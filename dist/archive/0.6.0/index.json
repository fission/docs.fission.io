[
{
	"uri": "https://docs.fission.io/0.6.0/",
	"title": "Fission",
	"tags": [],
	"description": "",
	"content": " Fission: Serverless Functions for Kubernetes fission.io @fissionio\nFission is a fast serverless framework for Kubernetes with a focus on developer productivity and high performance.\nFission operates on just the code: Docker and Kubernetes are abstracted away under normal operation, though you can use both to extend Fission if you want to.\nFission is extensible to any language; the core is written in Go, and language-specific parts are isolated in something called environments (more below). Fission currently supports NodeJS, Python, Ruby, Go, PHP, Bash, and any Linux executable, with more languages coming soon.\nPerformance: 100msec cold start Fission maintains a pool of \u0026ldquo;warm\u0026rdquo; containers that each contain a small dynamic loader. When a function is first called, i.e. \u0026ldquo;cold-started\u0026rdquo;, a running container is chosen and the function is loaded. This pool is what makes Fission fast: cold-start latencies are typically about 100msec.\nKubernetes is the right place for Serverless We\u0026rsquo;re built on Kubernetes because we think any non-trivial app will use a combination of serverless functions and more conventional microservices, and Kubernetes is a great framework to bring these together seamlessly.\nBuilding on Kubernetes also means that anything you do for operations on your Kubernetes cluster \u0026mdash; such as monitoring or log aggregation \u0026mdash; also helps with ops on your Fission deployment.\nFission Concepts A function is a piece of code that follows the fission function interface.\nAn environment contains the language- and runtime-specific parts of running a function.\nThe following environments are currently available:\n   Environment Image     Binary (for executables or scripts) fission/binary-env   Go fission/go-env   .NET fission/dotnet-env   .NET 2.0 fission/dotnet20-env   NodeJS (Alpine) fission/node-env   NodeJS (Debian) fission/node-env-debian   Perl fission/perl-env   PHP 7 fission/php-env   Python 3 fission/python-env   Ruby fission/ruby-env    You can also extend environments or create entirely new ones if you want. (An environment is essentially just a container with a webserver and dynamic loader.)\nA trigger is something that maps an event to a function; Fission supports HTTP routes as triggers today, with upcoming support for other types of event triggers, such as timers and Kubernetes events.\nUsage # Add the stock NodeJS env to your Fission deployment $ fission env create --name nodejs --image fission/node-env # A javascript one-liner that prints \u0026quot;hello world\u0026quot; $ curl https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js \u0026gt; hello.js # Upload your function code to fission $ fission function create --name hello --env nodejs --code hello.js # Map GET /hello to your new function $ fission route create --method GET --url /hello --function hello # Run the function. This takes about 100msec the first time. $ curl http://$FISSION_ROUTER/hello Hello, world!  See the examples directory for more.\n"
},
{
	"uri": "https://docs.fission.io/0.6.0/installation/",
	"title": "Installation Guide",
	"tags": [],
	"description": "",
	"content": " Installation Installing and upgrading Fission "
},
{
	"uri": "https://docs.fission.io/0.6.0/installation/installation/",
	"title": "Installation Guide",
	"tags": [],
	"description": "",
	"content": " Welcome! This guide will get you up and running with Fission on a Kubernetes cluster.\nCluster preliminaries If you don\u0026rsquo;t have a Kubernetes cluster, here\u0026rsquo;s a quick guide to set one up.\nLet\u0026rsquo;s ensure you have the Kubernetes CLI and Helm installed and ready. If you already have helm, skip ahead to the fission install.\nKubernetes CLI Ensure you have the Kubernetes CLI.\nYou can get the Kubernetes CLI for OSX like this:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Or, for Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Ensure you have access to a cluster; use kubectl to check your Kubernetes version:\n$ kubectl version  We need at least Kubernetes 1.6 (older versions may work, but we don\u0026rsquo;t test them).\nHelm Helm is an installer for Kubernetes. If you already use helm, skip to the next section.\nFirst, you\u0026rsquo;ll need the helm CLI:\nOn OS X:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.7.0-darwin-amd64.tar.gz $ tar xzf helm-v2.7.0-darwin-amd64.tar.gz $ mv darwin-amd64/helm /usr/local/bin  On Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.7.0-linux-amd64.tar.gz $ tar xzf helm-v2.7.0-linux-amd64.tar.gz $ mv linux-amd64/helm /usr/local/bin  Next, install the Helm server on your Kubernetes cluster:\n$ helm init  Install Fission Minikube $ helm install --namespace fission --set serviceType=NodePort https://github.com/fission/fission/releases/download/0.6.0/fission-all-0.6.0.tgz  The serviceType variable allows configuring the type of Kubernetes service outside the cluster. You can use ClusterIP if you don\u0026rsquo;t want to expose anything outside the cluster.\nCloud hosted clusters (GKE, AWS, Azure etc.) $ helm install --namespace fission https://github.com/fission/fission/releases/download/0.6.0/fission-all-0.6.0.tgz  Minimal version The fission-all helm chart installs a full set of services including the NATS message queue, influxDB for logs, etc. If you want a more minimal setup, you can install the fission-core chart instead:\n$ helm install --namespace fission https://github.com/fission/fission/releases/download/0.6.0/fission-core-0.6.0.tgz  Install the Fission CLI OS X Get the CLI binary for Mac:\n$ curl -Lo fission https://github.com/fission/fission/releases/download/0.6.0/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.6.0/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nRun an example Finally, you\u0026rsquo;re ready to use Fission!\n$ fission env create --name nodejs --image fission/node-env:0.6.0 $ curl -LO https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js $ fission function create --name hello --env nodejs --code hello.js $ fission function test --name hello Hello, world!  What\u0026rsquo;s next? If something went wrong, we\u0026rsquo;d love to help \u0026ndash; please drop by the slack channel and ask for help.\nCheck out the examples for some example functions.\n"
},
{
	"uri": "https://docs.fission.io/0.6.0/installation/kubernetessetup/",
	"title": "Kubernetes Quick Install",
	"tags": [],
	"description": "",
	"content": " This is a quick guide to help you get started running Kubernetes on your laptop (or on the cloud).\n(This isn\u0026rsquo;t meant as a production Kuberenetes guide; it\u0026rsquo;s merely intended to give you something quickly so you can try Fission on it.)\nMinikube Minikube is the usual way to run Kubernetes on your laptop:\nInstall and start Kubernetes on OSX: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.16.0/minikube-darwin-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Or, install and start Kubernetes on Linux: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.16.0/minikube-linux-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Google Container Engine Alternatively, you can use Google Container Engine\u0026rsquo;s free trial to get a 3-node cluster. Hop over to Google Cloud to set that up.\n"
},
{
	"uri": "https://docs.fission.io/0.6.0/installation/releasenotes/",
	"title": "Release notes",
	"tags": [],
	"description": "",
	"content": "  The fission team is on http://slack.fission.io if you have any questions.  0.4.0  This release is compatible with Kubernetes 1.7 onwards. We switched from ThirdPartyResources to CustomResourceDefinitions. ThirdPartyResources are removed in Kubernetes 1.8, so upgrade with caution, using the upgrade guide below. Upgrade guides:  Upgrade guide from 0.3.0 To upgrade from 0.2.1, please upgrade to 0.3.0 first, following the upgrade guide in the 0.3.0 release.   0.3.0 Note: This release is incompatible with Kubernetes 1.8 (Because it uses ThirdPartyResources; see #314)\nThis release introduces:\n Build pipeline. Currently, only the Python environment supports this. Workflow engine support (compatible with fission-workflows 0.1.1)  v0.2.1 Lots of big changes in this release!\n Most importantly, the API has changed a lot. We switched to Kubernetes ThirdPartyResources, and improved various pieces of the API to support new environments.\n The old API was too different from widely used Kubernetes patterns, and so we decided to fully break compatibility for this release. We\u0026rsquo;re still in alpha, so you should expect the occasional API breakage; we\u0026rsquo;ll be better at preserving compatibility once we reach beta.\n The CLI is still compatible. Environments are also still compatible \u0026ndash; environment images that worked before continue to work.\n We\u0026rsquo;re creating an upgrade tool to help migrate; if you\u0026rsquo;re upgrading v0.1.0 and can\u0026rsquo;t do a fresh install, wait for the upgrade tool.\n We now use Helm for installation instead of a set of YAML files.\n The Fission \u0026ldquo;controller\u0026rdquo; is now stateless. Fission\u0026rsquo;s etcd deployment is removed, since Fission stores state in ThirdPartyResources. Large function files are stored in a new function storage service, which uses a persistent volume.\n And, we\u0026rsquo;ve started a new docs site; for now it\u0026rsquo;s just the installation and upgrade guides, but we\u0026rsquo;ll be writing more docs soon.\n  "
},
{
	"uri": "https://docs.fission.io/0.6.0/concepts/",
	"title": "Fission Concepts",
	"tags": [],
	"description": "",
	"content": " Fission Concepts This is an overview of the few main concepts in Fission: Functions, Environments, and Triggers.\n"
},
{
	"uri": "https://docs.fission.io/0.6.0/installation/upgrade/",
	"title": "Upgrade",
	"tags": [],
	"description": "",
	"content": " From v0.4.x to v0.5.0  Upgrade guide  From v0.3 to v0.4.x  Upgrade guide  From v0.1 to v0.2.x  Upgrade guide  "
},
{
	"uri": "https://docs.fission.io/0.6.0/installation/upgrade/upgrade-from-v0.1/",
	"title": "Upgrading from v0.1 to v0.2.x",
	"tags": [],
	"description": "",
	"content": " TL;DR The Fission API has changed significantly in this version. The new API is incompatible with the old one. The CLI is compatible; if you wrote scripts using it, those should still work.\nBelow we describe a tool for migrating your state from your old install to the new one.\nWhile this upgrade is going to be disruptive, we\u0026rsquo;re going to do our best to make sure future upgrades aren\u0026rsquo;t as bad.\nWhy is this so complicated? For a couple of reasons, we wanted to switch to using Kubernetes resources (ThirdPartyResources now, CustomResources in the next release) for storing Fission state: (a) it would allow users to avoid management of another database and (b) Fission would fit better into the Kubernetes ecosystem.\nConcurrently with this change, we were also trying to make our versioning approach less opinionated, so it would work with other tools.\nThirdly, we were also enabling build pipelines (v2 Environments).\nThese changes, especially the difference in versioning approach, made maintaining compatiblity not worth the effort at this early stage of the project.\nAll that said, we want you to know that we care a lot about compatiblity, and we\u0026rsquo;ll be more rigorous about it from the beta release onwards.\nHow to Upgrade  Get the v0.2.1 CLI Get the Fission state from your old install Install Fission v0.2.1 Restore Fission state into your new install Destroy your old install  Get the new CLI OS X $ curl -Lo fission https://github.com/fission/fission/releases/download/v0.2.1-rc/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/v0.2.1-rc/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nGet Fission state from v0.1 install fission --server \u0026lt;your V1 server\u0026gt; upgrade dump --file state.json  You can skip the \u0026ndash;server argument if you have the environment variable $FISSION_URL set to point at a v0.1 Fission server.\nThis will create a JSON file with all your fission state in the current directory.\nInstall the new version Read the install guide. You can follow all of it, except that you will need to ensure your two installs don\u0026rsquo;t conflict. To do that, use separate namespaces and ensure nodeports don\u0026rsquo;t conflict. Install with a command similar to this:\nhelm install fission-all --namespace fission2 --set controllerPort=31303,routerPort=31304,natsStreamingPort=31305,functionNamespace=fission2-function  This installs fission in the fission2 namespace and runs functions in the fission2-function namespace.\nRestore your Fission state into Fission v0.2.1 fission upgrade restore --file state.json  This commands needs $FISSION_URL set to point to new fission installation.\nIt uses the file created in the first step. It doesn\u0026rsquo;t modify state.json.\n(Note that you can run this restore on any cluster; it doesn\u0026rsquo;t have the be the same kubernetes cluster as your old install.)\nVerify How exactly you do this is up to you! But, at a minimum, run fission fn list to check that all the functions you expect are there.\nSwitch over If you had exposed fission\u0026rsquo;s router to the outside world, switch over to using the new install\u0026rsquo;s router.\nDestroy your old install Once you\u0026rsquo;re no longer using the old install, you can destroy it by deleting the namespaces that was installed in.\nkubectl delete namespace fission fission-function  "
},
{
	"uri": "https://docs.fission.io/0.6.0/concepts/environments/",
	"title": "Environments",
	"tags": [],
	"description": "",
	"content": "An environment contains the language and runtime specific parts of a function. An environment is essentially a container with a webserver and a dynamic loader for the function code.\nThe following pre-built environments are currently available for use in Fission:\n   Environment Image     Binary (for executables or scripts) fission/binary-env   Go fission/go-env   .NET fission/dotnet-env   .NET 2.0 fission/dotnet20-env   NodeJS (Alpine) fission/node-env   NodeJS (Debian) fission/node-env-debian   Perl fission/perl-env   PHP 7 fission/php-env   Python 3 fission/python-env   Ruby fission/ruby-env    To create custom environments you can extend one of the environments in the list or create your own environment from scratch.\n"
},
{
	"uri": "https://docs.fission.io/0.6.0/installation/upgrade/upgrade-from-v0.3/",
	"title": "Upgrading from v0.3 to v0.4.x",
	"tags": [],
	"description": "",
	"content": " Introduction Kubernetes ThirdPartyResources (\u0026ldquo;TPR\u0026rdquo;) are replaced by CustomResourceDefinitions (\u0026ldquo;CRD\u0026rdquo;). TPRs have been deprecated and are removed in Kubernetes 1.8.\nSince Fission stores state in TPRs, we need to migrate this state from TPRs to CRDs while upgrading.\nFollow the instructions below if you\u0026rsquo;re upgrading a Fission 0.2.1 or 0.3.0 cluster to 0.4. If you\u0026rsquo;re using a pre-0.2 Fission cluster, use the [upgrade guide from 0.1 to 0.2]() and then upgrade to 0.4.0.\nHow to Upgrade  Get the 0.4.0 CLI Get the Fission state from v0.3 install Upgrade to Fission 0.4.0 Upgrade Kubernetes cluster version to 1.7.x or higher Remove all TPR definition (for Kubernetes 1.7.x) Restore Fission state into CRDs  Get the new CLI OS X $ curl -Lo fission https://github.com/fission/fission/releases/download/0.4.0/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.4.0/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nGet Fission state from v0.3 install fission --server \u0026lt;your v0.3 server\u0026gt; tpr2crd dump --file state.json  You can skip the \u0026ndash;server argument if you have the environment variable $FISSION_URL set to point at a v0.3 Fission server.\nThis will create a JSON file with all your fission state in the current directory.\nUpgrade to Fission 0.4.0 Upgrade fission with a command similar to this:\nhelm upgrade fission-all --namespace fission  Upgrade Kubernetes cluster version Since CustomResource is only supported on Kubernetes v1.7+ and higher, please make sure that you upgrade to the right version that supports CustomResource.\nRemove all TPR definition (for Kubernetes 1.7.x) ** NOTICE **: This step will remove TPR definition from your kubernetes cluster. Please make sure that you dump all TPRs at the second step!\nThough Kubernetes will migrate TPRs to CRDs automatically when TPR definition is deleted if the same name CRD exists. We still need to make sure that there is no resource gets lost during the migration. Also, since we changed the capitalization of some CRDs to CamelCase (e.g. Httptrigger -\u0026gt; HTTPTrigger), we need to recreate those resources by ourselves.\nfission tpr2crd delete  Restore your Fission state into Fission 0.4.0 fission tpr2crd restore --file state.json  This commands needs $FISSION_URL set to point to new fission installation.\nIt uses the file created in the first step. It doesn\u0026rsquo;t modify state.json.\n(Note that you can run this restore on any cluster; it doesn\u0026rsquo;t have the be the same kubernetes cluster as your old install.)\nVerify Let\u0026rsquo;s check the migration result, first run following command to check CRD established state.\nkubectl get crd -o 'custom-columns=NAME:{.metadata.name},ESTABLISHED:{.status.conditions[?(@.type==\u0026quot;Established\u0026quot;)].status}'  The output should be like this\nNAME ESTABLISHED environments.fission.io True functions.fission.io True httptriggers.fission.io True kuberneteswatchtriggers.fission.io True messagequeuetriggers.fission.io True packages.fission.io True timetriggers.fission.io True  And check that CRD resources you expect are there.\nCOMMAND: fission [resource] list RESOURCES: environments functions httptriggers kuberneteswatchtriggers messagequeuetriggers packages timetriggers  "
},
{
	"uri": "https://docs.fission.io/0.6.0/concepts/executor/",
	"title": "Controlling Function Execution",
	"tags": [],
	"description": "",
	"content": " Executors When you create a function, you can specify an executor for a function. An executor controls how function pods are created and what capabilities are available for that executor type.\nPool-based executor A pool based executor (Refered to as poolmgr) creates a pool of generic environment pods as soon as you create an environment. The pool size of initial \u0026ldquo;warm\u0026rdquo; containers can be configured based on user needs. These warm containers contain a small dynamic loader for loading the function. Resource requirements are specified at environment level and are inherited by specialized function pods.\nOnce you create a function and invoke it, one of pods from the pool is taken out and \u0026ldquo;specialized\u0026rdquo; and used for execution. This pod is used for subseqnent requests for that function. If there are no more requests for a certain idle duration, then this pod is cleaned up. If a new requests come after the earlier specialized pod was cleaned up, then a new pod is specialised from the pool and used for execution.\nPoolmgr executortype is great for functions where lower latency is a requirement. Poolmgr executortype has certain limitations: for example, you can not autoscale them based on demand.\nNew-deployment executor New-Deployment executor (Newdeploy) creates a Kubernetes Deployment along with a Service and HorizontalPodAutoscaler for function execution. This enables autoscaling of function pods and load balancing the requests between pods. In future additional capabilities will be added for newdeploy executortype such as support for volume etc. In the new-deploy executor, resource requirements can be specified at the function level. These requirements override those specified in the environment.\nNewdeploy executortype can be used for requests with no particular low-latency requirements, such as those invoked asynchronously, minscale can be set to zero. In this case the Kubernetes deployment and other objects will be created on first invocation of the function. Subsequent requests can be served by the same deployment. If there are no requests for certain duration then the idle objects are cleaned up. This mechanism ensures resource consumption only on demand and is a good fit for asynchronous requests.\nFor requests where latency requirements are stringent, a minscale greater than zero can be set. This essentially keeps a minscale number of pods ready when you create a function. When the function is invoked, there is no delay since the pod is already created. Also minscale ensures that the pods are not cleaned up even if the function is idle. This is great for functions where lower latency is more important than saving resource consumption when functions are idle.\nThe latency vs. idle-cost tradeoff The executors allow you as a user to decide between latency and a small idle cost tradeoff. Depending on the need you can choose one of the combinations which is optimal for your use case. In future, a more intelligent dispatch mechanism will enable more complex combinations of executors.\n   Executor Type Min Scale Latency Idle cost     Newdeploy 0 High Very low - pods get cleaned up after idlle time   Newdeploy \u0026gt;0 Low Medium, Min Scale number of pods are always up   Poolmgr 0 Low Low, pool of pods are always up    Autoscaling The new deployment based executor provides autoscaling for functions based on CPU usage. In future custom metrics will be also supported for scaling the functions. You can set the intial and maximum CPU for a function and target CPU at which autoscaling will be trigerred. Autoscaling is useful for workloads where you expect intermittant spikes in workloads. It also enables optimal usage of resources to execute functions, by using a baseline capacity with minimum scale and ability to burst up to maximum scale based on spikes in demand.\n"
},
{
	"uri": "https://docs.fission.io/0.6.0/installation/upgrade/upgrade-from-v0.4/",
	"title": "Upgrading from v0.4.x to v0.5.0",
	"tags": [],
	"description": "",
	"content": " How to Upgrade  Get the 0.5.0 CLI Upgrade to Fission 0.5.0  Get the new CLI OS X $ curl -Lo fission https://github.com/fission/fission/releases/download/0.5.0/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.5.0/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nUpgrade to Fission 0.5.0 Upgrade fission with a command similar to this:\n# find the release want to upgrade $ helm list # upgrade to 0.5.0 $ helm upgrade \u0026lt;release_name\u0026gt; https://github.com/fission/fission/releases/download/0.5.0/fission-all-0.5.0.tgz  "
},
{
	"uri": "https://docs.fission.io/0.6.0/concepts/trigger/",
	"title": "Trigger",
	"tags": [],
	"description": "",
	"content": " Triggers are events that can invoke a function. Fission has three kinds of triggers that can be used to invoke functions.\nHttp Trigger HTTP triggers enable calling functions with HTTP requests. Supported methods are GET, POST, PUT, DELETE, HEAD and by default GET is used. URL pattern follow the gorilla/mux supported patterns.\nTime Trigger If you want a function to be called at a periodic frequency then the time triggers are perfect for the use case. Time triggers follow cron like specifications and are invoked based on the cron schedule.\nTime trigger based invocations are great for running scheduled jobs, periodic cleanup jobs, periodic polling based invocations etc.\nMQ Trigger Message queue based trigger enables ability to listen on a topic and invoke a function for each message. You can optinally send a response to another topic. By default it is assumed that the messages in queue are in application/json format but you can specify otherwise while creating the trigger. Currently nats-streaming and azure-storage-queue are supported message queues supported.\nMQ triggers are great for integrating various systems in a decoupled and asynchronous manner.\n"
},
{
	"uri": "https://docs.fission.io/0.6.0/concepts/package/",
	"title": "Builder and Packages",
	"tags": [],
	"description": "",
	"content": "Most real world applications are more than a single file of code and typically have dependencies on libraries etc. Packages in fission solve three distinct problems:\n1) Enable a mechanism to store more than one file as a single unit and use them with functions. This is done through a combination of deployment archive builder environment associated with the environment.\n2) Provide a mechanism to build from source code and dependencies into a binary based on a build command and store it as an object. User should be able to use this built artifact with a function. This is achieved with a source archive and a builder environment.\n3) Decouple the execution logic from the functions and thus enable reuse of same logic for multiple functions. This will enable user to run same logic with different functions having different runtime charateristics and executor types.\nWhen you create a function with a single source file, fission internally creates a package and links it to a function. Creating a package explicitly gives more flexibility in some use cases as explained above.\n"
},
{
	"uri": "https://docs.fission.io/0.6.0/usage/",
	"title": "Using Fission",
	"tags": [],
	"description": "",
	"content": " Using Fission Usage guides, tutorials and examples "
},
{
	"uri": "https://docs.fission.io/0.6.0/usage/functions/",
	"title": "Function",
	"tags": [],
	"description": "",
	"content": " Create a function Before creating a function the environment should be created, we will assume that you have already created environment named node.\nLet\u0026rsquo;s create a simple code snippet in nodejs which will output Hello world:\nmodule.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, world!\\n\u0026quot; }; }  Let\u0026rsquo;s create a route for the function which can be used for making HTTP requests:\n$ fission route create --function hello --url /hello trigger '5327e9a7-6d87-4533-a4fb-c67f55b1e492' created  Let\u0026rsquo;s create a function based on pool based executor.\nfission fn create --name hello --code hello.js --env node --executortype poolmgr  When you hit this function\u0026rsquo;s URL , you get a response:\n$ curl http://$FISSION_ROUTER/hello Hello, world!  Similarly you can create a new deployment executor type function and provide minmum and maximum scale for the function.\nfission fn create --name hello --code hello.js --env node --minscale 1 --maxscale 5 --executortype newdeploy  View \u0026amp; update function source code You can look at the source code associated with given function:\n$ fission fn get --name hello module.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, world!\\n\u0026quot; }; }  Let\u0026rsquo;s say you want to update the function to output \u0026ldquo;Hello Fission\u0026rdquo; instead of \u0026ldquo;Hello world\u0026rdquo;, you can update the source file and update the source code for function:\n$ fission fn update --name hello --code ../hello.js package 'hello-js-ku9s' updated function 'hello' updated  Let\u0026rsquo;s verify that the function now respond with a different output than earlier:\n$ curl http://$FISSION_ROUTER/hello Hello, Fission!  Test and debug function You can directly test a function using test command. If the function call succeeds, it will output the function\u0026rsquo;s response.\n$ fission fn test --name hello Hello, Fission!  But if there is an error in function execution then the logs of function execution are displayed:\n$ fission fn test --name hello Error calling function hello: 500 Internal server error (fission) \u0026gt; fission-nodejs-runtime@0.1.0 start /usr/src/app \u0026gt; node server.js Codepath defaulting to /userfunc/user Port defaulting to 8888 user code load error: SyntaxError: Unexpected token function ::ffff:10.8.1.181 - - [16/Feb/2018:08:44:33 +0000] \u0026quot;POST /specialize HTTP/1.1\u0026quot; 500 2 \u0026quot;-\u0026quot; \u0026quot;Go-http-client/1.1\u0026quot;  You can also look at function execution logs explicitly:\n$ fission fn logs --name hello [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 fetcher received fetch request and started downloading: {1 {hello-js-rqew default 0 0001-01-01 00:00:00 +0000 UTC \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; map[] map[] [] nil [] } user [] []} [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Successfully placed at /userfunc/user [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Checking secrets/cfgmaps [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Completed fetch request [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 elapsed time in fetch request = 89.844653ms [2018-02-16 08:41:43 +0000 UTC] user code loaded in 0sec 4.235593ms [2018-02-16 08:41:43 +0000 UTC] ::ffff:10.8.1.181 - - [16/Feb/2018:08:41:43 +0000] \u0026quot;POST /specialize HTTP/1.1\u0026quot; 202 - \u0026quot;-\u0026quot; \u0026quot;Go-http-client/1.1\u0026quot; [2018-02-16 08:41:43 +0000 UTC] ::ffff:10.8.1.182 - - [16/Feb/2018:08:41:43 +0000] \u0026quot;GET / HTTP/1.1\u0026quot; 200 16 \u0026quot;-\u0026quot; \u0026quot;curl/7.54.0\u0026quot;  Fission builds \u0026amp; compiled artifacts Most real world functions will require more than one source files. It is also easier to simply provide source files and let Fission take care of building from source files. Fission provides first class support for building from source as well as using compiled artifacts to create functions.\nYou can attach the source/deployment packages to a function or explicitly create packages and use them across functions. Check documentation for package for more information.\nBuilding function from source Let\u0026rsquo;s take a simple python function which has dependency on a python pyyaml module. We can specify the dependencies in requirements.txt and a simple command to build from source. The tree structure of directory looks like:\nsourcepkg/ ├── __init__.py ├── build.sh ├── requirements.txt └── user.py  And the file contents:\n$ cat user.py import sys import yaml document = \u0026quot;\u0026quot;\u0026quot; a: 1 b: c: 3 d: 4 \u0026quot;\u0026quot;\u0026quot; def main(): return yaml.dump(yaml.load(document)) $ cat requirements.txt pyyaml $ cat build.sh #!/bin/sh pip3 install -r ${SRC_PKG}/requirements.txt -t ${SRC_PKG} \u0026amp;\u0026amp; cp -r ${SRC_PKG} ${DEPLOY_PKG}  You first need to create an environment with environment image and python-builder image specified:\n$fission env create --name python --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2  Now let\u0026rsquo;s zip the directory containing the source files and create a function with source package:\n$zip -jr demo-src-pkg.zip sourcepkg/ adding: __init__.py (stored 0%) adding: build.sh (deflated 24%) adding: requirements.txt (stored 0%) adding: user.py (deflated 25%) $ fission fn create --name hellopy --env python --src demo-src-pkg.zip --entrypoint \u0026quot;user.main\u0026quot; --buildcmd \u0026quot;./build.sh\u0026quot; function 'hellopy' created $ fission route create --function hellopy --url /hellopy  Once we create the function, the build process is started. You can check logs of the builder in fission-builder namespace:\n$ k -n fission-builder logs -f py3-4214348-59555d9bd8-ks7m4 builder 2018/02/16 11:44:21 Builder received request: {demo-src-pkg-zip-ninf-djtswo ./build.sh} 2018/02/16 11:44:21 Starting build... === Build Logs ===command=./build.sh env=[PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=py3-4214348-59555d9bd8-ks7m4 PYTHON_4212095_PORT_8000_TCP_PROTO=tcp PY3_4214348_SERVICE_HOST=10.11.250.161 KUBERNETES_PORT=tcp://10.11.240.1:443 PYTHON_4212095_PORT=tcp://10.11.244.134:8000 PYTHON_4212095_PORT_8000_TCP=tcp://10.11.244.134:8000 PYTHON_4212095_PORT_8001_TCP_PROTO=tcp PYTHON_4212095_PORT_8001_TCP_ADDR=10.11.244.134 PY3_4214348_SERVICE_PORT=8000 PY3_4214348_SERVICE_PORT_BUILDER_PORT=8001 PY3_4214348_PORT_8001_TCP=tcp://10.11.250.161:8001 KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_ADDR=10.11.240.1 PY3_4214348_SERVICE_PORT_FETCHER_PORT=8000 PY3_4214348_PORT_8000_TCP=tcp://10.11.250.161:8000 PY3_4214348_PORT_8001_TCP_PORT=8001 PYTHON_4212095_SERVICE_PORT_FETCHER_PORT=8000 PYTHON_4212095_PORT_8000_TCP_ADDR=10.11.244.134 KUBERNETES_SERVICE_HOST=10.11.240.1 PY3_4214348_PORT=tcp://10.11.250.161:8000 PYTHON_4212095_SERVICE_PORT_BUILDER_PORT=8001 PYTHON_4212095_PORT_8001_TCP=tcp://10.11.244.134:8001 PY3_4214348_PORT_8000_TCP_PROTO=tcp PY3_4214348_PORT_8000_TCP_PORT=8000 KUBERNETES_SERVICE_PORT_HTTPS=443 KUBERNETES_PORT_443_TCP=tcp://10.11.240.1:443 PYTHON_4212095_PORT_8001_TCP_PORT=8001 PY3_4214348_PORT_8000_TCP_ADDR=10.11.250.161 PY3_4214348_PORT_8001_TCP_PROTO=tcp KUBERNETES_SERVICE_PORT=443 PYTHON_4212095_SERVICE_PORT=8000 PYTHON_4212095_PORT_8000_TCP_PORT=8000 PY3_4214348_PORT_8001_TCP_ADDR=10.11.250.161 KUBERNETES_PORT_443_TCP_PROTO=tcp PYTHON_4212095_SERVICE_HOST=10.11.244.134 HOME=/root SRC_PKG=/packages/demo-src-pkg-zip-ninf-djtswo DEPLOY_PKG=/packages/demo-src-pkg-zip-ninf-djtswo-c40gfu] Collecting pyyaml (from -r /packages/demo-src-pkg-zip-ninf-djtswo/requirements.txt (line 1)) Downloading PyYAML-3.12.tar.gz (253kB) Installing collected packages: pyyaml Running setup.py install for pyyaml: started Running setup.py install for pyyaml: finished with status 'done' Successfully installed pyyaml-3.12 ================== 2018/02/16 11:44:24 elapsed time in build request = 3.460498847s  Once the build has succeeded, you can hit the function URL to test the function:\n$curl http://$FISSION_ROUTER/hellopy a: 1 b: {c: 3, d: 4}  Using compiled artifacts with Fission In some cases you have a pre-built deployment package which you need to deploy to Fission. For this example let\u0026rsquo;s use a simple python file as a deployment package but in practice it can be any other compiled package.\nWe will use a simple python file in a directory and turn it into a deployment package:\n$ cat testDir/hello.py def main(): return \u0026quot;Hello, world!\u0026quot; $zip -jr demo-deploy-pkg.zip testDir/  Let\u0026rsquo;s use the deployment package to create a function and route and then test it.\n$ fission fn create --name hellopy --env python --deploy demo-deploy-pkg.zip --entrypoint \u0026quot;hello.main\u0026quot; function 'hellopy' created $ fission route create --function hellopy --url /hellopy $ curl http://$FISSION_ROUTER/hellopy Hello, world!  View function information You can retrieve metadata information of a single function or list all functions to look at basic information of functions:\n$ fission fn getmeta --name hello NAME UID ENV hello 34234b50-12f5-11e8-85c9-42010aa00010 node $ fission fn list NAME UID ENV EXECUTORTYPE MINSCALE MAXSCALE TARGETCPU hello 34234b50-12f5-11e8-85c9-42010aa00010 node poolmgr 0 1 80 hello2 e37a46e3-12f4-11e8-85c9-42010aa00010 node newdeploy 1 5 80  "
},
{
	"uri": "https://docs.fission.io/0.6.0/tutorial/enabling-istio-on-fission/",
	"title": "Enabling Istio on Fission",
	"tags": [],
	"description": "",
	"content": " This is the very first step for fission to integrate with Istio. For those interested in trying to integrate fission with istio, following is the set up tutorial.\nTest Environment  Google Kubernetes Engine: 1.9.2-gke.1  Set Up Create Kubernetes v1.9+ cluster Enable both RBAC \u0026amp; initializer features on kubernetes cluster.\n$ export ZONE=\u0026lt;zone name\u0026gt; $ gcloud container clusters create istio-demo-1 \\ --machine-type=n1-standard-2 \\ --num-nodes=1 \\ --no-enable-legacy-authorization \\ --zone=$ZONE \\ --cluster-version=1.9.2-gke.1  Grant cluster admin permissions Grant admin permission for system:serviceaccount:kube-system:default and current user.\n# for system:serviceaccount:kube-system:default $ kubectl create clusterrolebinding --user system:serviceaccount:kube-system:default kube-system-cluster-admin --clusterrole cluster-admin # for current user $ kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value core/account)  Set up Istio environment For Istio 0.5.1 you can follow the installation tutorial below. Also, you can follow the latest installation guides on Istio official site: Quick Start and Sidecar Injection.\nDownload Istio 0.5.1\n$ export ISTIO_VERSION=0.5.1 $ curl -L https://git.io/getLatestIstio | sh - $ cd istio-0.5.1  Apply istio related YAML files\n$ kubectl apply -f install/kubernetes/istio.yaml  Automatic sidecar injection\n$ kubectl api-versions | grep admissionregistration admissionregistration.k8s.io/v1beta1  Installing the webhook\nDownload the missing files in istio release 0.5.1\n$ wget https://raw.githubusercontent.com/istio/istio/master/install/kubernetes/webhook-create-signed-cert.sh -P install/kubernetes/ $ wget https://raw.githubusercontent.com/istio/istio/master/install/kubernetes/webhook-patch-ca-bundle.sh -P install/kubernetes/ $ chmod +x install/kubernetes/webhook-create-signed-cert.sh install/kubernetes/webhook-patch-ca-bundle.sh  Install the sidecar injection configmap.\n$ ./install/kubernetes/webhook-create-signed-cert.sh \\ --service istio-sidecar-injector \\ --namespace istio-system \\ --secret sidecar-injector-certs $ kubectl apply -f install/kubernetes/istio-sidecar-injector-configmap-release.yaml  Install the sidecar injector\n$ cat install/kubernetes/istio-sidecar-injector.yaml | \\ ./install/kubernetes/webhook-patch-ca-bundle.sh \u0026gt; \\ install/kubernetes/istio-sidecar-injector-with-ca-bundle.yaml $ kubectl apply -f install/kubernetes/istio-sidecar-injector-with-ca-bundle.yaml # Check sidecar injector status $ kubectl -n istio-system get deployment -listio=sidecar-injector NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE istio-sidecar-injector 1 1 1 1 26s  Install fission Set default namespace for helm installation, here we use fission as example namespace.\n$ export FISSION_NAMESPACE=fission  Create namespace \u0026amp; add label for Istio sidecar injection.\n$ kubectl create namespace $FISSION_NAMESPACE $ kubectl label namespace $FISSION_NAMESPACE istio-injection=enabled $ kubectl config set-context $(kubectl config current-context) --namespace=$FISSION_NAMESPACE  Follow the installation guide to install fission with flag enableIstio true.\n$ helm install --namespace $FISSION_NAMESPACE --set enableIstio=true --name istio-demo \u0026lt;chart-fission-all-url\u0026gt;  Create a function Set environment\n$ export FISSION_URL=http://$(kubectl --namespace fission get svc controller -o=jsonpath='{..ip}') $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..ip}')  Let\u0026rsquo;s create a simple function with Node.js.\n# hello.js module.exports = async function(context) { console.log(context.request.headers); return { status: 200, body: \u0026quot;Hello, World!\\n\u0026quot; }; }  Create environment\n$ fission env create --name nodejs --image fission/node-env:latest  Create function\n$ fission fn create --name h1 --env nodejs --code hello.js --method GET  Create route\n$ fission route create --method GET --url /h1 --function h1  Access function\n$ curl http://$FISSION_ROUTER/h1 Hello, World!  Install Istio Add-ons  Prometheus  $ kubectl apply -f istio-0.5.1/install/kubernetes/addons/prometheus.yaml $ kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') 9090:9090  Web Link: http://127.0.0.1:9090/graph\n Grafana  Please install Prometheus first.\n$ kubectl apply -f istio-0.5.1/install/kubernetes/addons/grafana.yaml $ kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=grafana -o jsonpath='{.items[0].metadata.name}') 3000:3000  Web Link: http://127.0.0.1:3000/dashboard/db/istio-dashboard\n Jaegar  $ kubectl apply -n istio-system -f https://raw.githubusercontent.com/jaegertracing/jaeger-kubernetes/master/all-in-one/jaeger-all-in-one-template.yml $ kubectl port-forward -n istio-system $(kubectl get pod -n istio-system -l app=jaeger -o jsonpath='{.items[0].metadata.name}') 16686:16686  Web Link: http://localhost:16686\n"
},
{
	"uri": "https://docs.fission.io/0.6.0/usage/environments/",
	"title": "Environment",
	"tags": [],
	"description": "",
	"content": " Create an environment You can create an environment on your cluster from an image for that language. Optionally, you can specify CPU and memory resource limits. You can also specify the number of initially pre-warmed pods, which is called the poolsize.\nfission env create --name node --image fission/node-env:0.4.0 --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 4  In case of pool based executor, the resources specified for environment are used for function pod as well. In case of new deployment executor, you can override the resources when you create a function.\nUsing a builder When you create an environment, you can specify a builder image and builder command which will be used for building from source code. You can override the build command when creating a function. For more details on builder and packages you should check out examples in Functions and packages\nfission env create --name python --image fission/python-env:latest --builder fission/python-builder:latest  Viewing environment information You can list the environments or view information of an individual environment:\n$ fission env list NAME UID IMAGE POOLSIZE MINCPU MAXCPU MINMEMORY MAXMEMORY node ac84d62e-001f-11e8-85c9-42010aa00010 fission/node-env:0.4.0 4 40m 80m 64Mi 128Mi $ $ fission env get --name node NAME UID IMAGE node ac84d62e-001f-11e8-85c9-42010aa00010 fission/node-env:0.4.0  "
},
{
	"uri": "https://docs.fission.io/0.6.0/usage/executor/",
	"title": "Controlling Function Execution",
	"tags": [],
	"description": "",
	"content": " Autoscaling Let\u0026rsquo;s create a function to demonstrate the autoscaling behaviour in Fission. We create a simple function which outputs \u0026ldquo;Hello World\u0026rdquo; in using NodeJS. We have kept the CPU request and limit purposefully low to simulate the load and also kept the target CPU percent to 50%.\n$ fission fn create --name hello --env node --code hello.js --mincpu 10 --maxcpu 40 --minmemory 64 --maxmemory 128 --minscale 1 --maxscale 6 --executortype newdeploy --targetcpu 50 function 'hello' created  Now let\u0026rsquo;s use hey to generate the load with 250 concurrent and a total of 10000 requests:\n$ hey -c 250 -n 10000 http://$FISSION_ROUTER/hello Summary: Total:\t67.3535 secs Slowest:\t4.6192 secs Fastest:\t0.0177 secs Average:\t1.6464 secs Requests/sec:\t148.4704 Total data:\t160000 bytes Size/request:\t16 bytes Response time histogram: 0.018 [1]\t| 0.478 [486]\t|∎∎∎∎∎∎∎ 0.938 [971]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 1.398 [2686]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 1.858 [2326]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 2.318 [1641]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 2.779 [1157]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 3.239 [574]\t|∎∎∎∎∎∎∎∎∎ 3.699 [120]\t|∎∎ 4.159 [0]\t| 4.619 [38]\t|∎ Latency distribution: 10% in 0.7037 secs 25% in 1.1979 secs 50% in 1.5038 secs 75% in 2.1959 secs 90% in 2.6670 secs 95% in 2.8855 secs 99% in 3.4102 secs Details (average, fastest, slowest): DNS+dialup:\t0.0058 secs, 0.0000 secs, 1.0853 secs DNS-lookup:\t0.0000 secs, 0.0000 secs, 0.0000 secs req write:\t0.0000 secs, 0.0000 secs, 0.0026 secs resp wait:\t1.6405 secs, 0.0176 secs, 3.6144 secs resp read:\t0.0001 secs, 0.0000 secs, 0.0056 secs Status code distribution: [200]\t10000 responses  While the load is being generated, we will watch the HorizontalPodAutoscaler and how it scales over period of time. As you can notice, the number of pods is scaled from 1 to 3 after the load rises from 8 - 103%. After the load generator stops, it takes a few iterations to scale down from 3 to 1 pod.\n$ k -n fission-function get hpa -w NAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGE hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 1 3m hello-qoxmothj Deployment/hello-qoxmothj 8% / 50% 1 6 1 3m hello-qoxmothj Deployment/hello-qoxmothj 103% / 50% 1 6 1 4m hello-qoxmothj Deployment/hello-qoxmothj 103% / 50% 1 6 3 5m hello-qoxmothj Deployment/hello-qoxmothj 25% / 50% 1 6 3 5m hello-qoxmothj Deployment/hello-qoxmothj 25% / 50% 1 6 3 6m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 6m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 7m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 7m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 8m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 8m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 9m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 9m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 10m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 10m hello-qoxmothj Deployment/hello-qoxmothj 7% / 50% 1 6 1 11m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 11m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 12m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 12m  "
},
{
	"uri": "https://docs.fission.io/0.6.0/usage/trigger/",
	"title": "Triggers",
	"tags": [],
	"description": "",
	"content": " Create a HTTP Trigger You can create a HTTP trigger with default method (GET) for a function:\n$ fission ht create --url /hello --function hello trigger '94cd5163-30dd-4fb2-ab3c-794052f70841' created  Create a Time Trigger Time based triggers can be created with cron specifications:\n$ fission tt create --name halfhourly --function hello --cron \u0026quot;0 30 * * *\u0026quot; trigger 'halfhourly' created  Also a more friendly syntax such \u0026ldquo;every 1m\u0026rdquo; or \u0026ldquo;@hourly\u0026rdquo; can be used to create a time based trigger.\n$ fission tt create --name minute --function hello --cron \u0026quot;@every 1m\u0026quot; trigger 'minute' created  You can list time based triggers to inspect their associated function and cron specifications:\n$ fission tt list NAME CRON FUNCTION_NAME halfhourly 0 30 * * * hello minute @every 1m hello  Create a Message Queue Trigger A message queue trigger invokes a function based on messages from an message queue. Currently, NATS and Azure Storage Queue are supported queues. (Kafka support is under development.)\n$ fission mqt create --name hellomsg --function hello --mqtype nats-streaming --topic newfile --resptopic newfileresponse trigger 'hellomsg' created  You can list or update message queue triggers with fission mqt list, or fission mqt update.\n"
},
{
	"uri": "https://docs.fission.io/0.6.0/usage/package/",
	"title": "Packaging source code",
	"tags": [],
	"description": "",
	"content": " Creating source package Before you create a package, you need to create an environment with associated builder image:\n$ fission env create --name pythonsrc --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2 environment 'pythonsrc' created  Let\u0026rsquo;s take a simple python function which has dependency on a python pyyaml module. We can specify the dependencies in requirements.txt and a simple command to build from source. The tree structure of directory and contents of the file looks like:\nsourcepkg/ ├── __init__.py ├── build.sh ├── requirements.txt └── user.py  And the file contents:\n$ cat user.py import sys import yaml document = \u0026quot;\u0026quot;\u0026quot; a: 1 b: c: 3 d: 4 \u0026quot;\u0026quot;\u0026quot; def main(): return yaml.dump(yaml.load(document)) $ cat requirements.txt pyyaml $ cat build.sh #!/bin/sh pip3 install -r ${SRC_PKG}/requirements.txt -t ${SRC_PKG} \u0026amp;\u0026amp; cp -r ${SRC_PKG} ${DEPLOY_PKG} $zip -jr demo-src-pkg.zip sourcepkg/ adding: __init__.py (stored 0%) adding: build.sh (deflated 24%) adding: requirements.txt (stored 0%) adding: user.py (deflated 25%)  Using the source archive creared in previous step, you can create a package in Fission:\n$ fission package create --sourcearchive demo-src-pkg.zip --env pythonsrc --buildcmd \u0026quot;./build.sh\u0026quot; Package 'demo-src-pkg-zip-8lwt' created  Since we are working with source package, we provided the build command. Once you create the package, the build process will start and you can check the build logs by getting information of the package:\n$ fission pkg info --name demo-src-pkg-zip-8lwt Name: demo-src-pkg-zip-8lwt Environment: pythonsrc Status: succeeded Build Logs: Collecting pyyaml (from -r /packages/demo-src-pkg-zip-8lwt-v57qil/requirements.txt (line 1)) Using cached PyYAML-3.12.tar.gz Installing collected packages: pyyaml Running setup.py install for pyyaml: started Running setup.py install for pyyaml: finished with status 'done' Successfully installed pyyaml-3.12  Using the package above you can create the function. Since package already is associated with a source package, environment and build command, these will be ignored when creating a function. Only addition thing you will need to provide is the entrypoint. Assuming you hace created the route, the function should be reachable with successful output:\n$ fission fn create --name srcpy --pkg demo-src-pkg-zip-8lwt --entrypoint \u0026quot;user.main\u0026quot; function 'srcpy' created $ curl http://$FISSION_ROUTER/srcpy a: 1 b: {c: 3, d: 4}  Creating deployment package Before you create a package you need to create an environment with the builder image:\n$ fission env create --name pythondeploy --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2 environment 'pythonsrc' created  We will use a simple Python example which outputs \u0026ldquo;Hello World!\u0026rdquo; in a directory to create a deployment archive:\n$ cat testDir/hello.py def main(): return \u0026quot;Hello, world!\u0026quot; $zip -jr demo-deploy-pkg.zip testDir/  Using the archive and environments created previously, you can create a package:\n$ fission package create --deployarchive demo-deploy-pkg.zip --env pythondeploy Package 'demo-deploy-pkg-zip-whzl' created  Since it is a deployment archive, there is no need to build it, hence the build logs for the package will be empty:\n$ fission package info --name demo-deploy-pkg-zip-whzl Name: demo-deploy-pkg-zip-xlaw Environment: pythondeploy2 Status: succeeded Build Logs:  Finally you can create a function with the package and test the function:\n$fission fn create --name deploypy --pkg demo-deploy-pkg-zip-whzl --entrypoint \u0026quot;hello.main\u0026quot; $curl http://$FISSION_ROUTER/deploypy Hello, world!  "
},
{
	"uri": "https://docs.fission.io/0.6.0/usage/access-secret-cfgmap-in-function/",
	"title": "Accessing Secrets in Functions",
	"tags": [],
	"description": "",
	"content": " Functions can access Kubernetes Secrets and ConfigMaps.\nUse secrets for things like API keys, authentication tokens, and so on.\nUse config maps for any other configuration that doesn\u0026rsquo;t need to be a secret.\nCreate A Secret or a ConfigMap You can create a Secret or ConfigMap with the Kubernetes CLI:\n$ kubectl -n default create secret generic my-secret --from-literal=TEST_KEY=\u0026quot;TESTVALUE\u0026quot; $ kubectl -n default create configmap my-configmap --from-literal=TEST_KEY=\u0026quot;TESTVALUE\u0026quot;  Or, use kubectl create -f \u0026lt;filename.yaml\u0026gt; to create these from a YAML file.\napiVersion: v1 kind: Secret metadata: namespace: default name: my-secret data: TEST_KEY: VEVTVFZBTFVF # value after base64 encode type: Opaque --- apiVersion: v1 kind: ConfigMap metadata: namespace: default name: my-configmap data: TEST_KEY: TESTVALUE  Accessing Secrets and ConfigMaps Secrets and configmaps are accessed similarly. Each secret or configmap is a set of key value pairs. Fission sets these up as files you can read from your function.\n# Secret path /secrets/\u0026lt;namespace\u0026gt;/\u0026lt;name\u0026gt;/\u0026lt;key\u0026gt; # ConfigMap path /configs/\u0026lt;namespace\u0026gt;/\u0026lt;name\u0026gt;/\u0026lt;key\u0026gt;  From the previous example, the paths are:\n# secret my-secret /secrets/default/my-secret/TEST_KEY # confimap my-configmap /configs/default/my-configmap/TEST_KEY  Now, let\u0026rsquo;s create a simple python function (leaker.py) that returns the value of Secret my-secret and ConfigMap my-configmap.\n# leaker.py def main(): path = \u0026quot;/configs/default/my-configmap/TEST_KEY\u0026quot; f = open(path, \u0026quot;r\u0026quot;) config = f.read() path = \u0026quot;/secrets/default/my-secret/TEST_KEY\u0026quot; f = open(path, \u0026quot;r\u0026quot;) secret = f.read() msg = \u0026quot;ConfigMap: %s\\nSecret: %s\u0026quot; % (config, secret) return msg, 200  Create an environment and a function:\n# create python env $ fission env create --name python --image fission/python-env # create function named \u0026quot;leaker\u0026quot; $ fission fn create --name leaker --env python --code leaker.py --secret my-secret --configmap my-configmap  Run the function, and the output should look like this:\n$ fission function test --name leaker ConfigMap: TESTVALUE Secret: TESTVALUE  If the Secret or ConfigMap value is updated, the function may not get the updated value for some time; it may get a cached older value.\n "
},
{
	"uri": "https://docs.fission.io/0.6.0/contributing/",
	"title": "Contributing to Fission",
	"tags": [],
	"description": "",
	"content": " Contributing to Fission Development guide "
},
{
	"uri": "https://docs.fission.io/0.6.0/contributing/compiling/",
	"title": "Compiling Fission",
	"tags": [],
	"description": "",
	"content": "[You only need to do this if you\u0026rsquo;re making Fission changes; if you\u0026rsquo;re just deploying Fission, use fission.yaml which points to prebuilt images.]\nYou\u0026rsquo;ll need the go compiler and tools installed, along with the glide dependency management tool. You\u0026rsquo;ll also need docker for building images.\nThe server side is compiled as one binary (\u0026ldquo;fission-bundle\u0026rdquo;) which contains controller, poolmgr and router; it invokes the right one based on command-line arguments.\nTo build fission-bundle: clone this repo to $GOPATH/src/github.com/fission/fission, then from the top level directory (if you want to build the image with the docker inside minikube, you\u0026rsquo;ll need to set the proper environment variables with eval $(minikube docker-env)):\n # Get dependencies $ glide install # Build fission server and an image $ pushd fission-bundle $ ./build.sh  You now need to build the docker image for fission. You can use push.sh and push it to a docker hub account. But it\u0026rsquo;s easiest to use minikube and its built-in docker daemon:\n $ eval $(minikube docker-env) $ docker build -t minikube/fission-bundle .  Next, install fission with this image on your kubernetes cluster using the helm chart:\n $ helm install --set \u0026quot;image=minikube/fission-bundle,pullPolicy=IfNotPresent,analytics=false\u0026quot; charts/fission-all  And if you\u0026rsquo;re changing the CLI too, you can build it with:\n # Build Fission CLI $ cd fission \u0026amp;\u0026amp; go install  "
},
{
	"uri": "https://docs.fission.io/0.6.0/workflows/",
	"title": "Fission Workflows",
	"tags": [],
	"description": "",
	"content": " Prerequisites Fission Workflows requires the following components to be installed on your local machine:\n kubectl helm  Fission Workflows is deployed on top of a Kubernetes cluster. If you don\u0026rsquo;t have a Kubernetes cluster, here\u0026rsquo;s a quick guide to set one up. It also requires a Fission deployment to be present on your Kubernetes cluster. If you do not have a Fission deployment, follow Fission\u0026rsquo;s installation guide.\n(Note that Fission Workflows 0.2.0 requires Fission 0.4.1 or higher, with the NATS component installed!)\nInstalling Fission Workflows Fission Workflows is an add-on to Fission. You can install both Fission and Fission Workflows using helm charts.\nAssuming you have your Kubernetes cluster set up with a functioning deployment of Fission 0.4.1 or higher, run the following commands:\n# If you haven't already, add the Fission charts repo $ helm repo add fission-charts https://fission.github.io/fission-charts/ $ helm repo update # Install Fission Workflows $ helm install --wait -n fission-workflows fission-charts/fission-workflows --version 0.2.0  Creating your first workflow After installing Fission and Workflows, you\u0026rsquo;re all set to run a simple test workflow. With the following code snippet you will be able to deploy and run a small workflow example:\n# Fetch the required files, alternatively you could clone the fission-workflow repo $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.2.0/examples/whales/fortune.sh \u0026gt; fortune.sh $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.2.0/examples/whales/whalesay.sh \u0026gt; whalesay.sh $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.2.0/examples/whales/fortunewhale.wf.yaml \u0026gt; fortunewhale.wf.yaml # # Add binary environment and create two test functions on your Fission setup: # $ fission env create --name binary --image fission/binary-env $ fission function create --name whalesay --env binary --deploy ./whalesay.sh $ fission function create --name fortune --env binary --deploy ./fortune.sh # # Create a workflow that uses those two functions. A workflow is just # a function that uses the \u0026quot;workflow\u0026quot; environment. # $ fission function create --name fortunewhale --env workflow --src ./fortunewhale.wf.yaml # # Map an HTTP GET to your new workflow function: # $ fission route create --method GET --url /fortunewhale --function fortunewhale # # Invoke the workflow with an HTTP request: # $ curl ${FISSION_ROUTER}/fortunewhale  This last command, the invocation of the workflow, should return a whale saying something wise\n ______________________________________ / Anthony's Law of Force: \\ | | \\ Don't force it; get a larger hammer. / -------------------------------------- \\ \\ \\ ## . ## ## ## == ## ## ## ## ## === /\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\\___/ === { / ===- \\______ O __/ \\ \\ __/ \\____\\_______/  So what happened here? Let\u0026rsquo;s see what the workflow consists of (for example by running cat fortunewhale.wf.yaml):\n# This whale shows off a basic workflow that combines both Fission Functions (fortune, whalesay) and internal functions (noop) apiVersion: 1 output: WhaleWithFortune tasks: InternalFuncShowoff: run: noop GenerateFortune: run: fortune requires: - InternalFuncShowoff WhaleWithFortune: run: whalesay inputs: \u0026quot;{$.Tasks.GenerateFortune.Output}\u0026quot; requires: - GenerateFortune  What you see is the YAML-based workflow definition of the fortunewhale workflow. A workflow consists of multiple tasks, which are steps that it needs to complete. Each task has a unique identifier, such as GenerateFortune, a reference to a Fission function in the run field. Optionally, it can contain inputs which allows you to specify inputs to the task, as well as contain requires which allows you to specify which tasks need to complete before this task can start. Finally, at the top you will find the output field, which specifies the task whose output is used as the workflow\u0026rsquo;s output.\nIn this case, the fortunewhale workflow consists of a sequence of 3 tasks:\nInternalFuncShowoff -\u0026gt; GenerateFortune -\u0026gt; WhaleWithFortune  First, it starts with InternalFuncShowoff by running noop, which is an internal function in the workflow engine. Internal functions are run inside of the workflow engine, which makes them run much faster at the cost of expressiveness and scalability. So typically, light-weight functions, such as logic or control flow operations, are good candidates to be used as internal functions. Besides, a minimal set of predefined internal functions, you can define internal function - there is nothing special about them.\nAfter InternalFuncShowff completes, the GenerateFortune task can start as its requires has been fulfilled. It runs the fortune Fission function, which outputs a random piece of wisdom.\nAfter GenerateFortune completes, the WhaleWithFortune task can start. This task uses a javascript expression in its inputs to reference the output of the GenerateFortune task. In the inputs of a task you can reference anything in the workflow, such as outputs, inputs, and task definitions, or just provide a constant value. The workflow engine invokes the whalesay fission function with as input the piece of wisdom, which outputs the ASCI whale that wraps the phrase.\nFinally, with all tasks completed, the workflow engine uses the top-level output field to fetch the output of the WhaleWithFortune and return it to the user. As the workflow engine adheres to the Fission function specification, a Fission workflow is just another Fission Function. This means that you could use this workflow as a function in the run in other workflows.\nWhat\u0026rsquo;s next? To learn more about the Fission Workflows system and its advanced concepts, see the documentation on Github.\nOr, check out the examples for more example workflows.\nIf something went wrong, we\u0026rsquo;d love to help \u0026ndash; please drop by the slack channel and ask for help.\n"
},
{
	"uri": "https://docs.fission.io/0.6.0/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.fission.io/0.6.0/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.fission.io/0.6.0/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.fission.io/0.6.0/tutorial/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": ""
}]