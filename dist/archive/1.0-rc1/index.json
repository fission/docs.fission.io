[
{
	"uri": "https://docs.fission.io/1.0-rc1/",
	"title": "Fission",
	"tags": [],
	"description": "",
	"content": " Fission: Serverless Functions for Kubernetes fission.io @fissionio\nFission is a fast serverless framework for Kubernetes with a focus on developer productivity and high performance.\nFission operates on just the code: Docker and Kubernetes are abstracted away under normal operation, though you can use both to extend Fission if you want to.\nFission is extensible to any language; the core is written in Go, and language-specific parts are isolated in something called environments (more below). Fission currently supports NodeJS, Python, Ruby, Go, PHP, Bash, and any Linux executable, with more languages coming soon.\nPerformance: 100msec cold start Fission maintains a pool of \u0026ldquo;warm\u0026rdquo; containers that each contain a small dynamic loader. When a function is first called, i.e. \u0026ldquo;cold-started\u0026rdquo;, a running container is chosen and the function is loaded. This pool is what makes Fission fast: cold-start latencies are typically about 100msec.\nKubernetes is the right place for Serverless We\u0026rsquo;re built on Kubernetes because we think any non-trivial app will use a combination of serverless functions and more conventional microservices, and Kubernetes is a great framework to bring these together seamlessly.\nBuilding on Kubernetes also means that anything you do for operations on your Kubernetes cluster \u0026mdash; such as monitoring or log aggregation \u0026mdash; also helps with ops on your Fission deployment.\nFission Concepts A function is a piece of code that follows the fission function interface.\nAn environment contains the language- and runtime-specific parts of running a function.\nThe following environments are currently available:\n   Environment Image     Binary (for executables or scripts) fission/binary-env   Go fission/go-env   .NET fission/dotnet-env   .NET 2.0 fission/dotnet20-env   NodeJS (Alpine) fission/node-env   NodeJS (Debian) fission/node-env-debian   Perl fission/perl-env   PHP 7 fission/php-env   Python 3 fission/python-env   Ruby fission/ruby-env    You can also extend environments or create entirely new ones if you want. (An environment is essentially just a container with a webserver and dynamic loader.)\nA trigger is something that maps an event to a function; Fission supports HTTP routes as triggers today, with upcoming support for other types of event triggers, such as timers and Kubernetes events.\nUsage # Add the stock NodeJS env to your Fission deployment $ fission env create --name nodejs --image fission/node-env # A javascript one-liner that prints \u0026quot;hello world\u0026quot; $ curl https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js \u0026gt; hello.js # Upload your function code to fission $ fission function create --name hello --env nodejs --code hello.js # Map GET /hello to your new function $ fission route create --method GET --url /hello --function hello # Run the function. This takes about 100msec the first time. $ fission function test --name hello Hello, world!  See the examples directory for more.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/accessing-url-params/",
	"title": "Accessing URL parameters",
	"tags": [],
	"description": "",
	"content": "To develop an application consists with REST APIs, we may want to access URL parameters in functions.\nFor example, a REST API with URL parameters like following\nhttp://192.168.0.1/guestbook/messages/{id}  You can put parameter placeholders in value of --url flag. Since fission uses gorilla/mux as underlying URL router, you can also write regular expression to filter out illegal API requests.\n$ fission httptrigger create --method GET \\ --url \u0026quot;/guestbook/messages/{id}\u0026quot; --function restapi-get $ fission httptrigger create --method GET \\ --url \u0026quot;/guestbook/messages/{id:[0-9]+}\u0026quot; --function restapi-get  Next step is to access the value of URL parameters.\nDue to some internal mechanism, the value of URL parameters will be attached to the HTTP request header like following.\nAccept-Encoding: gzip Host: 172.17.0.25:8888 Connection: close Accept: */* User-Agent: curl/7.54.0 Content-Length: 15 Content-Type: application/json X-Forwarded-For: 172.17.0.1 X-Fission-Function-Uid: 82c95606-9afa-11e8-bbd1-08002720b796 X-Fission-Function-Resourceversion: 480652 X-Fission-Function-Name: reqpayload X-Fission-Function-Namespace: default X-Fission-Params-Id: 12345  The header with key prefix X-Fission-Params- are the actual fields contain value of URL parameters we want to access to.\nOne thing worth to notice is in some language like Go the header key will be displayed as MIME canonical format. For example,\nurl: /guestbook/messages/{id} header key: X-Fission-Params-Id url: /guestbook/messages/{FooBar} header key: X-Fission-Params-Foobar  You have to check the letter case of header key and do conversion if necessary in order to get the right parameter value.\n(In Go, you can call request.Header.Get() to get header value without worrying key cases.)\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/languages/nodejs/",
	"title": "Fission functions with Nodejs",
	"tags": [],
	"description": "",
	"content": " Fission supports functions written in Nodejs. Current fission nodejs runtime environment supports node version greater than 7.6.0. In this usage guide we\u0026rsquo;ll cover how to use this environment, write functions, and work with dependencies.\nBefore you start We assume you have Fission and Kubernetes setup. If not, head over to the install guide. Verify your Fission setup with:\n$ fission --version  Add the Nodejs runtime environment to your cluster Fission language support is enabled by creating an Environment. An environment is the language-specific part of Fission. It has a container image in which your function will run.\n$ fission environment create --name nodejs --image fission/node-env  Write a simple function in Nodejs Create a file helloWorld.js with the following content\nmodule.exports = async function(context) { return { status: 200, body: \u0026quot;hello, world!\\n\u0026quot; }; }  Create a function with the following command. Note that the value for --env flag is nodejs which was created with fission env create command above.\n$ fission function create --name hello-world --code helloWorld.js --env nodejs  Test the function with the below command and you should see \u0026ldquo;hello, world!\u0026rdquo; in the output\n$ fission fn test --name hello-world  HTTP requests and HTTP responses Accessing HTTP Requests This section gives a few examples of invoking nodejs functions with HTTP requests and how HTTP request components can be extracted inside the function. While these examples give you a rough idea of the usage, there are more real world examples here\nHeaders Here\u0026rsquo;s an example of extracting HTTP headers from the HTTP request.\nCreate a file hello.js with the following content. Here the function tries to access the value associated with header with name \u0026lsquo;x-internal-token\u0026rsquo; and it could potentially do some authentication and authorization on the token before returning the response.\nmodule.exports = async function(context) { console.log(context.request.headers); var token = context.request.headers['x-internal-token']; console.log(\u0026quot;Token presented : \u0026quot;, token); // do some authn and authz based on token received return { status: 200, body: \u0026quot;hello world!\u0026quot; } }  Create a function with the following command.\n$ fission function create --name hello-world --code hello.js --env nodejs  Create an HTTP trigger to invoke the function\nfission httptrigger create --url /hello-world --function hello-world  Test the function with the below command and you should see \u0026ldquo;hello, world!\u0026rdquo; in the output\n$ curl HTTP://$FISSION_ROUTER/hello-world -H \u0026quot;X-Internal-Token: abcdefghtsdfjsldjf123\u0026quot;  Query string Here\u0026rsquo;s an example of extracting the query string from the HTTP request.\nCreate a file helloUser.js with the following content. Here the function tries to read the value of query parameter user and returns \u0026ldquo;hello \u0026rdquo;.\nvar url = require('url'); module.exports = async function(context) { console.log(context.request.url) var url_parts = url.parse(context.request.url, true); var query = url_parts.query; console.log(\u0026quot;query user : \u0026quot;, query.user); return { status: 200, body: \u0026quot;hello \u0026quot; + query.user + \u0026quot;!\u0026quot; } }  Create a function with the following command.\n$ fission function create --name hello-user --code helloUser.js --env nodejs  Create an HTTP trigger to invoke the function\n$ fission httptrigger create --url /hello-user --function hello-user  Test the function with the below command and you should see \u0026ldquo;hello, foo!\u0026rdquo; in the output\n$ curl HTTP://$FISSION_ROUTER/header-example?user=foo  Body First lets see an example of a function which extracts a request body in JSON format.\nCreate a file jobStatus.js with the following content. Here the function tries to extract the \u0026lsquo;job_id\u0026rsquo; and the \u0026lsquo;job_status\u0026rsquo; from the HTTP request body and could potentially persist the status somewhere.\nmodule.exports = async function(context) { const job = context.request.body.job_id; const jobStatus = context.request.body.job_status; // do some db write if required to save the status return { status: 200, body: \u0026quot;Successfully saved job status for job ID: \u0026quot; + job }; }  Create a function with the following command.\n$ fission function create --name job-status --code jobStatus.js --env nodejs  Create an HTTP trigger to invoke the function\n$ fission httptrigger create --url /job-status --function job-status --method POST  Invoke the function with a POST HTTP request with the appropriate JSON body and you will see the response \u0026ldquo;Successfully saved job status for job ID: 1234\u0026rdquo;\n$ curl -XPOST HTTP://$FISSION_ROUTER/job-status -d '{\u0026quot;job_id\u0026quot; : \u0026quot;1234\u0026quot;, \u0026quot;job_status\u0026quot;: \u0026quot;Passed\u0026quot;}'  Next lets see an example of writing a function which extracts a request body in the Plain Text format\nCreate a file wordCount.js with the following content. Here the function tries to extract a request body and returns the word count of the input text.\nmodule.exports = async function(context) { var splitStringArray = context.request.body.split(\u0026quot; \u0026quot;); return { status: 200, body: \u0026quot;word count \u0026quot; + splitStringArray.length }; }  Create a function with the following command.\n$ fission function create --name word-count --code wordCount.js --env nodejs  Create an HTTP trigger to invoke the function\n$ fission httptrigger create --url /word-count --function word-count --method POST  Invoke the function with a POST HTTP request with a text body and you will see the count of number of words in the HTTP response.\n$ curl -XPOST -H \u0026quot;Content-Type: text/plain\u0026quot; HTTP://$FISSION_ROUTER/word-count -d '{\u0026quot;It's a beautiful day!\u0026quot;}'  Controlling HTTP Responses This section gives a few examples of invoking nodejs functions with HTTP requests and how the function can return various values as part of HTTP response headers and body.\nSetting Response Headers Create a file functionMetadata.js with the following content. Here the function returns the fission function metadata added by Fission Router as part of the HTTP response header to the user.\nmodule.exports = async function(context) { console.log(context.request.headers); return { status: 200, headers: { 'x-fission-function-name': context.request.headers['x-fission-function-name'], 'x-fission-function-namespace': context.request.headers['x-fission-function-namespace'], 'x-fission-function-resourceversion': context.request.headers['x-fission-function-resourceversion'], 'x-fission-function-uid': context.request.headers['x-fission-function-uid'], }, body: \u0026quot;hello world!\u0026quot; } }  Create a function with the following command.\n$ fission function create --name function-metadata --code functionMetadata.js --env nodejs  Create an HTTP trigger to invoke the function\n$ fission httptrigger create --url /function-metadata --function function-metadata --method GET  Invoke the function with a \u0026lsquo;-v\u0026rsquo; flag on curl command to display all headers\n$ curl HTTP://$FISSION_ROUTER/function-metadata -v  We can see the headers in the output as below\n* Trying 0.0.0.0 . . . \u0026lt; HTTP/1.1 200 OK \u0026lt; Content-Length: 12 \u0026lt; Content-Type: text/html; charset=utf-8 \u0026lt; Date: Tue, 23 Oct 2018 19:01:55 GMT \u0026lt; Etag: W/\u0026quot;c-QwzjTQIHJO11oZbfwq1nx3dy0Wk\u0026quot; \u0026lt; X-Fission-Function-Name: header-example \u0026lt; X-Fission-Function-Namespace: default \u0026lt; X-Fission-Function-Resourceversion: 19413500 \u0026lt; X-Fission-Function-Uid: 0014884b-d6e7-11e8-afb7-42010a800194 \u0026lt; X-Powered-By: Express \u0026lt; * Connection #0 to host 0.0.0.0 left intact hello world!  Setting Status Codes Create a file validateInput.js with the following content. Here the function tries to validate an input parameter \u0026ldquo;job_id\u0026rdquo; and sends a HTTP response code 400 when validation fails.\nmodule.exports = async function(context) { const job = context.request.body.job_id; const jobStatus = context.request.body.job_status; console.log(\u0026quot;Received CI job id: \u0026quot; + job + \u0026quot; job status: \u0026quot; + jobStatus ); if (!job) { return { status: 400, body: \u0026quot;job_id cannot be empty\u0026quot; }; } return { status: 200, body: \u0026quot;Successfully saved CI job status for job ID: \u0026quot; + job }; }  Create a function with the following command.\n$ fission function create --name error-handling --code validateInput.js --env nodejs  Create an HTTP trigger to invoke the function\n$ fission httptrigger create --url /error-handling --function error-handling --method POST  Invoke the function with this curl command where job_id is empty and you should see \u0026ldquo;job_id cannot be empty\u0026rdquo;\n$ curl -XPOST HTTP://$FISSION_ROUTER/error-handling -d '{\u0026quot;job_status\u0026quot;: \u0026quot;Passed\u0026quot;}'  Working with dependencies There may be instances where functions need to require node modules that are not packed into the nodejs runtime environment. In such instances, nodejs builder image could be used to npm install those modules. This section describes ways in which this can be achieved.\nUsing fission nodejs builder image Example of using the nodejs builder image fission docker hub has a nodejs builder image fission/node-builder. Here\u0026rsquo;s an example of using this image.\nFirst, create an environment with runtime image and builder image as follows\n$ fission environment create --name nodejs --image fission/node-env --builder fission/node-builder  Next, create a file momentExample.js with the following content. This file requires \u0026lsquo;moment\u0026rsquo; node_module that is not packed into the fission runtime image. Also create a package.json with \u0026lsquo;moment\u0026rsquo; listed in dependencies section.\nconst momentpackage = require('moment') module.exports = async function(context) { return { status: 200, body: momentpackage().format() }; }  Sample package.json\n{ \u0026quot;name\u0026quot;: \u0026quot;fission-nodejs-runtime\u0026quot;, \u0026quot;engines\u0026quot;: { \u0026quot;node\u0026quot;: \u0026quot;\u0026gt;=7.6.0\u0026quot; }, \u0026quot;dependencies\u0026quot;: { \u0026quot;moment\u0026quot;: \u0026quot;*\u0026quot; } }  Next, create a zip archive of these 2 files with zip momentExample.js package.json , let\u0026rsquo;s call it node-source-example.zip\nNow create a fission source package with the zip file just created. This command outputs the name of the package created.\n$ fission package create --src node-source-example.zip --env nodejs  Next, create a fission function with the package created above, let\u0026rsquo;s assume the package name is \u0026lsquo;node-source-example-abcd\u0026rsquo;\n$ fission function create --name node-builder-example --pkg node-source-example-abcd --env nodejs --entrypoint \u0026quot;momentExample\u0026quot;  If everything was successful so far, then, build status of the source package will be set to \u0026lsquo;succeeded\u0026rsquo;. This can be checked with the following command.\n$ fission package info --name node-source-example-abcd  Next, test your function with the following and the output should have the current time.\n$ fission fn test --name node-builder-example  Details of the fission nodejs builder image The builder has a build.sh script that performs an npm install of the node modules listed in user provided package.json. The builder image runs this script and packages the result into an archive.\nWhen the function is invoked, one of the pods running the runtime image is specialized. What this means is that the archive created by the builder is fetched and extracted in the file system. Next, the user function is loaded according to the entry point specified with fission fn create command\nCreating a custom nodejs builder image If you\u0026rsquo;d like to do more than just npm install in the build step, you could customize the build.sh. Here\u0026rsquo;s the link to the source code of fission nodejs builder\nAs you can see, the build.sh performs a npm install inside a directory defined by the environment variable SRC_PKG and copies the built archive into a directory defined by environment variable DEPLOY_PKG You could create a customized version of this build.sh with whatever additional commands needed to be run during the build step.\nFinally the image can be built with docker build -t \u0026lt;USER\u0026gt;/nodejs-custom-builder . and pushed to docker hub with docker push \u0026lt;USER\u0026gt;/nodejs-custom-builder\nNow you are ready to create a nodejs env with your custom builder image supplied to --builder flag\nModifying the nodejs runtime image If you wish to modify the nodejs runtime image to add more dependencies without using/creating a builder image, you can do so too.\nHere\u0026rsquo;s the link to the source code of fission nodejs runtime\nAs you can see, there is a package.json in the directory with a list of node modules listed under dependencies section. You can add the node modules required to this list and then build the docker image with docker build -t \u0026lt;USER\u0026gt;/nodejs-custom-runtime . and push the image docker push \u0026lt;USER\u0026gt;/nodejs-custom-runtime\nYou are now ready to create a nodejs env with your image supplied to --image flag\nResource usage Currently the nodejs environment containers are run with default memory limit of 512 MiB and a memory request of 256 MiB. Also, a default CPU limit of 1 and a CPU request of 0.5 cores.\nIf you wish to create functions with higher resource requirements, you could supply --mincpu, --maxcpu, --minmemory and --maxmemory flags during fission fn create. Also supply --executortype newdeploy to the CLI.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/languages/go/",
	"title": "Using Go with Fission",
	"tags": [],
	"description": "",
	"content": " With Go plugin mechanism, fission supports Go as one of function languages.\nIn this usage guide we\u0026rsquo;ll cover how to use this environment, write functions, and work with dependencies.\nBefore you start We\u0026rsquo;ll assume you have Fission and Kubernetes setup. If not, head over to the install guide. Verify your Fission setup with:\n$ fission --version  Add the Go environment to your cluster Unlike Python, Go is a compiled language that means we need to compile source code before running it.\nFortunately, builder manager within fission does all this hard work automatically when a Go function/package is created. The Go builder will convert a source package into a deployable package.\nTo enable Go builder, we need to assign a function builder with flag --builder.\n$ fission environment create --name go --image fission/go-env --builder fission/go-builder  Write a simple function in Go Here is a hello world example (hw.go) in Go:\n// Due to go plugin mechanism, // the package of function handler must be main package package main import ( \u0026quot;net/http\u0026quot; ) // Handler is the entry point for this fission function func Handler(w http.ResponseWriter, r *http.Request) { msg := \u0026quot;Hello, world!\\n\u0026quot; w.Write([]byte(msg)) }  The entrypoint of function let go server to know how to load-in plugin file correctly. Here, our first hello world function\u0026rsquo;s entrypoint is simply the name of function: Handler.\n# Create golang env with builder image to build go plugin $ fission fn create --name helloworld --env go --src hw.go --entrypoint Handler  Before accessing function, need to ensure deploy package of function is in succeeded state.\n$ fission pkg info --name \u0026lt;pkg-name\u0026gt;  Now, let\u0026rsquo;s test our first Go function with test command\n$ fission fn test --name \u0026lt;function-name\u0026gt;  See here for how to setup different trigger for Go function.\n HTTP requests and HTTP responses From the sample above we know that go server passes HTTP Request and ResponseWriter to user function for further processing.\nfunc Handler(w http.ResponseWriter, r *http.Request) { ... }  Following we will go through steps for how to accessing/controlling the requests/responses.\nAccessing HTTP Requests Headers package main import ( \u0026quot;fmt\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;net/textproto\u0026quot; ) func Handler(w http.ResponseWriter, r *http.Request) { // recommend v1 := r.Header.Get(\u0026quot;HEADER_KEY_1\u0026quot;) // need to convert string cases manually key := textproto.CanonicalMIMEHeaderKey(\u0026quot;HEADER_KEY_2\u0026quot;) // v2 type is []string v2, _ := r.Header[key] w.Write([]byte(fmt.Sprintf(\u0026quot;v1: %s, v2: %v\u0026quot;, v1, v2))) }  Let\u0026rsquo;s create a HTTP trigger for the function we created above.\n$ fission httptrigger create --method GET --url \u0026quot;/\u0026lt;url\u0026gt;\u0026quot; --function \u0026lt;fn-namne\u0026gt;  $ curl -X GET http://$FISSION_ROUTER/\u0026lt;url\u0026gt; -H 'HEADER_KEY_1: foo' -H 'HEADER_KEY_2: bar' v1: foo, v2: [bar]  One thing worth to notice is all header key will be converted to the canonical format of the MIME header key. You can access to header value by calling request.Header.Get(). However, if you prefer to access the value by map index you must convert key format with textproto.CanonicalMIMEHeaderKey().\nQuery string package main import ( \u0026quot;net/http\u0026quot; ) func Handler(w http.ResponseWriter, r *http.Request) { v := r.URL.Query().Get(\u0026quot;key-name\u0026quot;) w.Write([]byte(v)) }  $ curl -X GET http://$FISSION_ROUTER/\u0026lt;url\u0026gt;?key-name=123 123  Request Body PLAIN TEXT\npackage main import ( \u0026quot;io/ioutil\u0026quot; \u0026quot;net/http\u0026quot; ) func Handler(w http.ResponseWriter, r *http.Request) { reqBody, err := ioutil.ReadAll(r.Body) if err != nil { w.WriteHeader(http.StatusBadRequest) w.Write([]byte(err.Error())) } body := string(reqBody) w.Write([]byte(body)) }  $ curl -X POST http://$FISSION_ROUTER/\u0026lt;url\u0026gt; -d foobar foobar  JSON\npackage main import ( \u0026quot;encoding/json\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;io/ioutil\u0026quot; ) type msg struct { Content string `json:\u0026quot;content\u0026quot;` } func Handler(w http.ResponseWriter, r *http.Request) { reqBody, err := ioutil.ReadAll(r.Body) if err != nil { w.WriteHeader(http.StatusBadRequest) w.Write([]byte(err.Error())) } m := msg{} err = json.Unmarshal(reqBody, \u0026amp;m) if err != nil { w.WriteHeader(http.StatusBadRequest) w.Write([]byte(err.Error())) } respBody, err := json.Marshal(m) if err != nil { w.WriteHeader(http.StatusInternalServerError) w.Write([]byte(err.Error())) } w.Write([]byte(respBody)) }  curl -X POST http://$FISSION_ROUTER/\u0026lt;url\u0026gt; -d '{\u0026quot;content\u0026quot;: \u0026quot;foobar\u0026quot;}' {\u0026quot;content\u0026quot;:\u0026quot;foobar\u0026quot;}  Controlling HTTP Responses Setting Response Headers package main import ( \u0026quot;net/http\u0026quot; ) func setCORS(w http.ResponseWriter) http.ResponseWriter { w.Header().Set(\u0026quot;Access-Control-Allow-Origin\u0026quot;, \u0026quot;*\u0026quot;) w.Header().Set(\u0026quot;Access-Control-Allow-Headers\u0026quot;, \u0026quot;*\u0026quot;) w.Header().Set(\u0026quot;Access-Control-Allow-Credentials\u0026quot;, \u0026quot;true\u0026quot;) w.Header().Set(\u0026quot;Access-Control-Allow-Methods\u0026quot;, \u0026quot;*\u0026quot;) w.Header().Set(\u0026quot;Access-Control-Expose-Headers\u0026quot;, \u0026quot;*\u0026quot;) return w } func Handler(w http.ResponseWriter, r *http.Request) { w = setCORS(w) w.WriteHeader(http.StatusOK) }  $ curl -i -X GET \u0026quot;http://$FISSION_ROUTER/\u0026lt;url\u0026gt;\u0026quot; HTTP/1.1 200 OK Access-Control-Allow-Credentials: true Access-Control-Allow-Headers: * Access-Control-Allow-Methods: * Access-Control-Allow-Origin: * Access-Control-Expose-Headers: * Content-Length: 0 Content-Type: text/plain; charset=utf-8 Date: Sat, 27 Oct 2018 15:00:14 GMT  Setting Status Codes Always write response status code before writing response body! Otherwise, the client may receive unexpected status code.\n You can set response status code by calling function writer.WriteHeader(). However, one thing wroth to notice is if a function writes response body before status code, the client will receive HTTP 200 OK no matter what actual status code is.\npackage main import ( \u0026quot;net/http\u0026quot; ) func Handler(w http.ResponseWriter, r *http.Request) { // DONT // w.Write([]byte(\u0026quot;foobar\u0026quot;)) // w.WriteHeader(http.StatusBadRequest) // DO http.Error(w, \u0026quot;dummy error\u0026quot;, http.StatusBadRequest) // or DO // w.WriteHeader(http.StatusBadRequest) // w.Write([]byte(\u0026quot;foobar\u0026quot;)) }  Working with dependencies Add dependencies Unlike pip for Python has been widely adopted by community, there are various dependency management tools for Go like gb, dep and glide. Hence fission Go builder image doesn\u0026rsquo;t contain a default tool for downloading dependencies during build processes.\nIn order to support 3rd party dependencies, users need to put all necessary packages to vendor directory and archive it into source archive.\nFollowing I will use glide to demonstrate how to add dependencies to source archive.\n$ mkdir example $ pushd example $ glide init --non-interactive $ glide get \u0026quot;github.com/golang/example/stringutil\u0026quot; $ curl https://raw.githubusercontent.com/fission/fission/master/examples/go/vendor-example/main.go \u0026gt; main.go $ zip -r example.zip . $ fission fn create --name foobar --src example.zip --entrypoint Handler # wait for package build process $ fission fn test --name foobar  Custom builds If no custom build script included in source archive, by default builder manager will execute the build.sh in go builder image. In this part, we will go through how to run custom build script during the build process.\nBefore we write our own script, we need to dive into the original build script to see what\u0026rsquo;s useful inside.\n#!/bin/sh set -eux srcDir=${GOPATH}/src/$(basename ${SRC_PKG}) trap \u0026quot;rm -rf ${srcDir}\u0026quot; EXIT if [ -d ${SRC_PKG} ] then echo \u0026quot;Building in directory ${srcDir}\u0026quot; ln -sf ${SRC_PKG} ${srcDir} elif [ -f ${SRC_PKG} ] then echo \u0026quot;Building file ${SRC_PKG} in ${srcDir}\u0026quot; mkdir -p ${srcDir} cp ${SRC_PKG} ${srcDir}/function.go fi cd ${srcDir} go build -buildmode=plugin -i -o ${DEPLOY_PKG} .  There are environment variables as shown above:\n $SRC_PKG: The path to the source code directory/file. $DEPLOY_PKG: The path to the deploy directory/executable binary.  The steps of build script are:\n Check the $SRC_PKG is a file or directory Copy/Link source code to $GOPATH Change location to $SRC_PKG, build source code into plugin file then output to $DEPLOY_PKG  For example, we want to add git commit SHA or build timestamp to go binaries like following.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;net/http\u0026quot; ) var ( Timestamp string ) // Handler is the entry point for this fission function func Handler(w http.ResponseWriter, r *http.Request) { msg := fmt.Sprintf(\u0026quot;Build timestamp: %v\u0026quot;, Timestamp) w.Write([]byte(msg)) }  To set build timestamp we can set it through ldflags during build process. But it\u0026rsquo;s not supported with original build script.\nSince we understand how a build script (customBuild.sh) works, let\u0026rsquo;s try to modify it a little bit.\n#!/bin/sh set -eux srcDir=${GOPATH}/src/$(basename ${SRC_PKG}) trap \u0026quot;rm -rf ${srcDir}\u0026quot; EXIT if [ -d ${SRC_PKG} ] then echo \u0026quot;Building in directory ${srcDir}\u0026quot; ln -sf ${SRC_PKG} ${srcDir} elif [ -f ${SRC_PKG} ] then echo \u0026quot;Building file ${SRC_PKG} in ${srcDir}\u0026quot; mkdir -p ${srcDir} cp ${SRC_PKG} ${srcDir}/function.go fi pkgpath=$(basename ${SRC_PKG}) timestamp=$(date +%s) cd ${srcDir} go build -ldflags \u0026quot;-X ${pkgpath}.Timestamp=$timestamp\u0026quot; -buildmode=plugin -i -o ${DEPLOY_PKG} .  At this moment, the directory structure would be like\n. ├── customBuild.sh └── main.go  Archive source package.\n$ chmod +x customBuild.sh $ zip -r example.zip .  After editing custom build script, next step is to assign a build command for builder to know what command to run with.\n$ fission fn create --name foobar --env go --src example.zip --entrypoint Handler --buildcmd \u0026quot;./customBuild.sh\u0026quot; $ fission fn test --name foobar Build timestamp: 1540566887  Modifying/Rebuild the environment images For how to rebuild environment image, please visit here\nResource usage By default, a function can use all resource on node it run on, however, other functions will be affected once a function takes too much resources. To prevent this, Fission allows users to specify a resource limitation for function.\nFollowing are flags to manage function resource usage limitation.\n--mincpu value Minimum CPU to be assigned to pod (In millicore, minimum 1) --maxcpu value Maximum CPU to be assigned to pod (In millicore, minimum 1) --minmemory value Minimum memory to be assigned to pod (In megabyte) --maxmemory value Maximum memory to be assigned to pod (In megabyte)  And you can specify them when creating/updating a function.\n$ fission fn create --name g1 --env go --src example.zip --entrypoint Handler --mincpu 20 --maxcpu 100 --minmemory 128 --maxmemory 256  So what\u0026rsquo;s the reasonable resource setting for a function? It really depends on what type of your function is.\nHere\u0026rsquo;s a tip, use kubectl top to get actual resource consumption of pod when doing benchmarking. Then you will know what\u0026rsquo;s the best setting for a Go function.\n$ kubectl -n fission-function top pod -l functionName=g1 NAME CPU(cores) MEMORY(bytes) go-1ef65ed0-d5eb-11e8-91e8-080027114863-9x7y4xmh-569bfdd9bhmlrf 112m 6Mi  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/languages/java/",
	"title": "Using Java with Fission JVM environment",
	"tags": [],
	"description": "",
	"content": " Fission supports functions written in Java and runs then on JVM. Current JVM environment is based on openjdk8 and uses Spring Boot as framework.\nBefore you start We\u0026rsquo;ll assume you have Fission and Kubernetes setup. If not, head over to the install guide. Verify your Fission setup with:\n$ fission --version  Add JVM environment to your cluster Fission language support is enabled by creating an Environment. An environment is the language-specific part of Fission. It has a container image in which your function will run.\n$ fission environment create --name java --image fission/jvm-env --builder fission/jvm-builder  Write a simple function in Java A function needs to implement the io.fission.Function class and override the call method. The call method receives the RequestEntity and Context as inputs and needs to return ResponseEntity object. Both RequestEntity and ResponseEntity are from org.springframework.http package and provide a fairly high level and rich API to interact with request and response objects. The function code responds with \u0026ldquo;Hello World\u0026rdquo; in response body looks as shown below:\npackage io.fission; import org.springframework.http.RequestEntity; import org.springframework.http.ResponseEntity; import io.fission.Function; import io.fission.Context; public class HelloWorld implements Function { @Override public ResponseEntity\u0026lt;?\u0026gt; call(RequestEntity req, Context context) { return ResponseEntity.ok(\u0026quot;Hello World!\u0026quot;); } }  HTTP requests and HTTP responses Java function provides easy access to the Request and Response using Spring framework\u0026rsquo;s RequestEntity and ResponseEntity objects.\nAccessing HTTP Requests Headers You can access headers object from the request object and then use various methods on header object to retrieve a specific header or get a collection of all headers. Please note that the header keys will be converted to canonical MIME format header key.\nHttpHeaders headers = req.getHeaders(); List\u0026lt;String\u0026gt; values = headers.get(\u0026quot;keyname\u0026quot;);  Query string You can use the URI object in request object and parse the query parameters as shown below.\nMap\u0026lt;String, String\u0026gt; query_pairs = new LinkedHashMap\u0026lt;String, String\u0026gt;(); URI url = req.getUrl(); String query = url.getQuery(); String[] pairs = query.split(\u0026quot;\u0026amp;\u0026quot;); for (String pair : pairs) { int idx = pair.indexOf(\u0026quot;=\u0026quot;); query_pairs.put(URLDecoder.decode(pair.substring(0, idx), \u0026quot;UTF-8\u0026quot;), URLDecoder.decode(pair.substring(idx + 1), \u0026quot;UTF-8\u0026quot;)); }  Body The body of the request object can be accessed as a map. You can use the map to convert to a value object using Jackson library\u0026rsquo;s ObjectMappper. You will need to add the Jackson library to dependencies and import appropriate classes.\nimport com.fasterxml.jackson.databind.ObjectMapper; final ObjectMapper mapper = new ObjectMapper(); HashMap data = (HashMap) req.getBody(); // The Data object is a POJO representation of JSON from request Data iotData = mapper.convertValue(data, Data.class);  Controlling HTTP Responses Setting Response Headers \u0026amp; Status code The response object allows adding headers before sending the response back to the user. You can also set status code, body etc. on response object\nHttpHeaders headers = new HttpHeaders(); headers.add(\u0026quot;Access-Control-Allow-Origin\u0026quot;, \u0026quot;*\u0026quot;); return ResponseEntity.status(HttpStatus.OK).headers(headers).build();  Working with dependencies Dependencies JVM environment can accept any executable JAR with entrypoint method that implements the interface of io.fission.Function. Currently the dependencies in the JVM environment are managed with Maven so we will take that as an example but you can use the others tools as well such as Gradle.\nJVM environment already has the spring-boot-starter-web and fission-java-core as dependencies so you need to declare them at provided scope. You can add additional dependencies that your application needs.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.fission\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fission-java-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.2-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  Building the function The current build environment for Java has support for Maven builds. You can upload the source code and the JVM builder will build the source code into a jar. Let\u0026rsquo;s take Java example from here and build using Fission builder.\nLet\u0026rsquo;s first create a JVM environment with builder. For JVM environment you need to pass --keeparchive so that the jar file built from source is not extracted for running the function. You also need to use version 2 or higher of environment.\n$ fission env create --name java --image fission/jvm-env --builder fission/jvm-builder --keeparchive --version 2  Next create a package with the builder environment by providing the source package. This will kick off the build process.\n$ tree -L 1 . ├── README.md ├── build.sh ├── pom.xml └── src 2 directories, 3 files $ zip java-src-pkg.zip -r * $ fission package create --env java --src java-src-pkg.zip Package 'java-src-pkg-zip-dqo5' created  You can check the status of build by running the info command on package. After the build succeeds, the status will turn to succeeded and the build logs will be visible.\n$ fission package info --name java-src-pkg-zip-dqo5 Name: java-src-pkg-zip-dqo5 Environment: java Status: running Build Logs: $ fission package info --name java-src-pkg-zip-dqo5 Name: java-src-pkg-zip-dqo5 Environment: java Status: succeeded Build Logs: [INFO] Scanning for projects... [INFO] [INFO] -----------------------\u0026lt; io.fission:hello-world \u0026gt;----------------------- [INFO] Building hello-world 1.0-SNAPSHOT [INFO] --------------------------------[ jar ]--------------------------------- [INFO] \u0026lt;\u0026lt; TRUNCATED FOR SIMPLICITY \u0026gt;\u0026gt; [INFO] Building jar: /packages/java-src-pkg-zip-dqo5-aevhi1/target/hello-world-1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 6.588 s [INFO] Finished at: 2018-10-25T12:46:09Z [INFO] ------------------------------------------------------------------------  Finally let\u0026rsquo;s create a function with package created earlier and provide an entrypoint. The function can be tested with fission fn test command.\n$ fission fn create --name javatest --pkg java-src-pkg-zip-dqo5 --env java --entrypoint io.fission.HelloWorld --executortype newdeploy --minscale 1 --maxscale 1 $ fission fn test --name javatest Hello World!  Custom builds You might have noticed that we did not provide any build command to package for building from source in previous section. The build still worked because the builder used the default built in command to build the source. You can override this build command to suit your needs. The only requirement is to instruct the builder on how to copy resulting Jar file to function by using the environment variables $SRC_PKG and $DEPLOY_PKG. The $SRC_PKG is the root from where build will be run so you can form a relative oath to Jar file and copy the file to $DEPLOY_PKG Fission will at runtime inject these variables and copy the Jar file.\n$ cat build.sh #!/bin/sh set -eou pipefail mvn clean package cp ${SRC_PKG}/target/*with-dependencies.jar ${DEPLOY_PKG}  You can pass the custom build script when creating package or function using the buildcmd flag:\n$ fission package create --env java --src java-src-pkg.zip --buildcmd custom_build.sh Package 'java-src-pkg-zip-dqo5' created  Modifying the environment images The JVM environment\u0026rsquo;s source code is available here. If you only want to add libraries to the OS or add some additional files etc. to environment, it would be easier to simply extend the official Fission JVM environment image and use it.\nThe JVM builder image source code is available here and could be extended or written from scratch to use other tools such as Gradle etc. It would be easier to extend the Fission official image and then add tools.\nResource usage A minimum memory of 128MB is needed for JVM environment. You can specify CPU and memory when you create an environment as shown below. The min and max for resources correspond to resource request and resource limits of Kubernetes pods.\n$ fission env create --name java --image fission/jvm-env --builder fission/jvm-builder --keeparchive --version 2 --mincpu 100 --maxcpu 500 --minmemory 128 --maxmemory 512  For function of executor type \u0026ldquo;newdeploy\u0026rdquo; you can also override the resource values when creating a function. For functions of type \u0026ldquo;poolmgr\u0026rdquo;, the resources can only be specified at environment level.\n$ fission fn create --name javatest --pkg java-src-pkg-zip-dqo5 --env java --entrypoint io.fission.HelloWorld --executortype newdeploy --minscale 1 --maxscale 1 --mincpu 100 --maxcpu 500 --minmemory 128 --maxmemory 512  JVM Parameters You can provide options to JVM such as heap size or additional parameters for tuning the JVM to your needs. The Fission JVM environment supports the JVM options.\nYou can create the JVM environment spec (For more information on using specs check using Fission specs) and then add environment variable named JVM_OPTS. The value of environment variable is used as options to JVM when function starts. The following is an example of Fission environment YAML with JVM_OPTS added as an environment variable.\napiVersion: fission.io/v1 kind: Environment metadata: creationTimestamp: null name: jvm namespace: default spec: TerminationGracePeriod: 360 builder: {} keeparchive: true poolsize: 3 resources: {} runtime: functionendpointport: 0 image: fission/jvm-env loadendpointpath: \u0026quot;\u0026quot; loadendpointport: 0 container: env: - name: JVM_OPTS value: \u0026quot;-Xms256M -Xmx1024M\u0026quot; version: 2  You can validate and apply the YAML to create the JVM environment with JVM options.\n$ fission spec validate $ fission spec apply  Samples  The Fission Kafka sample is a complete application written in Java and uses Kafka to interact between functions. The source code and more information can be found here\n The Fission workflow sample uses Fission workflows and Java functions. The source code and more information can be found here\n  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/languages/python/",
	"title": "Using Python with Fission",
	"tags": [],
	"description": "",
	"content": " Fission supports functions written in Python. Both Python 2.x and Python 3.x are supported. In this usage guide we\u0026rsquo;ll cover how to set up and use a Python environment on Fission, write functions, and work with dependencies. We\u0026rsquo;ll also cover basic troubleshooting.\nBefore you start We\u0026rsquo;ll assume you have Fission and Kubernetes setup. If not, head over to the installation guide. Verify your Fission setup with:\n$ fission --version  Add the Python environment to your cluster Fission language support is enabled by creating an Environment. An environment is the language-specific part of Fission. It has a container image in which your function will run.\n$ fission environment create --name python --image fission/python-env  Create a simple function in Python Create a file named hello.py:\ndef main(): return \u0026quot;Hello, world!\u0026quot;  Create a Fission function (this uploads the file to Fission on the cluster):\n$ fission function create --name hello --env python --code hello.py  Invoke this function through the Fission CLI:\n$ fission function test --name hello Hello, world!  You can also invoke this function by creating an HTTP trigger and making an HTTP request to the Fission router. Ensure you have your router\u0026rsquo;s address in the FISSION_ROUTER environment variable as this guide describes. Then,\n$ fission route create --method GET --url /hello --function hello $ curl $FISSION_ROUTER/hello Hello, world!  Function input and output interface In this section we\u0026rsquo;ll describe the input and output interfaces of Python functions in Fission. Fission\u0026rsquo;s Python integration is built on the Flask framework. You can access HTTP requests and responses as you do in Flask. We\u0026rsquo;ll provide some examples below.\nAccessing HTTP Requests HTTP Headers Write a simple headers.py with something like this:\nfrom flask import request def main(): try: myHeader = request.headers['x-my-header'] except KeyError: return \u0026quot;Header 'x-my-header' not found\u0026quot; return \u0026quot;The header's value is '%s'\u0026quot; % myHeader  Create that function, assign it a route, and invoke it with an HTTP header:\n$ fission function create --name headers --env python --code headers.py $ fission route create --url /headers --function headers $ curl -H \u0026quot;X-My-Header: Hello\u0026quot; $FISSION_ROUTER/headers The header's value is 'Hello'  Query parameters HTTP Query parameters are the key-value pairs in a URL after the ?. They are also available through the request object:\nWrite a simple query.py with something like this:\nfrom flask import request def main(): queryParam = request.args.get('myKey') return \u0026quot;Value for myKey: %s\u0026quot; % queryParam  Create that function, assign it a route, and invoke it with a query parameter:\n$ fission function create --name query --env python --code query.py $ fission route create --url /query --function query $ curl $FISSION_ROUTER/query?myKey=myValue Value for myKey: myValue  Body HTTP POST and PUT requests can have a request body. Once again, you can access this body through the request object.\nFor requests with a JSON Content-Type, you can directly get a parsed object with request.get_json() [docs].\nFor form-encoded requests ( application/x-www-form-urlencoded), use request.form.get('key') [docs].\nFor all other requests, use request.data [docs] to get the full request body as a string of bytes.\nYou can find the full docs on the request object in the flask docs.\nControlling HTTP Responses The simplest way to return a response is to return a string. This implicitly says that your function succeeded with a status code of 200; the returned string becomes the body. However, you can control the response more closely using the Flask response object.\nSetting Response Headers import flask def main(): resp = flask.Response(\u0026quot;Hello, world!\u0026quot;) resp.headers['X-My-Response-Header'] = 'Something' return resp  Setting Status Codes import flask def main(): resp = flask.Response(\u0026quot;Hello, world!\u0026quot;) resp.status_code = 200 return resp  HTTP Redirects import flask def main(): r = flask.redirect('/new-url', code=303) # Optional; set this to False to force a relative URL redirect. # Defaults to True, which converts the redirect to an absolute URL # that's only accessible within the cluster. r.autocorrect_location_header = False return r  Logging from flask import current_app def main(): current_app.logger.info(\u0026quot;This is a log message\u0026quot;) return \u0026quot;Hello, world\u0026quot;  Working with dependencies The examples above show simple one-file functions with no dependencies. You can package dependencies with your function, and even use Fission to download and package up the dependencies.\nUsing the Python environment with the builder Fission supports builders, which are language-specific containers that know how to gather dependencies and build from a source zip file, into a deployment zip file.\nTo use a builder with your environment, create the environment with with the \u0026ndash;builder flag:\n$ fission env create --name python --image fission/python-env --builder fission/python-builder  A function with depedencies Let\u0026rsquo;s take a simple python function which has a dependency on the pyyaml module. We can specify the dependencies in requirements.txt and a simple command to build from source. The tree structure of directory and contents of the file would look like:\nsourcepkg/ ├── __init__.py ├── build.sh ├── requirements.txt └── user.py  And the file contents:\n user.py  import sys import yaml document = \u0026quot;\u0026quot;\u0026quot; a: 1 b: c: 3 d: 4 \u0026quot;\u0026quot;\u0026quot; def main(): return yaml.dump(yaml.load(document))   requirements.txt  pyyaml   build.sh  #!/bin/sh pip3 install -r ${SRC_PKG}/requirements.txt -t ${SRC_PKG} \u0026amp;\u0026amp; cp -r ${SRC_PKG} ${DEPLOY_PKG}   Archive these files:  $ zip -jr demo-src-pkg.zip sourcepkg/ adding: __init__.py (stored 0%) adding: build.sh (deflated 24%) adding: requirements.txt (stored 0%) adding: user.py (deflated 25%)  Using the source archive creared in previous step, you can create a package in Fission:\n$ fission package create --sourcearchive demo-src-pkg.zip --env pythonsrc --buildcmd \u0026quot;./build.sh\u0026quot; Package 'demo-src-pkg-zip-8lwt' created  Since we are working with a source package, we provided the build command. Once you create the package, the build process will start and you can see the build logs with the fission package info command:\n$ fission pkg info --name demo-src-pkg-zip-8lwt Name: demo-src-pkg-zip-8lwt Environment: pythonsrc Status: succeeded Build Logs: Collecting pyyaml (from -r /packages/demo-src-pkg-zip-8lwt-v57qil/requirements.txt (line 1)) Using cached PyYAML-3.12.tar.gz Installing collected packages: pyyaml Running setup.py install for pyyaml: started Running setup.py install for pyyaml: finished with status 'done' Successfully installed pyyaml-3.12  Using the package above you can create the function. Since this package is already associated with a source archive, an environment and a build command, you don\u0026rsquo;t need to provide these while creating a function from this package.\nThe only additional thing you\u0026rsquo;ll need to provide is the Function\u0026rsquo;s entrypoint:\n$ fission fn create --name srcpy --pkg demo-src-pkg-zip-8lwt --entrypoint \u0026quot;user.main\u0026quot; function 'srcpy' created # Run the function: $ fission fn test --name srcpy a: 1 b: {c: 3, d: 4}  Modifying the runtime environment image The base runtime image of the Python can also be modified to include dependencies. You can do this for dependencies that all your functions need, thus reducing the size of your function packages (and improving cold-start times).\nFirst, get a copy of the Fission source, which includes the Python environment:\n$ git clone github.com/fission/fission  Get to the Python environment:\n$ cd fission/environments/python  To add package dependencies, edit requirements.txt to add what you need, and rebuild this image as follows:\nNext, build and push the container image. To push your image you\u0026rsquo;ll need access to a Docker registry. Let\u0026rsquo;s assume you have a DockerHub account called \u0026ldquo;USER\u0026rdquo;. (You could use any other registry too.)\n$ docker build -t USER/python-env . $ docker push USER/python-env  Now you can use this image as your function runtime. You can re-create the environment, pointing the runtime at this image:\n$ fission env create --name python --image USER/python-env ...  Or just update it, if you already have an image:\n$ fission env update --name python --image USER/python-env ...  After this, functions that have the env parameter set to \u0026ldquo;python\u0026rdquo; will use this new customized image for running the functions.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/installation/kubernetessetup/",
	"title": "Kubernetes Quick Install",
	"tags": [],
	"description": "",
	"content": " This is a quick guide to help you get started running Kubernetes on your laptop (or on the cloud).\n(This isn\u0026rsquo;t meant as a production Kuberenetes guide; it\u0026rsquo;s merely intended to give you something quickly so you can try Fission on it.)\nMinikube Minikube is the usual way to run Kubernetes on your laptop:\nInstall and start Kubernetes on OSX: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.26.1/minikube-darwin-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Or, install and start Kubernetes on Linux: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.26.1/minikube-linux-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Google Container Engine Alternatively, you can use Google Kubernetes Engine\u0026rsquo;s free trial to get a 3-node cluster. Hop over to Google Cloud to set that up.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/concepts/basic-concept/",
	"title": "Basic Concepts",
	"tags": [],
	"description": "",
	"content": " There are three basic concepts/elements of fission:\nFunction A snippet of code write in specific programming language and will be invoked when requests come to fission router.\nFollowing is a simple nodejs helloworld sample\nmodule.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, world!\\n\u0026quot; }; }  Currently, fission support multiple popular language like NodeJs, Go, Python, Java\u0026hellip;etc. For more examples in different languages, please visit fission language examples.\nEnvironment The environment(language) container which runs user function to serve HTTP requests. When a request hit fission router, the env container will load user function into runtime conainer first, then execute the function to serve the request.\nTrigger A fission object maps incoming requests to the backend functions. When a trigger receives requests/events, it will invoke the target function defined in trigger object by sending a HTTP request to function pod.\nCurrently, fission supports following types of trigger:\n HTTP Trigger  The trigger first registers a specific url path to router and proxy all requests hit the url to user function.  Time trigger  A function will be invoked based on the schedule of cron spec.  Message Queue Trigger  The trigger will subscribe and handle any messages sent to the message queue topic. Then, publish function response/error to the predefined response/error topic.  Kubernetes Watch Trigger  A watcher will be created to watch changes of kubernetes objects. If any changes occurred, invoke the target user function.   "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/installation/",
	"title": "Installing Fission",
	"tags": [],
	"description": "",
	"content": " Welcome! This guide will get you up and running with Fission on a Kubernetes cluster.\nCluster preliminaries If you don\u0026rsquo;t have a Kubernetes cluster, here\u0026rsquo;s a quick guide to set one up.\nFirst, let\u0026rsquo;s ensure you have the Kubernetes CLI and Helm installed and ready. If you already have helm, skip ahead to the fission install.\nIf you cannot (or don\u0026rsquo;t want to) use Helm, there is an alternative installation method possible; see installing without Helm..\nKubernetes CLI Ensure you have the Kubernetes CLI.\nYou can get the Kubernetes CLI for OSX like this:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Or, for Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Next, ensure you have access to a cluster. Do this by using kubectl to check your Kubernetes version:\n$ kubectl version  We will need at least Kubernetes 1.6.\nSet up Helm Helm is an installer for Kubernetes. If you already use helm, skip to the next section.\nTo install Helm, first you\u0026rsquo;ll need the helm CLI:\nOn OS X:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.11.0-darwin-amd64.tar.gz $ tar xzf helm-v2.11.0-darwin-amd64.tar.gz $ mv darwin-amd64/helm /usr/local/bin  On Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.11.0-linux-amd64.tar.gz $ tar xzf helm-v2.11.0-linux-amd64.tar.gz $ mv linux-amd64/helm /usr/local/bin  Next, install the Helm server on your Kubernetes cluster. Before you do that, you have to give helm\u0026rsquo;s server privileges to install software on your cluster.\nFor example, you can use the following steps to install helm using a dedicated service account with full cluster admin privileges.\n$ kubectl create serviceaccount --namespace kube-system tiller $ kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller $ helm init --service-account tiller  Or, if your cluster is already set up with a permissive service account (this varies by version and how your Kubernetes was installed), you can simply do:\n$ helm init  Install Fission (if you have helm) List of all supported configurations for the charts fission-all and fission-core can be found here\nMinikube Since minikube 0.26.0 the default bootstrapper is kubeadm which enables RBAC by default. For those who work on versions before 0.26.0, please follow the steps below to enable RBAC.\n# For minikube before version 0.26.0 $ minikube start --extra-config=apiserver.Authorization.Mode=RBAC  Then, you should see the cluster role cluster-admin.\n$ kubectl get clusterroles cluster-admin NAME AGE cluster-admin 44d  Install fission with helm\n$ helm install --name fission --namespace fission --set serviceType=NodePort,routerServiceType=NodePort https://github.com/fission/fission/releases/download/1.0-rc1/fission-all-1.0-rc1.tgz  The serviceType variable allows configuring the type of Kubernetes service outside the cluster. You can use ClusterIP if you don\u0026rsquo;t want to expose anything outside the cluster.\nCloud hosted clusters (GKE, AWS, Azure etc.) $ helm install --name fission --namespace fission https://github.com/fission/fission/releases/download/1.0-rc1/fission-all-1.0-rc1.tgz  Minimal version The fission-all helm chart installs a full set of services including the NATS message queue, influxDB for logs, etc. If you want a more minimal setup, you can install the fission-core chart instead:\n$ helm install --name fission --namespace fission https://github.com/fission/fission/releases/download/1.0-rc1/fission-core-1.0-rc1.tgz  Install Fission \u0026ndash; alternative method without helm This method uses kubectl apply to install Fission. You can edit the YAML file before applying it to your cluster, if you want to change anything in it.\nChoose one of the following commands to run:\n# Full Fission install, cloud hosted cluster: $ kubectl apply -f https://github.com/fission/fission/releases/download/1.0-rc1/fission-all-1.0-rc1.yaml # Full install on minikube: $ kubectl apply -f https://github.com/fission/fission/releases/download/1.0-rc1/fission-all-1.0-rc1-minikube.yaml # Minimal install on cloud hosted cluster: $ kubectl apply -f https://github.com/fission/fission/releases/download/1.0-rc1/fission-core-1.0-rc1.yaml # Minimal install on minikube: $ kubectl apply -f https://github.com/fission/fission/releases/download/1.0-rc1/fission-core-1.0-rc1-minikube.yaml  Next, install the Fission CLI.\nInstall the Fission CLI OS X Get the CLI binary for Mac:\n$ curl -Lo fission https://github.com/fission/fission/releases/download/1.0-rc1/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/1.0-rc1/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nRun an example Finally, you\u0026rsquo;re ready to use Fission!\n$ fission env create --name nodejs --image fission/node-env:1.0-rc1 $ curl -LO https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js $ fission function create --name hello --env nodejs --code hello.js $ fission function test --name hello Hello, world!  For a compiled language like Go:\n$ fission env create --name go --image fission/go-env:1.0-rc1 --builder fission/go-builder:1.0-rc1 $ curl -LO https://raw.githubusercontent.com/fission/fission/master/examples/go/hello.go $ fission function create --name gohello --env go --src hello.go --entrypoint Handler $ fission function test --name gohello Hello, world!  What\u0026rsquo;s next? If something went wrong, we\u0026rsquo;d love to help \u0026ndash; please drop by the slack channel and ask for help.\nCheck out the examples for some example functions.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/concepts/executor/",
	"title": "Function Executors",
	"tags": [],
	"description": "",
	"content": " When you create a function, you can specify an executor for a function. An executor controls how function pods are created and what capabilities are available for that executor type.\nPool-based executor A pool based executor (Refered to as Poolmgr) creates a pool of generic environment pods as soon as you create an environment. The pool size of initial \u0026ldquo;warm\u0026rdquo; containers can be configured based on user needs. These warm containers contain a small dynamic loader for loading the function. Resource requirements are specified at environment level and are inherited by specialized function pods.\nOnce you create a function and invoke it, one of pods from the pool is taken out and \u0026ldquo;specialized\u0026rdquo; and used for execution. This pod is used for subsequent requests for that function. If there are no more requests for a certain idle duration, then this pod is cleaned up. If a new requests come after the earlier specialized pod was cleaned up, then a new pod is specialised from the pool and used for execution.\nPoolmgr executor type is great for functions where lower latency is a requirement. Poolmgr executor type has certain limitations: for example, you can not autoscale them based on demand.\nNew-deployment executor New-Deployment executor (Refered to as Newdeploy) creates a Kubernetes Deployment along with a Service and HorizontalPodAutoscaler(HPA) for function execution. This enables autoscaling of function pods and load balancing the requests between pods. In future additional capabilities will be added for newdeploy executor type such as support for volume etc. In the new-deploy executor, resource requirements can be specified at the function level. These requirements override those specified in the environment.\nNewdeploy executor type can be used for requests with no particular low-latency requirements, such as those invoked asynchronously, minscale can be set to zero. In this case the Kubernetes deployment and other objects will be created on first invocation of the function. Subsequent requests can be served by the same deployment. If there are no requests for certain duration then the idle objects are cleaned up. This mechanism ensures resource consumption only on demand and is a good fit for asynchronous requests.\nFor requests where latency requirements are stringent, a minscale greater than zero can be set. This essentially keeps a minscale number of pods ready when you create a function. When the function is invoked, there is no delay since the pod is already created. Also minscale ensures that the pods are not cleaned up even if the function is idle. This is great for functions where lower latency is more important than saving resource consumption when functions are idle.\nThe latency vs. idle-cost tradeoff The executors allow you as a user to decide between latency and a small idle cost trade-off. Depending on the need you can choose one of the combinations which is optimal for your use case. In future, a more intelligent dispatch mechanism will enable more complex combinations of executors.\n   Executor Type Min Scale Latency Idle cost     Newdeploy 0 High Very low - pods get cleaned up after idlle time   Newdeploy \u0026gt;0 Low Medium, Min Scale number of pods are always up   Poolmgr 0 Low Low, pool of pods are always up    Autoscaling The new deployment based executor provides autoscaling for functions based on CPU usage. In future custom metrics will be also supported for scaling the functions. You can set the initial and maximum CPU for a function and target CPU at which autoscaling will be triggered. Autoscaling is useful for workloads where you expect intermittant spikes in workloads. It also enables optimal the usage of resources to execute functions, by using a baseline capacity with minimum scale and ability to burst up to maximum scale based on spikes in demand.\nLearn more further usage/setup of executor type for functions, please see here\n "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/concepts/",
	"title": "Fission Concepts",
	"tags": [],
	"description": "",
	"content": " Fission has three main concepts: Functions, Environments, and Triggers.\nFunctions A Fission function is something that Fission executes. It\u0026rsquo;s usually a module with one entry point, and that entry point is a function with a certain interface. A number of programming languages are supported for Functions; see below.\nEnvironments Environments are the language-specific parts of Fission. An Environment contains just enough software to build and run a Fission Function.\nSince Fission invokes Functions through HTTP, this means the runtime of an environment is a container with an HTTP server, and usually a dynamic loader that can load a function. Some environments also contain builder containers, which take care of compilation and gathering dependencies.\nThe following pre-built environments are currently available for use in Fission:\n   Environment Image     NodeJS (Alpine) fission/node-env   NodeJS (Debian) fission/node-env-debian   Python 3 fission/python-env   Go fission/go-env   Ruby fission/ruby-env   Binary (for executables or scripts) fission/binary-env   .NET fission/dotnet-env   .NET 2.0 fission/dotnet20-env   Perl fission/perl-env   PHP 7 fission/php-env    To create custom environments you can extend one of the environments in the list or create your own environment from scratch.\nTriggers Functions are invoked on the occurence of an event; a Trigger is what configures Fission to use that event to invoke a function. In other words, a trigger is a binding of events to function invocations.\nFor example, an HTTP Trigger may bind GET requests on a certain path to the invocation of a certain function.\nThere are several types of triggers besides HTTP Triggers: Timer Trigger invoke functions based on time; Message queue triggers for Kafka, NATS, and Azure queues; Kubernetes Watch triggers to invoke functions when something in your cluster changes.\nOther Concepts These are concepts you may not need while starting out, but might be useful to know in more advanced usage.\nArchives An Archive is a zip file containing source code or compiled binaries.\nArchives with runnable functions in them are called Deployment Archives; those with source code in them are called Source Archives.\nPackages A Package is a Fission object containing a Deployment Archive and a Source Archive. A Package also references a certain environment.\nWhen you create a Package with a Source Archive, Fission automatically builds it using the appropriate builder environment, and adds a Deployment Archive to the package.\nSpecifications Specifications (specs for short) are simply YAML config files containing the objects we\u0026rsquo;ve spoken about so far \u0026mdash; Functions, Environments, Triggers, Packages and Archives.\nSpecifications exist only on the client side, and are a way to instruct the Fission CLI about what objects to create or update. They also specify how to bundle up source code, binaries etc into Archives.\nThe Fission CLI features an idempotent deployment tool that works using these specifications.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/installation/upgrade/",
	"title": "Upgrading Fission",
	"tags": [],
	"description": "",
	"content": " If you\u0026rsquo;re using Helm If you installed Fission using helm, upgrade is as simple as helm upgrade:\n# Find the name of the release you want to upgrade $ helm list # Upgrade it $ helm upgrade \u0026lt;release_name\u0026gt; https://github.com/fission/fission/releases/download/1.0-rc1/fission-all-1.0-rc1.tgz  Replace fission-all with fission-core if you\u0026rsquo;re using the minimal Fission install.\nIf you\u0026rsquo;re not using Helm If you installed using kubectl apply of a YAML file, you can simply kubectl apply the new file.\n$ kubectl apply -f https://github.com/fission/fission/releases/download/1.0-rc1/fission-all-1.0-rc1.yaml  Replace fission-all with fission-core if you\u0026rsquo;re using the minimal install.\nUse the -minikube suffix if you\u0026rsquo;re on minikube, as follows:\n$ kubectl apply -f https://github.com/fission/fission/releases/download/1.0-rc1/fission-all-1.0-rc1-minikube.yaml  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/package/",
	"title": "Packaging source code",
	"tags": [],
	"description": "",
	"content": " Creating a Source Package Before you create a package, you need to create an environment with an associated builder image:\n$ fission env create --name pythonsrc --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2 environment 'pythonsrc' created  Let\u0026rsquo;s take a simple python function which has a dependency on the pyyaml module. We can specify the dependencies in requirements.txt and a simple command to build from source. The tree structure of directory and contents of the file would look like:\nsourcepkg/ ├── __init__.py ├── build.sh ├── requirements.txt └── user.py  And the file contents:\n user.py  import sys import yaml document = \u0026quot;\u0026quot;\u0026quot; a: 1 b: c: 3 d: 4 \u0026quot;\u0026quot;\u0026quot; def main(): return yaml.dump(yaml.load(document))   requirements.txt  pyyaml   build.sh  #!/bin/sh pip3 install -r ${SRC_PKG}/requirements.txt -t ${SRC_PKG} \u0026amp;\u0026amp; cp -r ${SRC_PKG} ${DEPLOY_PKG}  Now create an archive before creating the package:\n$zip -jr demo-src-pkg.zip sourcepkg/ adding: __init__.py (stored 0%) adding: build.sh (deflated 24%) adding: requirements.txt (stored 0%) adding: user.py (deflated 25%)  Using the source archive created in previous step, you can create a package in Fission:\n$ fission package create --sourcearchive demo-src-pkg.zip --env pythonsrc --buildcmd \u0026quot;./build.sh\u0026quot; Package 'demo-src-pkg-zip-8lwt' created  Since we are working with a source package, we provided the build command. Once you create the package, the build process will start and you can see the build logs with the fission package info command:\n$ fission pkg info --name demo-src-pkg-zip-8lwt Name: demo-src-pkg-zip-8lwt Environment: pythonsrc Status: succeeded Build Logs: Collecting pyyaml (from -r /packages/demo-src-pkg-zip-8lwt-v57qil/requirements.txt (line 1)) Using cached PyYAML-3.12.tar.gz Installing collected packages: pyyaml Running setup.py install for pyyaml: started Running setup.py install for pyyaml: finished with status 'done' Successfully installed pyyaml-3.12  Using the package above you can create the function. Since package already is associated with a source package, environment and build command, these will be ignored when creating a function.\nThe only additional thing you\u0026rsquo;ll need to provide is the Function\u0026rsquo;s entrypoint:\n$ fission fn create --name srcpy --pkg demo-src-pkg-zip-8lwt --entrypoint \u0026quot;user.main\u0026quot; function 'srcpy' created # Run the function: $ fission fn test --name srcpy a: 1 b: {c: 3, d: 4}  Creating a Deployment Package Before you create a package you need to create an environment with the builder image:\n$ fission env create --name pythondeploy --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2 environment 'pythonsrc' created  We will use a simple Python example which outputs \u0026ldquo;Hello World!\u0026rdquo; in a directory to create a deployment archive:\n$ cat testDir/hello.py def main(): return \u0026quot;Hello, world!\u0026quot; $zip -jr demo-deploy-pkg.zip testDir/  Using the archive and environments created previously, you can create a package:\n$ fission package create --deployarchive demo-deploy-pkg.zip --env pythondeploy Package 'demo-deploy-pkg-zip-whzl' created  Since it is a deployment archive, there is no need to build it, so the build logs for the package will be empty:\n$ fission package info --name demo-deploy-pkg-zip-whzl Name: demo-deploy-pkg-zip-xlaw Environment: pythondeploy2 Status: succeeded Build Logs:  Finally you can create a function with the package and test the function:\n$ fission fn create --name deploypy --pkg demo-deploy-pkg-zip-whzl --entrypoint \u0026quot;hello.main\u0026quot; $ fission fn test --name deploypy Hello, world!  While these examples illustrate how to use packages, you don\u0026rsquo;t have to use them every time you need to build your source code. A better way is to use Specifications.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/access-secret-cfgmap-in-function/",
	"title": "Accessing Secrets in Functions",
	"tags": [],
	"description": "",
	"content": " Functions can access Kubernetes Secrets and ConfigMaps.\nUse secrets for things like API keys, authentication tokens, and so on.\nUse config maps for any other configuration that doesn\u0026rsquo;t need to be a secret.\nCreate A Secret or a ConfigMap You can create a Secret or ConfigMap with the Kubernetes CLI:\n$ kubectl -n default create secret generic my-secret --from-literal=TEST_KEY=\u0026quot;TESTVALUE\u0026quot; $ kubectl -n default create configmap my-configmap --from-literal=TEST_KEY=\u0026quot;TESTVALUE\u0026quot;  Or, use kubectl create -f \u0026lt;filename.yaml\u0026gt; to create these from a YAML file.\napiVersion: v1 kind: Secret metadata: namespace: default name: my-secret data: TEST_KEY: VEVTVFZBTFVF # value after base64 encode type: Opaque --- apiVersion: v1 kind: ConfigMap metadata: namespace: default name: my-configmap data: TEST_KEY: TESTVALUE  Accessing Secrets and ConfigMaps Secrets and configmaps are accessed similarly. Each secret or configmap is a set of key value pairs. Fission sets these up as files you can read from your function.\n# Secret path /secrets/\u0026lt;namespace\u0026gt;/\u0026lt;name\u0026gt;/\u0026lt;key\u0026gt; # ConfigMap path /configs/\u0026lt;namespace\u0026gt;/\u0026lt;name\u0026gt;/\u0026lt;key\u0026gt;  From the previous example, the paths are:\n# secret my-secret /secrets/default/my-secret/TEST_KEY # confimap my-configmap /configs/default/my-configmap/TEST_KEY  Now, let\u0026rsquo;s create a simple python function (leaker.py) that returns the value of Secret my-secret and ConfigMap my-configmap.\n# leaker.py def main(): path = \u0026quot;/configs/default/my-configmap/TEST_KEY\u0026quot; f = open(path, \u0026quot;r\u0026quot;) config = f.read() path = \u0026quot;/secrets/default/my-secret/TEST_KEY\u0026quot; f = open(path, \u0026quot;r\u0026quot;) secret = f.read() msg = \u0026quot;ConfigMap: %s\\nSecret: %s\u0026quot; % (config, secret) return msg, 200  Create an environment and a function:\n# create python env $ fission env create --name python --image fission/python-env # create function named \u0026quot;leaker\u0026quot; $ fission fn create --name leaker --env python --code leaker.py --secret my-secret --configmap my-configmap  Run the function, and the output should look like this:\n$ fission function test --name leaker ConfigMap: TESTVALUE Secret: TESTVALUE  If the Secret or ConfigMap value is updated, the function may not get the updated value for some time; it may get a cached older value.\n "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/",
	"title": "Using Fission",
	"tags": [],
	"description": "",
	"content": " Environments Functions Triggers Controlling Function Execution Packaging source code Accessing Secrets in Functions  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/environments/",
	"title": "Environments",
	"tags": [],
	"description": "",
	"content": " Create an environment You can create an environment on your cluster from an image for that language.\nOptionally, you can specify CPU and memory resource limits. You can also specify the number of initially pre-warmed pods, which is called the poolsize.\n$ fission env create --name node --image fission/node-env --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 4  In case of the pool based executor, the resources specified for environment are used for function pod as well. In case of new deployment executor, you can override the resources when you create a function.\nUsing a builder When you create an environment, you can specify a builder image and builder command which will be used for building from source code. You can override the build command when creating a function. For more details on builder and packages, check out examples in Functions and packages.\n$ fission env create --name python --image fission/python-env:latest --builder fission/python-builder:latest  Viewing environment information You can list the environments or view information of an individual environment:\n$ fission env list NAME UID IMAGE POOLSIZE MINCPU MAXCPU MINMEMORY MAXMEMORY node ac84d62e-001f-11e8-85c9-42010aa00010 fission/node-env:0.4.0 4 40m 80m 64Mi 128Mi $ fission env get --name node NAME UID IMAGE node ac84d62e-001f-11e8-85c9-42010aa00010 fission/node-env:0.4.0 $ kubectl get environment.fission.io -o yaml # Full YAML of Fission environment object  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": " This section walks through working with functions, for controlling execution of functions please refer to Controlling Function Execution\nCreate a function Before creating a function, you\u0026rsquo;ll need an environment; read environments if you haven\u0026rsquo;t already.\nLet\u0026rsquo;s create a simple code snippet in NodeJS which will output the string \u0026ldquo;Hello, world!\u0026rdquo;:\nmodule.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, world!\\n\u0026quot; }; }  Let\u0026rsquo;s create this function on the cluster. This only registers the function with Fission, it doesn\u0026rsquo;t run it yet.\n$ fission fn create --name hello --code hello.js --env node  Next, let\u0026rsquo;s create a route for the function which can be used for making HTTP requests:\n$ fission route create --function hello --url /hello trigger '5327e9a7-6d87-4533-a4fb-c67f55b1e492' created  When you hit this function\u0026rsquo;s URL, you get the expected response:\n$ curl http://${FISSION_ROUTER}/hello Hello, world!  You can also create a function with executor type \u0026ldquo;newdeploy\u0026rdquo; and provide the minimum and maximum number of instances of the function.\n$ fission fn create --name hello --code hello.js --env node --minscale 1 --maxscale 5 --executortype newdeploy  View \u0026amp; update function source code You can look at the source code associated with given function:\n$ fission fn get --name hello module.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, world!\\n\u0026quot; }; }  Let\u0026rsquo;s say you want to update the function to output \u0026ldquo;Hello Fission\u0026rdquo; instead of \u0026ldquo;Hello world\u0026rdquo;, you can update the source file and update the source code for function:\n$ fission fn update --name hello --code ../hello.js package 'hello-js-ku9s' updated function 'hello' updated  Let\u0026rsquo;s verify that the function now responds with a different output than it did earlier:\n$ curl http://${FISSION_ROUTER}/hello Hello, Fission!  Test and debug function You can run a function using the test command. If the function call succeeds, it will output the function\u0026rsquo;s response.\n$ fission fn test --name hello Hello, Fission!  But if there is an error in the function\u0026rsquo;s execution (it returns HTTP \u0026gt;= 300), then the logs of function execution are displayed:\n$ fission fn test --name hello Error calling function hello: 500 Internal server error (fission) \u0026gt; fission-nodejs-runtime@0.1.0 start /usr/src/app \u0026gt; node server.js Codepath defaulting to /userfunc/user Port defaulting to 8888 user code load error: SyntaxError: Unexpected token function ::ffff:10.8.1.181 - - [16/Feb/2018:08:44:33 +0000] \u0026quot;POST /specialize HTTP/1.1\u0026quot; 500 2 \u0026quot;-\u0026quot; \u0026quot;Go-http-client/1.1\u0026quot;  You can also look at function execution logs explicitly:\n$ fission fn logs --name hello [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 fetcher received fetch request and started downloading: {1 {hello-js-rqew default 0 0001-01-01 00:00:00 +0000 UTC \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; map[] map[] [] nil [] } user [] []} [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Successfully placed at /userfunc/user [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Checking secrets/cfgmaps [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Completed fetch request [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 elapsed time in fetch request = 89.844653ms [2018-02-16 08:41:43 +0000 UTC] user code loaded in 0sec 4.235593ms [2018-02-16 08:41:43 +0000 UTC] ::ffff:10.8.1.181 - - [16/Feb/2018:08:41:43 +0000] \u0026quot;POST /specialize HTTP/1.1\u0026quot; 202 - \u0026quot;-\u0026quot; \u0026quot;Go-http-client/1.1\u0026quot; [2018-02-16 08:41:43 +0000 UTC] ::ffff:10.8.1.182 - - [16/Feb/2018:08:41:43 +0000] \u0026quot;GET / HTTP/1.1\u0026quot; 200 16 \u0026quot;-\u0026quot; \u0026quot;curl/7.54.0\u0026quot;  Fission builds \u0026amp; compiled artifacts Most real world functions will require more than one source files. It is also easier to simply provide source files and let Fission take care of building from source files. Fission provides first class support for building from source as well as using compiled artifacts to create functions.\nYou can attach the source/deployment packages to a function or explicitly create packages and use them across functions. Check documentation for package for more information.\nBuilding functions from source Let\u0026rsquo;s take a simple python function which has dependency on a python pyyaml module. We can specify the dependencies in requirements.txt and a simple command to build from source. The tree structure of directory looks like:\nsourcepkg/ ├── __init__.py ├── build.sh ├── requirements.txt └── user.py  And the file contents:\n$ cat user.py import sys import yaml document = \u0026quot;\u0026quot;\u0026quot; a: 1 b: c: 3 d: 4 \u0026quot;\u0026quot;\u0026quot; def main(): return yaml.dump(yaml.load(document)) $ cat requirements.txt pyyaml $ cat build.sh #!/bin/sh pip3 install -r ${SRC_PKG}/requirements.txt -t ${SRC_PKG} \u0026amp;\u0026amp; cp -r ${SRC_PKG} ${DEPLOY_PKG}  You first need to create an environment with environment image and python-builder image specified:\n$ fission env create --name python --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2  Now let\u0026rsquo;s zip the directory containing the source files and create a function with source package:\n$ zip -jr demo-src-pkg.zip sourcepkg/ adding: __init__.py (stored 0%) adding: build.sh (deflated 24%) adding: requirements.txt (stored 0%) adding: user.py (deflated 25%) $ fission fn create --name hellopy --env python --src demo-src-pkg.zip --entrypoint \u0026quot;user.main\u0026quot; --buildcmd \u0026quot;./build.sh\u0026quot; function 'hellopy' created $ fission route create --function hellopy --url /hellopy  Once we create the function, the build process is started. You can check logs of the builder in fission-builder namespace:\n$ kubectl -n fission-builder logs -f py3-4214348-59555d9bd8-ks7m4 builder 2018/02/16 11:44:21 Builder received request: {demo-src-pkg-zip-ninf-djtswo ./build.sh} 2018/02/16 11:44:21 Starting build... === Build Logs ===command=./build.sh env=[PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=py3-4214348-59555d9bd8-ks7m4 PYTHON_4212095_PORT_8000_TCP_PROTO=tcp PY3_4214348_SERVICE_HOST=10.11.250.161 KUBERNETES_PORT=tcp://10.11.240.1:443 PYTHON_4212095_PORT=tcp://10.11.244.134:8000 PYTHON_4212095_PORT_8000_TCP=tcp://10.11.244.134:8000 PYTHON_4212095_PORT_8001_TCP_PROTO=tcp PYTHON_4212095_PORT_8001_TCP_ADDR=10.11.244.134 PY3_4214348_SERVICE_PORT=8000 PY3_4214348_SERVICE_PORT_BUILDER_PORT=8001 PY3_4214348_PORT_8001_TCP=tcp://10.11.250.161:8001 KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_ADDR=10.11.240.1 PY3_4214348_SERVICE_PORT_FETCHER_PORT=8000 PY3_4214348_PORT_8000_TCP=tcp://10.11.250.161:8000 PY3_4214348_PORT_8001_TCP_PORT=8001 PYTHON_4212095_SERVICE_PORT_FETCHER_PORT=8000 PYTHON_4212095_PORT_8000_TCP_ADDR=10.11.244.134 KUBERNETES_SERVICE_HOST=10.11.240.1 PY3_4214348_PORT=tcp://10.11.250.161:8000 PYTHON_4212095_SERVICE_PORT_BUILDER_PORT=8001 PYTHON_4212095_PORT_8001_TCP=tcp://10.11.244.134:8001 PY3_4214348_PORT_8000_TCP_PROTO=tcp PY3_4214348_PORT_8000_TCP_PORT=8000 KUBERNETES_SERVICE_PORT_HTTPS=443 KUBERNETES_PORT_443_TCP=tcp://10.11.240.1:443 PYTHON_4212095_PORT_8001_TCP_PORT=8001 PY3_4214348_PORT_8000_TCP_ADDR=10.11.250.161 PY3_4214348_PORT_8001_TCP_PROTO=tcp KUBERNETES_SERVICE_PORT=443 PYTHON_4212095_SERVICE_PORT=8000 PYTHON_4212095_PORT_8000_TCP_PORT=8000 PY3_4214348_PORT_8001_TCP_ADDR=10.11.250.161 KUBERNETES_PORT_443_TCP_PROTO=tcp PYTHON_4212095_SERVICE_HOST=10.11.244.134 HOME=/root SRC_PKG=/packages/demo-src-pkg-zip-ninf-djtswo DEPLOY_PKG=/packages/demo-src-pkg-zip-ninf-djtswo-c40gfu] Collecting pyyaml (from -r /packages/demo-src-pkg-zip-ninf-djtswo/requirements.txt (line 1)) Downloading PyYAML-3.12.tar.gz (253kB) Installing collected packages: pyyaml Running setup.py install for pyyaml: started Running setup.py install for pyyaml: finished with status 'done' Successfully installed pyyaml-3.12 ================== 2018/02/16 11:44:24 elapsed time in build request = 3.460498847s  Once the build has succeeded, you can hit the function URL to test the function:\n$curl http://$FISSION_ROUTER/hellopy a: 1 b: {c: 3, d: 4}  If you\u0026rsquo;re using Fission with source code, be sure to read about the recommended development workflow.\nUsing compiled artifacts with Fission In some cases you have a pre-built deployment package which you need to deploy to Fission. For this example let\u0026rsquo;s use a simple python file as a deployment package but in practice it can be any other compiled package.\nWe will use a simple python file in a directory and turn it into a deployment package:\n$ cat testDir/hello.py def main(): return \u0026quot;Hello, world!\u0026quot; $zip -jr demo-deploy-pkg.zip testDir/  Let\u0026rsquo;s use the deployment package to create a function and route and then test it.\n$ fission fn create --name hellopy --env python --deploy demo-deploy-pkg.zip --entrypoint \u0026quot;hello.main\u0026quot; function 'hellopy' created $ fission route create --function hellopy --url /hellopy $ curl http://$FISSION_ROUTER/hellopy Hello, world!  View function information You can retrieve metadata information of a single function or list all functions to look at basic information of functions:\n$ fission fn getmeta --name hello NAME UID ENV hello 34234b50-12f5-11e8-85c9-42010aa00010 node $ fission fn list NAME UID ENV EXECUTORTYPE MINSCALE MAXSCALE TARGETCPU hello 34234b50-12f5-11e8-85c9-42010aa00010 node poolmgr 0 1 80 hello2 e37a46e3-12f4-11e8-85c9-42010aa00010 node newdeploy 1 5 80  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/trigger/",
	"title": "Triggers",
	"tags": [],
	"description": "",
	"content": " Create a HTTP Trigger An HTTP trigger invokes a function when there is an HTTP request.\nYou can specify the relative URL and HTTP method for a trigger:\n$ fission httptrigger create --url /hello --method GET --function hello trigger '94cd5163-30dd-4fb2-ab3c-794052f70841' created $ curl http://$FISSION_ROUTER/hello Hello World!  FISSION_ROUTER is the externally-visible address of your Fission router service. For how to set up environment variable FISSION_ROUTER, see here\n Also, we can create a trigger contains URL parameter by putting placeholders in value of --url flag.\n$ fission httptrigger create --method GET \\ --url \u0026quot;/guestbook/messages/{id}\u0026quot; --function restapi-get  Since fission uses gorilla/mux as underlying URL router, you can write regular expression to filter out illegal API requests.\n$ fission httptrigger create --method GET \\ --url \u0026quot;/guestbook/messages/{id:[0-9]+}\u0026quot; --function restapi-get  Learn how to access URL parameters in function to develop a REST API, please visit here\n If you want to use Kubernetes Ingress for the HTTP Trigger, you can provide the --createingress flag and a hostname. If the hostname is not provided, it defaults to \u0026ldquo;*\u0026ldquo;, which indicates a wildcard host.\n$ fission httptrigger create --url /hello --method GET --function hello --createingress --host acme.com trigger '94cd5163-30dd-4fb2-ab3c-794052f70841' created $ fission route list NAME METHOD HOST URL INGRESS FUNCTION_NAME 94cd5163-30dd-4fb2-ab3c-794052f70841 GET acme.com /hello true hello  Please note that for ingress to work, you will have to deploy an ingress controller in Kubernetes cluster. Kubernetes currently supports and maintains the following ingress controllers:\n Nginx Ingress Controller GCE Ingress Controller  Other Ingress controllers exist, such as F5 networks and Kong.\nCreate a Time Trigger Time-based triggers invoke functions based on time. They can run once or repeatedly. They\u0026rsquo;re specified using cron string specifications:\n$ fission tt create --name halfhourly --function hello --cron \u0026quot;*/30 * * * *\u0026quot; trigger 'halfhourly' created  You can also use a friendlier syntax such \u0026ldquo;@every 1m\u0026rdquo; or \u0026ldquo;@hourly\u0026rdquo;:\n$ fission tt create --name minute --function hello --cron \u0026quot;@every 1m\u0026quot; trigger 'minute' created  And you can list time triggers to see their associated function and cron strings:\n$ fission tt list NAME CRON FUNCTION_NAME halfhourly 0 30 * * * * hello minute @every 1m hello  You can also use showschedule to show the upcoming schedule for a given cron spec. Use this to test your cron strings. And note that the server\u0026rsquo;s time is used to invoke functions, not your laptop\u0026rsquo;s time!\n$ fission tt showschedule --cron \u0026quot;0 30 * * * *\u0026quot; --round 5 Current Server Time: 2018-06-12T05:07:41Z Next 1 invocation: 2018-06-12T05:30:00Z Next 2 invocation: 2018-06-12T06:30:00Z Next 3 invocation: 2018-06-12T07:30:00Z Next 4 invocation: 2018-06-12T08:30:00Z Next 5 invocation: 2018-06-12T09:30:00Z  Create a Message Queue Trigger A message queue trigger invokes a function based on messages from an message queue. Optionally, it can place the response of a function onto another queue.\nNATS and Azure Storage Queue are supported queues:\n$ fission mqt create --name hellomsg --function hello --mqtype nats-streaming --topic newfile --resptopic newfileresponse trigger 'hellomsg' created  You can list or update message queue triggers with fission mqt list, or fission mqt update.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/executor/",
	"title": "Controlling Function Execution",
	"tags": [],
	"description": "",
	"content": " Fission Concepts/Function Executors describes the major difference between executors. In this guide, we will go through how to set up/config different executors for function.\nPoolmgr (Pool-based executor) You can create a function like following to use poolmgr as backend executor.\n# The default executor type for function is poolmgr, $ fission fn create --name foobar --env nodejs --code hello.js # Or, set executor type to poolmgr explicitly $ fission fn create --name foobar --env nodejs --code hello.js --executortype poolmgr  When an environment is created, poolmgr creates a pool of generic pods with default pool size 3. We may want to adjust the size of pools based on our need (e.g. resource efficiency), for some historic reason fission now only supports to adjust pool size by giving --version 3 flag when creating an environment.\n$ fission env create --name python --version 3 --poolsize 1 --image fission/python-env:0.11.0 $ kubectl -n fission-function get pod -l environmentName=test  Now, you shall see only one pod for the environment we just created.\nWith --poolsize 0, the executor will not be able to specialize any function due to no generic pod in pool.\n If you want to set resource requests/limits for all functions use the same environment, you can provide extra min/max cpu \u0026amp; memory flags to set them at environment-level. For example, we want to limit an environment\u0026rsquo;s min/max cpu to 100m/200m and min/max memory to 128Mi/256Mi.\n$ fission env create --name python --version 3 --poolsize 1 --image fission/python-env \\ --mincpu 100 --maxcpu 200 --minmemory 128 --maxmemory 256 $ fission env list NAME UID IMAGE POOLSIZE MINCPU MAXCPU MINMEMORY MAXMEMORY EXTNET GRACETIME python 73e4e8a3-db49-... fission/python-env 1 100m 200m 128Mi 256Mi false 360  Newdeploy (New-deployment executor) Newdeploy provides autoscaling and min/max scale setting for functions, and allow a function to handle spikes in workloads. To create a function with newdeploy, you have to set executor type to newdeploy explicitly.\n$ fission fn create --name foobar --env nodejs --code hello.js --executortype newdeploy  Unlike Poolmgr sets all configs at the environment-level. Newdeploy provides more fine grained configuration at the function-level. Here are some flags for Newdeploy:\n--mincpu value Minimum CPU to be assigned to pod (In millicore, minimum 1) --maxcpu value Maximum CPU to be assigned to pod (In millicore, minimum 1) --minmemory value Minimum memory to be assigned to pod (In megabyte) --maxmemory value Maximum memory to be assigned to pod (In megabyte) --minscale value Minimum number of pods (Uses resource inputs to configure HPA) --maxscale value Maximum number of pods (Uses resource inputs to configure HPA) --targetcpu value Target average CPU usage percentage across pods for scaling (default: 80)  So if we want to limit a function\u0026rsquo;s min/max cpu to 100m/200m and min/max memory to 128Mi/256Mi.\n$ fission fn create --name foobar --env nodejs --code hello.js --executortype newdeploy \\ --minscale 1 --maxscale 3 --mincpu 100 --maxcpu 200 --minmemory 128 --maxmemory 256 $ fission fn list NAME UID ENV EXECUTORTYPE MINSCALE MAXSCALE MINCPU MAXCPU MINMEMORY MAXMEMORY TARGETCPU foobar afe7666a-db51-11e8... nodejs newdeploy 1 3 100m 200m 128Mi 256Mi 80 $ kubectl -n fission-function get deploy -l functionName=foobar NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE foobar-hhytbcx4 1 1 1 1 51s  With --minscale 0, a function will experience long cold-start time since it takes time for executor to create/scale deployment to 1 replica.\n Eliminating cold start If you want to eliminate the cold start for a function, you can run the function with executortype as \u0026ldquo;newdeploy\u0026rdquo; and minscale set to 1. This will ensure that at least one replica of function is always running and there is no cold start in request path.\n$ fission fn create --name hello --env node --code hello.js --minscale 1 --executortype newdeploy  Autoscaling Let\u0026rsquo;s create a function to demonstrate the autoscaling behaviour in Fission. We create a simple function which outputs \u0026ldquo;Hello World\u0026rdquo; in using NodeJS. We have kept the CPU request and limit purposefully low to simulate the load and also kept the target CPU percent to 50%.\n$ fission fn create --name hello --env node --code hello.js --executortype newdeploy \\ --minmemory 64 --maxmemory 128 --minscale 1 --maxscale 6 --targetcpu 50 function 'hello' created  Now let\u0026rsquo;s use hey to generate the load with 250 concurrent and a total of 10000 requests:\n$ hey -c 250 -n 10000 http://${FISSION_ROUTER}/hello Summary: Total:\t67.3535 secs Slowest:\t4.6192 secs Fastest:\t0.0177 secs Average:\t1.6464 secs Requests/sec:\t148.4704 Total data:\t160000 bytes Size/request:\t16 bytes Response time histogram: 0.018 [1]\t| 0.478 [486]\t|∎∎∎∎∎∎∎ 0.938 [971]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 1.398 [2686]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 1.858 [2326]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 2.318 [1641]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 2.779 [1157]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 3.239 [574]\t|∎∎∎∎∎∎∎∎∎ 3.699 [120]\t|∎∎ 4.159 [0]\t| 4.619 [38]\t|∎ Latency distribution: 10% in 0.7037 secs 25% in 1.1979 secs 50% in 1.5038 secs 75% in 2.1959 secs 90% in 2.6670 secs 95% in 2.8855 secs 99% in 3.4102 secs Details (average, fastest, slowest): DNS+dialup:\t0.0058 secs, 0.0000 secs, 1.0853 secs DNS-lookup:\t0.0000 secs, 0.0000 secs, 0.0000 secs req write:\t0.0000 secs, 0.0000 secs, 0.0026 secs resp wait:\t1.6405 secs, 0.0176 secs, 3.6144 secs resp read:\t0.0001 secs, 0.0000 secs, 0.0056 secs Status code distribution: [200]\t10000 responses  While the load is being generated, we will watch the HorizontalPodAutoscaler and how it scales over a period of time. As you can notice, the number of pods is scaled from 1 to 3 after the load rises from 8 - 103%. After the load generator stops, it takes a few iterations to scale down from 3 to 1 pod.\nWhen testing the scaling behaviour, do keep in mind that the scaling event has an initial delay of up to a minute and waits for the average CPU to reach 110% above the threshold before scaling up. It is best to maintain a minimum number of pods which can handle initial load and scale as needed.\nYou will notice that the scaling up and down has different behaviour in terms of response time. This behaviour is governed by the frequency at which the controller watches (which defaults to 30s) and parameters set on controller-manager for upscale/downscale delay. More details can be found here\n$ kubectl -n fission-function get hpa -w NAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGE hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 1 3m hello-qoxmothj Deployment/hello-qoxmothj 8% / 50% 1 6 1 3m hello-qoxmothj Deployment/hello-qoxmothj 103% / 50% 1 6 1 4m hello-qoxmothj Deployment/hello-qoxmothj 103% / 50% 1 6 3 5m hello-qoxmothj Deployment/hello-qoxmothj 25% / 50% 1 6 3 5m hello-qoxmothj Deployment/hello-qoxmothj 25% / 50% 1 6 3 6m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 6m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 7m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 7m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 8m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 8m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 9m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 9m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 10m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 10m hello-qoxmothj Deployment/hello-qoxmothj 7% / 50% 1 6 1 11m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 11m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 12m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 12m  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/installation/env_vars/",
	"title": "Environment Variables",
	"tags": [],
	"description": "",
	"content": " Namespace Set FISSION_NAMESPACE to the namespace where the Fission is installed. You don\u0026rsquo;t have to set this unless there are multiple Fission installations in different namespaces within the same Kubernetes cluster.\n$ export FISSION_NAMESPACE \u0026lt;namespace\u0026gt;  Fission Router Address It\u0026rsquo;s convenient to set the FISSION_ROUTER environment variable to the externally-visible address of the Fission router.\nMinikube If you\u0026rsquo;re using minikube, use these commands:\n$ export FISSION_ROUTER=$(minikube ip):$(kubectl -n fission get svc router -o jsonpath='{...nodePort}')  Cloud Provider If you want to expose the router to the internet, the service type of router service must be set to LoadBalancer. This is the default in the helm chart.\n$ kubectl --namespace fission get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE router LoadBalancer 10.107.80.21 \u0026lt;pending\u0026gt; 80:31314/TCP 11d  If the field EXTERNAL-IP shows \u0026lt;pending\u0026gt;, it means that kubernetes is waiting for cloud provider to allocate the public IP address. It often takes a few minutes to get an IP address. Then:\n# AWS $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..hostname}') # GCP $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..ip}')  Using FISSION_ROUTER env var $ curl http://${FISSION_ROUTER}/\u0026lt;url-path\u0026gt;  Troubleshooting If your cluster is running in an environment that does not support external load balancer (e.g., minikube), the EXTERNAL-IP of fission router will stay in pending state.\n$ kubectl --namespace fission get svc router NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE router LoadBalancer 10.39.253.73 \u0026lt;pending\u0026gt; 80:31377/TCP 27d  In this case, you can use the port-forward method instead:\n# Port-forward $ kubectl --namespace fission port-forward $(kubectl --namespace fission get pod -l svc=router -o name) \u0026lt;local port\u0026gt;:80 \u0026amp; $ export FISSION_ROUTER=127.0.0.1:\u0026lt;local port\u0026gt;  Now, curl http://${FISSION_ROUTER}/ will open a connection that goes through the port forward you just created. This is useful for local testing of your function.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/developer-workflow/",
	"title": "Source Code Organization and Your Development Workflow",
	"tags": [],
	"description": "",
	"content": " You\u0026rsquo;ve made a Hello World function in your favourite language, and you\u0026rsquo;ve run it on your Fission deployment. What\u0026rsquo;s next?\nHow should you organize source code when you have lots of functions? How should you automate deployment into the cluster? What about version control? How do you test before deploying?\nThe answers to these questions start from a common first step: how do you specify an application?\nDeclarative Specifications Instead of invoking the Fission CLI commands, you can specify your functions in a set of YAML files. This is better than scripting the fission CLI, which is meant as a user interface, not a programming interface.\nYou\u0026rsquo;ll usually want to track these YAML files in version control along with your source code. Fission provides CLI tools for generating these specification files, validating them, and \u0026ldquo;applying\u0026rdquo; them to a Fission installation.\nWhat does it mean to apply a specification? It means putting specification to effect: figuring out the things that need to be changed on the cluster, and updating them to make them the same as the specification.\nApplying a Fission spec goes through these steps:\n Resources (functions, triggers, etc) that are in the specification but don\u0026rsquo;t exist on the cluster are created. Local source files are packaged and uploaded.\n Resources that are both in the specs and on the cluster are compared. If they\u0026rsquo;re different, the ones on the cluster are changed to match the spec.\n Resources present only on the cluster and not in the spec are destroyed. (This deletion is limited to resources that were created by a previous apply; this makes sure that Fission doesn\u0026rsquo;t delete unrelated resources. See below for how this calculation works.)\n  Note that running apply more than once is equivalent to running it once: in other words, it\u0026rsquo;s idempotent.\nUsage Summary Start using Fission\u0026rsquo;s declarative application specifications in 3 steps:\n Initialize a directory of specs: fission spec init Generate some YAMLs: fission function create --spec ... Apply them to a cluster: fission spec apply --wait  You can also deploy continuously with fission spec apply --watch.\nWe\u0026rsquo;ll see examples of all these commands in the tutorial below.\nTutorial This tutorial assumes you\u0026rsquo;ve already set up Fission, and tested a simple hello world function to make sure everything\u0026rsquo;s working. To learn how to do that, head over to the installation guide.\nWe\u0026rsquo;ll make a small calculator app with one python environment and two functions, all of which will be declaratively specified using YAML files. This is a somewhat contrived example, but it is just meant as an illustration.\nMake an empty directory $ mkdir spec-tutorial $ cd spec-tutorial  Initialize the specs directory $ fission spec init  This creates a specs/ directory. You\u0026rsquo;ll see a fission-config.yaml in there. This file has a unique ID in it; everything created on the cluster from these specs will be annotated with that unique ID.\nSetup a Python environment $ fission env create --spec --name python --image fission/python-env:0.11.0 --builder fission/python-builder:0.11.0  This command creates a YAML file under specs called specs/env-python.yaml.\nCode two functions One function simply returns a simple web form. You can download the code or copy paste from the contents below:\n$ curl -Lo form.py http://xxx  Here are its contents:\ndef main(): return \u0026quot;\u0026quot;\u0026quot; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026quot;/calculate\u0026quot; method=\u0026quot;GET\u0026quot;\u0026gt; \u0026lt;input name=\u0026quot;num_1\u0026quot;/\u0026gt; \u0026lt;input name=\u0026quot;num_2\u0026quot;/\u0026gt; \u0026lt;input name=\u0026quot;operator\u0026quot;/\u0026gt; \u0026lt;button\u0026gt;Calculate\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026quot;\u0026quot;\u0026quot;  The form accepts a simple arithmetic expression. When it is submitted, it makes a request to the second function, which calculates the expression entered.\nHere\u0026rsquo;s the calculator function:\n$ curl -Lo calc.py http://yyy  That function is pretty simple too:\ndef main(): num_1 = int(request.form['num_1']) num_2 = int(request.form['num_2']) operator = request.form['operator'] if operator == '+': result = num_1 + num_2 elsif operator == '-': result = num_1 - num_2 return \u0026quot;%s %s %s = %s\u0026quot; % (num_1, operator, num_2, result)  Create specs for these functions Let\u0026rsquo;s create a specification for each of these functions. This specifies the function name, where the code lives, and associates the function with the python environment:\n$ fission function create --spec --name calc-form --env python --src form.py --entrypoint form.main $ fission function create --spec --name calc-eval --env python --src calc.py --entrypoint calc.main  You can see the generated YAML files in specs/function-calc-form.yaml and specs/function-calc-eval.yaml.\nCreate HTTP trigger specs $ fission route create --spec --method GET --url /form --function calc-form $ fission route create --spec --method GET --url /eval --function calc-eval  This creates YAML files specifying that GET requests on /form and /eval invoke the functions calc-form and calc-eval respectively.\nValidate your specs Spec validation does some basic checks: it makes sure there are no duplicate functions with the same name, and that references between various resources are correct.\n$ fission spec validate  You should see no errors.\nApply: deploy your functions to Fission You can simply use apply to deploy the environment, functions and HTTP triggers to the cluster.\n$ fission spec apply --wait  (This uses your kubeconfig to connect to Fission, just like kubectl. See Usage Reference below for options.)\nTest a function Make sure your function is working:\n$ fission function test --name calc-form  You should see the output of the calc-form function.\nTo test the other function, open the URL of the Fission router service in a browser, enter two numbers and an operator, and click submit.\n(If you don\u0026rsquo;t know the address of the Fission router, you can find it with kubectl: kubectl -n fission get service router.)\nModify the function and re-deploy it Let\u0026rsquo;s try modifying a function: let\u0026rsquo;s change the calc-eval function to support multiplication, too.\n ... elsif operator == '*': result = num_1 * num_2 ...  You can add the above lines to calc.py, or just download the modified function:\n$ curl -Lo calc.py http://zzz  To deploy your changes, simply apply the specs again:\n$ fission spec apply --wait  This should output something like:\n1 archive updated: calc-eval-xyz 1 package updated: calc-eval-xyz 1 function updated: calc-eval  Your new updated function is deployed!\nTest it out by entering a * for the operator in the form!\nAdd dependencies to the function Let\u0026rsquo;s say you\u0026rsquo;d like to add a pip requirements.txt to your function, and include some libraries in it, so you can import them in your functions.\nCreate a requirements.txt, and add something to it:\nxxx  Modify the ArchiveUploadSpec inside specs/function-.yaml\nOnce again, deploying is the same:\n$ fission spec apply --wait  This command figures out that one function has changed, uploads the source to the cluster, and waits until the Fission builder on the cluster finishes rebuilding this updated source code.\nA bit about how this works Kubernetes manages its state as a set of resources. Deployments, Pod, Services are examples of resources. They represent a target state, and Kubernetes then does the work to ensure this target state is met.\nKubernetes resources can be extended, using Custom Resources. Fission runs on top of Kubernetes and sets up your functions, environments and triggers as Custom Resources. You can see even these custom resources from kubectl: try kubectl get customeresourcedefinitions or kubectl get function.fission.io\nYour specs directory is, basically, set of resources plus a bit of configuration. Each YAML file contains one or more resources. They are separated by a \u0026ldquo;\u0026mdash;\u0026rdquo; separator. The resources are functions, environments, triggers.\nThere\u0026rsquo;s a special resource there, ArchiveUploadSpec. This is in fact not a resource, just looks like one in the YAML files. It is used to specify and name a set of files that will be uploaded to the cluster. fission spec apply uses these ArchiveUploadSpecs to create archives locally and upload them. The specs reference these archives using archive:// URLs. These aren\u0026rsquo;t \u0026ldquo;real\u0026rdquo; URLs; they are replaced by http URLs by the fission spec implementation after the archives are uploaded to the cluster. On the cluster, Archives are tracked with checksums; the Fission CLI only uploads archives when their checksum has changed.\nUsage Reference NAME: fission spec - Manage a declarative app specification USAGE: fission spec command [command options] [arguments...] COMMANDS: init Create an initial declarative app specification validate Validate Fission app specification apply Create, update, or delete Fission resources from app specification destroy Delete all Fission resources in the app specification helm Create a helm chart from the app specification OPTIONS: --help, -h show help  fission spec init NAME: fission spec init - Create an initial declarative app specification USAGE: fission spec init [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs --name value (optional) Name for the app, applied to resources as a Kubernetes annotation  fission spec validate NAME: fission spec validate - Validate Fission app specification USAGE: fission spec validate [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs  fission spec apply NAME: fission spec apply - Create, update, or delete Fission resources from app specification USAGE: fission spec apply [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs --delete Allow apply to delete resources that no longer exist in the specification --wait Wait for package builds --watch Watch local files for change, and re-apply specs as necessary  fission spec destroy NAME: fission spec destroy - Delete all Fission resources in the app specification USAGE: fission spec destroy [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/ingress-tutorial/",
	"title": "Exposing functions with Ingress",
	"tags": [],
	"description": "",
	"content": " This tutorial will walk you through exposing a function using an ingress controller (You can read more about ingress and ingress controller here). We will make the function available on a fully qualified domain name (FQDN) using Fission\u0026rsquo;s route and ingress controller setup in a cloud environment.\nSetup \u0026amp; pre-requisites You will need a Kubernetes cluster with Fission installed (Please check installation page for details). This tutorial uses a cloud load balancer, but if you are using Minikube you might want to take a look at details here\nLater parts of this tutorial use a FQDN to reach the function. If you plan to go along in this section, you will need a domain name setup and access to modify the NS records and create A record in the zone of the domain name you have. The tutorial uses Google cloud to walk through the tutorial but you can use any cloud you prefer to. Also the changes in name server can take 24-48 hours so you may want to use an already created domain name.\nSetup an Ingress Controller First thing we will need is an ingress controller and we will use Nginx ingress controller in this tutorial. Based on your setup you can choose one of the multiple ways to install Nginx ingress controller. This setup should work with other ingress controllers also but has not been tested.\nLet\u0026rsquo;s verify that the installation succeeded:\n$ kubectl get all -n ingress-nginx NAME READY STATUS RESTARTS AGE po/default-http-backend-66b447d9cf-4q8f7 1/1 Running 0 19d po/nginx-ingress-controller-58fcfdc6fd-2cwts 1/1 Running 0 19d NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE svc/default-http-backend 10.11.243.109 \u0026lt;none\u0026gt; 80/TCP 19d svc/ingress-nginx 10.11.245.254 35.200.150.175 80:31000/TCP,443:30666/TCP 19d NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deploy/default-http-backend 1 1 1 1 19d deploy/nginx-ingress-controller 1 1 1 1 19d NAME DESIRED CURRENT READY AGE rs/default-http-backend-66b447d9cf 1 1 1 19d rs/nginx-ingress-controller-58fcfdc6fd 1 1 1 19d  Following are key points to validate that ingress controller installation succeeded (Please refer to output of a successful installation above)\n The ingress controller pod is up and running The ingress-nginx service has a external IP address populated If you hit the external IP address of the ingress-nginx, you get the default backend page:  $ curl http://35.200.150.175 default backend - 404  Deploying Function with ingress An ingress resource allows traffic from outside the cluster to reach the services inside the cluster. The ingress is fulfilled by an ingress controller. In following sections we will create a function and enable traffic outside the cluster to reach the function.\nCreate a function We will create an environment, a function and test that it works:\n$ fission env create --name nodejs --image fission/node-env environment 'nodejs' created $ cat hello.js module.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, Fission!\\n\u0026quot; }; } $ fission fn create --name hello --env nodejs --code hello.js function 'hello' created $ fission fn test --name hello Hello, Fission!  Create a internal route Let\u0026rsquo;s create a route which is not exposed via the ingress controller so that it can be consumed by resources inside the cluster only.\nCurrently since functions are also exposed via the Fission router, the function can be accessed from outside the cluster but in future the router may not expose all functions outside the cluster.\n$ fission route create --url /ihello --function hello trigger '249838c9-9ae3-492a-bba1-b0464ae65671' created $ fission route list NAME METHOD HOST URL INGRESS FUNCTION_NAME 249838c9-9ae3-492a-bba1-b0464ae65671 GET /ihello false hello  This route will be accessible at http://$FISSION_ROUTER/ihello but if tried to access on the ingress controller address http://\u0026lt;INGRESS-CONTROLLER-EXTERNAL-IP\u0026gt;/ihello you will get a default backend page. This is expected result as we did not create an ingress for this route.\nCreate a external route Now let\u0026rsquo;s create a route which we will expose over ingress controller. We will create a route with createingress flag enabled:\n$ fission route create --url /hello --function hello --createingress trigger '301b3cb0-5ac1-4211-a1ed-2b0ad9143e34' created $ fission route list NAME METHOD HOST URL INGRESS FUNCTION_NAME 249838c9-9ae3-492a-bba1-b0464ae65671 GET /ihello false hello 301b3cb0-5ac1-4211-a1ed-2b0ad9143e34 GET /hello true hello  If you check the ingress controller pod logs, you will notice that the ingress controller has re-loaded the configuration for the newly created ingress resource:\nI0604 12:47:08.983567 5 controller.go:168] backend reload required I0604 12:47:08.985535 5 event.go:218] Event(v1.ObjectReference{Kind:\u0026quot;Ingress\u0026quot;, Namespace:\u0026quot;fission\u0026quot;, Name:\u0026quot;301b3cb0-5ac1-4211-a1ed-2b0ad9143e34\u0026quot;, UID:\u0026quot;64bffe8c-67f5-11e8-98e8-42010aa00018\u0026quot;, APIVersion:\u0026quot;extensions\u0026quot;, ResourceVersion:\u0026quot;18017617\u0026quot;, FieldPath:\u0026quot;\u0026quot;}): type: 'Normal' reason: 'CREATE' Ingress fission/301b3cb0-5ac1-4211-a1ed-2b0ad9143e34 I0604 12:47:09.117629 5 controller.go:177] ingress backend successfully reloaded...  If you now hit the function at ingress controller\u0026rsquo;s IP and the path (http://\u0026lt;INGRESS-CONTROLLER-EXTERNAL-IP\u0026gt;/hello), you will get function\u0026rsquo;s response. Depending on your setup and settings, you will have to try HTTP or HTTPS. Some ingress controllers enable SSL redirect by default and hence the HTTPS URL has to be accessed.\n$ curl -k https://35.200.150.175/hello Hello, Fission!  Create a FQDN route This is an optional step and pre-requisites should be fulfilled before proceeding. You can map the FQDN to function if you have DNS setup and access. You need to do a few steps:\n Map the domain name\u0026rsquo;s name server to your cloud provider. For example we used domain name fission.sh and mapped the name server to google cloud (Since this tutorial setup is on Google cloud). The instructions are specific to your domain name provider, please check the documentation of the provider.\n Create a zone for the root domain in the cloud provider (Created a zone for fission.sh in google cloud)\n Create a sub-domain A record that maps to the IP address of Ingress Controller load balancer. In this tutorial we created a A record in the zone above for ing.fission.sh and pointed to the IP of ingress controller load balancer i.e. 35.200.150.175 (A records can take 30 minutes to 4 hours to update)\n If all these steps are configured properly, we can hit the function at FQDN like below:\n  $ curl -k https://ing.fission.sh/hello Hello, Fission!  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/canary-deployments/",
	"title": "Supporting Canary Deployments for Fission Functions",
	"tags": [],
	"description": "",
	"content": " This tutorial will walk you through setting up a canary config such that a new version of a function can be deployed in production with minimal risk in a way that it gradually receives user traffic all the way from 0% to 100% eventually.\nSetup \u0026amp; pre-requisites This feature is dependent on Prometheus metrics to check the health of the new version of the function before incrementing the percentage of user traffic to the new version of the function can be incremented at every interval that is configured.\nHence, Prometheus needs to be deployed and is listed as a dependency for fission chart. Issuing a helm dependency update before helm install of fission ensures the prometheus chart is fetched and installed alongside fission.\nCanary Config parameters A Canary Config has the following parameters :\n duration: Specifies how frequently user traffic needs to be incremented for the new version of function\n failurethreshold: Specifies the threshold in percentage beyond which the new version of a function is declared unhealthy\n newfunction: Specifies the name of the latest version of the function\n oldfunction: Specifies the name of the current stable version of the function\n trigger: Specifies the name of the http trigger object\n weightincrement: Specifies the percentage increase of user traffic towards the new version of the function\n failureType: Specifies the parameter for checking the health of the new version of a function. For now, the only supported type is status-code which is the http status code. So if a function returns a status code other than 200, its considered to be unhealthy.\n  For example, let\u0026rsquo;s say the current stable version of a function is fna-v1 and the latest version of a function is fna-v2. Let\u0026rsquo;s suppose we want to increment the traffic towards the new version in steps of 30% every 1m with a failure threshold of 10%. For such a scenario, the sample canary config is given below. What happens is that every 1m, the percentage of failed requests to fna-v2 gets calculated from prometheus metrics. If it is under the configured failure threshold of 10%, then the percentage traffic to fn-v2 gets incremented by 30% and this cycle repeats until either the failure threshold has reached at which point, the deployment is rolled back or fn-v2 is receiving 100% of the user traffic.\napiVersion: fission.io/v1 kind: CanaryConfig metadata: name: canary-1 namespace: default spec: duration: 1m failureType: status-code failurethreshold: 10 newfunction: fn-a-v2 oldfunction: fn-a-v1 trigger: route-fna weightincrement: 30  Steps to setup a canary config  Create environment for fission function :  $ fission env create --name nodejs --image fission/node-env   Create fission functions :  $ fission fn create --name fna-v1 --code hello.js --env nodejs $ fission fn create --name fna-v2 --code hello2.js --env nodejs   Create an http trigger to these functions :  $ fission route create --name route-fna --function fna-v1 --weight 100 --function fna-v2 --weight 0   Create a canary config :  $ fission canary-config create --name canary-1 --newfunction fna-v2 --oldfunction fna-v1 --httptrigger route-fna --increment-step 30 --increment-interval 1m --failure-threshold 10  Steps to verify the status of a canary deployment $ fission canary-config get --name canary-1  This prints the status of the canary deployment of the new version of the function. The status is \u0026ldquo;Pending\u0026rdquo; if the canary deployment is in progress. The status is \u0026ldquo;Succeeded\u0026rdquo; if the new version of the function is receiving 100% of the user traffic. The status is \u0026ldquo;Failed\u0026rdquo; if the failure threshold reached for the new version of the function and as a result 100% of the traffic gets routed to the old version of the function(rollback). The status is \u0026ldquo;Aborted\u0026rdquo; if there were some failures during the canary deployment.\nNote The scrape_interval for Prometheus server is 1m by default. If the \u0026ldquo;duration\u0026rdquo; parameter needs to be less than 1m, the scrape_interval parameter needs to configured to a much lower value. This can be done by updating the config map for prometheus server. Just updating the config map is enough, prometheus server need not be restarted.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/languages/",
	"title": "Languages",
	"tags": [],
	"description": "",
	"content": " Go  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/tutorial/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": " Enabling Istio on Fission Building Java Functions  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/tutorial/enabling-istio-on-fission/",
	"title": "Enabling Istio on Fission",
	"tags": [],
	"description": "",
	"content": " This is the very first step for fission to integrate with Istio. For those interested in trying to integrate fission with istio, following is the set up tutorial.\nTest Environment  Google Kubernetes Engine: 1.9.2-gke.1  Set Up Create Kubernetes v1.9+ cluster Enable both RBAC \u0026amp; initializer features on kubernetes cluster.\n$ export ZONE=\u0026lt;zone name\u0026gt; $ gcloud container clusters create istio-demo-1 \\ --machine-type=n1-standard-2 \\ --num-nodes=1 \\ --no-enable-legacy-authorization \\ --zone=$ZONE \\ --cluster-version=1.9.2-gke.1  Grant cluster admin permissions Grant admin permission for system:serviceaccount:kube-system:default and current user.\n# for system:serviceaccount:kube-system:default $ kubectl create clusterrolebinding --user system:serviceaccount:kube-system:default kube-system-cluster-admin --clusterrole cluster-admin # for current user $ kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value core/account)  Set up Istio environment For Istio 0.5.1 you can follow the installation tutorial below. Also, you can follow the latest installation guides on Istio official site: Quick Start and Sidecar Injection.\nDownload Istio 0.5.1\n$ export ISTIO_VERSION=0.5.1 $ curl -L https://git.io/getLatestIstio | sh - $ cd istio-0.5.1  Apply istio related YAML files\n$ kubectl apply -f install/kubernetes/istio.yaml  Automatic sidecar injection\n$ kubectl api-versions | grep admissionregistration admissionregistration.k8s.io/v1beta1  Installing the webhook\nDownload the missing files in istio release 0.5.1\n$ wget https://raw.githubusercontent.com/istio/istio/master/install/kubernetes/webhook-create-signed-cert.sh -P install/kubernetes/ $ wget https://raw.githubusercontent.com/istio/istio/master/install/kubernetes/webhook-patch-ca-bundle.sh -P install/kubernetes/ $ chmod +x install/kubernetes/webhook-create-signed-cert.sh install/kubernetes/webhook-patch-ca-bundle.sh  Install the sidecar injection configmap.\n$ ./install/kubernetes/webhook-create-signed-cert.sh \\ --service istio-sidecar-injector \\ --namespace istio-system \\ --secret sidecar-injector-certs $ kubectl apply -f install/kubernetes/istio-sidecar-injector-configmap-release.yaml  Install the sidecar injector\n$ cat install/kubernetes/istio-sidecar-injector.yaml | \\ ./install/kubernetes/webhook-patch-ca-bundle.sh \u0026gt; \\ install/kubernetes/istio-sidecar-injector-with-ca-bundle.yaml $ kubectl apply -f install/kubernetes/istio-sidecar-injector-with-ca-bundle.yaml # Check sidecar injector status $ kubectl -n istio-system get deployment -listio=sidecar-injector NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE istio-sidecar-injector 1 1 1 1 26s  Install fission Set default namespace for helm installation, here we use fission as example namespace.\n$ export FISSION_NAMESPACE=fission  Create namespace \u0026amp; add label for Istio sidecar injection.\n$ kubectl create namespace $FISSION_NAMESPACE $ kubectl label namespace $FISSION_NAMESPACE istio-injection=enabled $ kubectl config set-context $(kubectl config current-context) --namespace=$FISSION_NAMESPACE  Follow the installation guide to install fission with flag enableIstio true.\n$ helm install --namespace $FISSION_NAMESPACE --set enableIstio=true --name istio-demo \u0026lt;chart-fission-all-url\u0026gt;  Create a function Set environment\n$ export FISSION_URL=http://$(kubectl --namespace fission get svc controller -o=jsonpath='{..ip}') $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..ip}')  Let\u0026rsquo;s create a simple function with Node.js.\n# hello.js module.exports = async function(context) { console.log(context.request.headers); return { status: 200, body: \u0026quot;Hello, World!\\n\u0026quot; }; }  Create environment\n$ fission env create --name nodejs --image fission/node-env:latest  Create function\n$ fission fn create --name h1 --env nodejs --code hello.js --method GET  Create route\n$ fission route create --method GET --url /h1 --function h1  Access function\n$ curl http://$FISSION_ROUTER/h1 Hello, World!  Install Istio Add-ons  Prometheus  $ kubectl apply -f istio-0.5.1/install/kubernetes/addons/prometheus.yaml $ kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') 9090:9090  Web Link: http://127.0.0.1:9090/graph\n Grafana  Please install Prometheus first.\n$ kubectl apply -f istio-0.5.1/install/kubernetes/addons/grafana.yaml $ kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=grafana -o jsonpath='{.items[0].metadata.name}') 3000:3000  Web Link: http://127.0.0.1:3000/dashboard/db/istio-dashboard\n Jaegar  $ kubectl apply -n istio-system -f https://raw.githubusercontent.com/jaegertracing/jaeger-kubernetes/master/all-in-one/jaeger-all-in-one-template.yml $ kubectl port-forward -n istio-system $(kubectl get pod -n istio-system -l app=jaeger -o jsonpath='{.items[0].metadata.name}') 16686:16686  Web Link: http://localhost:16686\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/tutorial/java-example/",
	"title": "Building Java Functions",
	"tags": [],
	"description": "",
	"content": " With the JVM environment there is now support to use Java functions in Fission. This tutorial explains about the working and some inner details of the way Java functions work in Fission.\nTo see this Java support in action, we are going to build a simple \u0026ldquo;Hello World\u0026rdquo; function with the JVM environment. This example can also be found in examples directory on GitHub.\nJVM Environment The JVM environment in Fission is based on Spring boot and Spring web frameworks. Spring boot \u0026amp; web is already loaded in JVM and if you are using this dependency, you can mark it at provided scope. The environment loads the function code from JAR file during specialization and then executes it.\nFission contract A function needs to implement the io.fission.Function class and override the call method. The call method receives the RequestEntity and Context as inputs and needs to return ResponseEntity object. Both RequestEntity and ResponseEntity are from org.springframework.http package and provide a fairly high level and rich API to interact with request and response.\nResponseEntity call(RequestEntity req, Context context);  The Context object is a placeholder to interact with the platform and provide information about the platform to the code. This also is a extension mechanism to provide more information to runtime code in future.\nBuilding a function Source code \u0026amp; test The function code responds with \u0026ldquo;Hello World\u0026rdquo; in response body.\npublic class HelloWorld implements Function { @Override public ResponseEntity\u0026lt;?\u0026gt; call(RequestEntity req, Context context) { return ResponseEntity.ok(\u0026quot;Hello World!\u0026quot;); } }  Project \u0026amp; dependencies with Maven First you have to define the the basic information about the function:\n\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;io.fission\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hello-world\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;JAR\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;hello-world\u0026lt;/name\u0026gt;  You will have to add two dependencies which are provided by the function runtime, so both them of scope as provided.\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.fission\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fission-java-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.2-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  One of the key things when packaging the Java function is to package it as a uber/fat JAR so that the class and all other dependencies are packaged with function. For that you can use maven-assembly-plugin:\n\u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;make-assembly\u0026lt;/id\u0026gt; \u0026lt;!-- this is used for inheritance merges --\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;!-- bind to the packaging phase --\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;single\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt;  Lastly since the fission-java-core is currently in the snapshot release, you need to explicitely add the sonatype repository which is where it is published.\n\u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;fission-java-core\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;fission-java-core-snapshot\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://oss.sonatype.org/content/repositories/snapshots/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt;  Building the package For building the source Java code with Maven, you either need Maven and Java installed locally or you can use the build.sh helper script which builds the code inside a docker image which has those dependencies.\n$ docker run -it --rm -v \u0026quot;$(pwd)\u0026quot;:/usr/src/mymaven -w /usr/src/mymaven maven:3.5-jdk-8 mvn clean package  At this stage we assume that build succeeded and you have the JAR file of the function ready.\nDeploying the function First you will need to create an environment. The extract flag is important for Java based applications packaged as JAR file. This flag will ensure that the fetcher won\u0026rsquo;t extract the JAR file into a directory. Currently JVM environment only supports version 2 \u0026amp; above so we specify the environment version as 2\n$ fission env create --name jvm --image fission/jvm-env --version 2 --extract=false  When creating the function we provide the JAR file built in earlier steps and the environment. The entrypoint signifies the fully qualified name of the class which implements the Fission\u0026rsquo;s Function interface.\n$ fission fn create --name hello --deploy target/hello-world-1.0-SNAPSHOT-JAR-with-dependencies.JAR --env jvm --entrypoint io.fission.HelloWorld  Lastly you can create a route and test that the function works!\n$ fission route create --function hello --url /hellon --method GET $ curl $FISSION_ROUTER/hello Hello World!  What\u0026rsquo;s next  More examples can be found in examples directory on GitHub  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/workflows/",
	"title": "Fission Workflows",
	"tags": [],
	"description": "",
	"content": " Prerequisites Fission Workflows requires the following components to be installed on your local machine:\n kubectl helm  Fission Workflows is deployed on top of a Kubernetes cluster. If you don\u0026rsquo;t have a Kubernetes cluster, here\u0026rsquo;s a quick guide to set one up. It also requires a Fission deployment to be present on your Kubernetes cluster. If you do not have a Fission deployment, follow Fission\u0026rsquo;s installation guide.\n(Note that Fission Workflows 0.6.0 requires Fission 0.4.1 or higher, with the NATS component installed!)\nInstalling Fission Workflows Fission Workflows is an add-on to Fission. You can install both Fission and Fission Workflows using helm charts.\nAssuming you have your Kubernetes cluster set up with a functioning deployment of Fission 0.4.1 or higher, run the following commands:\n# If you haven't already, add the Fission charts repo $ helm repo add fission-charts https://fission.github.io/fission-charts/ $ helm repo update # Install Fission Workflows $ helm install --wait -n fission-workflows fission-charts/fission-workflows --version 0.6.0  Creating your first workflow After installing Fission and Workflows, you\u0026rsquo;re all set to run a simple test workflow. With the following code snippet you will be able to deploy and run a small workflow example:\n# Fetch the required files, alternatively you could clone the fission-workflow repo $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.6.0/examples/whales/fortune.sh \u0026gt; fortune.sh $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.6.0/examples/whales/whalesay.sh \u0026gt; whalesay.sh $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.6.0/examples/whales/fortunewhale.wf.yaml \u0026gt; fortunewhale.wf.yaml # # Add binary environment and create two test functions on your Fission setup: # $ fission env create --name binary --image fission/binary-env $ fission function create --name whalesay --env binary --deploy ./whalesay.sh $ fission function create --name fortune --env binary --deploy ./fortune.sh # # Create a workflow that uses those two functions. A workflow is just # a function that uses the \u0026quot;workflow\u0026quot; environment. # $ fission function create --name fortunewhale --env workflow --src ./fortunewhale.wf.yaml # # Map an HTTP GET to your new workflow function: # $ fission route create --method GET --url /fortunewhale --function fortunewhale # # Invoke the workflow with an HTTP request: # $ curl ${FISSION_ROUTER}/fortunewhale  This last command, the invocation of the workflow, should return a whale saying something wise\n ______________________________________ / Anthony's Law of Force: \\ | | \\ Don't force it; get a larger hammer. / -------------------------------------- \\ \\ \\ ## . ## ## ## == ## ## ## ## ## === /\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\\___/ === { / ===- \\______ O __/ \\ \\ __/ \\____\\_______/  So what happened here? Let\u0026rsquo;s see what the workflow consists of (for example by running cat fortunewhale.wf.yaml):\n# This whale shows off a basic workflow that combines both Fission Functions (fortune, whalesay) and internal functions (noop) apiVersion: 1 output: WhaleWithFortune tasks: InternalFuncShowoff: run: noop GenerateFortune: run: fortune requires: - InternalFuncShowoff WhaleWithFortune: run: whalesay inputs: \u0026quot;{$.Tasks.GenerateFortune.Output}\u0026quot; requires: - GenerateFortune  What you see is the YAML-based workflow definition of the fortunewhale workflow. A workflow consists of multiple tasks, which are steps that it needs to complete. Each task has a unique identifier, such as GenerateFortune, a reference to a Fission function in the run field. Optionally, it can contain inputs which allows you to specify inputs to the task, as well as contain requires which allows you to specify which tasks need to complete before this task can start. Finally, at the top you will find the output field, which specifies the task whose output is used as the workflow\u0026rsquo;s output.\nIn this case, the fortunewhale workflow consists of a sequence of 3 tasks:\nInternalFuncShowoff -\u0026gt; GenerateFortune -\u0026gt; WhaleWithFortune  First, it starts with InternalFuncShowoff by running noop, which is an internal function in the workflow engine. Internal functions are run inside of the workflow engine, which makes them run much faster at the cost of expressiveness and scalability. So typically, light-weight functions, such as logic or control flow operations, are good candidates to be used as internal functions. Besides, a minimal set of predefined internal functions, you can define internal function - there is nothing special about them.\nAfter InternalFuncShowff completes, the GenerateFortune task can start as its requires has been fulfilled. It runs the fortune Fission function, which outputs a random piece of wisdom.\nAfter GenerateFortune completes, the WhaleWithFortune task can start. This task uses a javascript expression in its inputs to reference the output of the GenerateFortune task. In the inputs of a task you can reference anything in the workflow, such as outputs, inputs, and task definitions, or just provide a constant value. The workflow engine invokes the whalesay fission function with as input the piece of wisdom, which outputs the ASCI whale that wraps the phrase.\nFinally, with all tasks completed, the workflow engine uses the top-level output field to fetch the output of the WhaleWithFortune and return it to the user. As the workflow engine adheres to the Fission function specification, a Fission workflow is just another Fission Function. This means that you could use this workflow as a function in the run in other workflows.\nWhat\u0026rsquo;s next? To learn more about the Fission Workflows system and its advanced concepts, see the documentation on Github.\nOr, check out the examples for more example workflows.\nIf something went wrong, we\u0026rsquo;d love to help \u0026ndash; please drop by the slack channel and ask for help.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/usage/kafka-trigger-tutorial/",
	"title": "Using Kafka trigger to invoke a Function",
	"tags": [],
	"description": "",
	"content": " This tutorial will demonstrate how to use a Kafka trigger to invoke a function. We\u0026rsquo;ll assume you have Fission and Kubernetes installed with Kafka MQ integration installed. If not, please head over to the install guide.\nYou will also need Kafka setup which is reachable from the Fission Kubernetes cluster. If you want to setup Kafka on the Kubernetes cluster, you can use the information here.\nOverview Before we dive into details, let\u0026rsquo;s walk through overall flow of event and functions involved.\n A Go lang producer function (producerfunc) acts as a producer and drops a message in a Kafka topic named input. Fission kafka trigger activates and invokes another function (consumerfunc) with body of Kafka message. The consumer function (consumerfunc) gets body of message and returns a response. Fission Kafka trigger takes the response of consumer function (consumerfunc) and drops the message in a response topic named output. If there is an error, the message is dropped in error topic named error.  Building the app Producer Function The producer function is a go program which creates a message with timestamp and drops into a topic input. For brevity all values have been hard coded in the code itself.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;time\u0026quot; sarama \u0026quot;github.com/Shopify/sarama\u0026quot; ) // Handler posts a message to Kafka Topic func Handler(w http.ResponseWriter, r *http.Request) { brokers := []string{\u0026quot;broker.kafka.svc.cluster.local:9092\u0026quot;} producerConfig := sarama.NewConfig() producerConfig.Producer.RequiredAcks = sarama.WaitForAll producerConfig.Producer.Retry.Max = 10 producerConfig.Producer.Return.Successes = true producer, err := sarama.NewSyncProducer(brokers, producerConfig) if err != nil { panic(err) } t := time.Now() ts := t.Format(time.RFC3339) message := fmt.Sprintf(\u0026quot;{\\\u0026quot;name\\\u0026quot;: \\\u0026quot;value %s \\\u0026quot;}\u0026quot;, ts) _, _, err = producer.SendMessage(\u0026amp;sarama.ProducerMessage{ Topic: \u0026quot;input\u0026quot;, Value: sarama.StringEncoder(message), }) if err != nil { w.Write([]byte(fmt.Sprintf(\u0026quot;Failed to publish message to topic %s: %v\u0026quot;, \u0026quot;input\u0026quot;, err))) return } w.Write([]byte(\u0026quot;Successfully sent to input\u0026quot;)) }  Since the go program uses sarama library, we need to provide that package for building \u0026amp; running the program. We use glide tool with simple glide.yaml declaration below to download the package.\nimport: - package: github.com/Shopify/sarama  With these two files in a directory, run the command glide install -v. The resulting directory structure will look like below:\n. ├── glide.lock ├── glide.yaml ├── kafka-pub.go └── vendor 1 directory, 3 files  We are now ready to package this code and create a function so that we can execute it later. Following commands will create a environment, package and function. Verify that build for package succeeded before proceeding.\n$ fission env create --name goenv --image fission/go-env --builder fission/go-builder $ zip -qr kafka.zip * $ fission package create --env goenv --src kafka.zip Package 'kafka-zip-tzsu' created $ fission fn create --name producerfunc --env goenv --pkg kafka-zip-tzsu --entrypoint Handler $ fission package info --name kafka-zip-tzsu Name: kafka-zip-tzsu Environment: go-kafka Status: succeeded Build Logs: Building in directory /usr/src/kafka-zip-tzsu-1bicov  Consumer function The consumer function is nodejs function which takes the body of the request, appends a \u0026ldquo;Hello\u0026rdquo; and returns the resulting string.\nmodule.exports = async function (context) { console.log(context.request.body); let obj = context.request.body; return { status: 200, body: \u0026quot;Hello \u0026quot;+ JSON.stringify(obj) }; }  Let\u0026rsquo;s create the environment and function:\n$ fission env create --name nodeenv --image fission/node-env $ fission fn create --name consumerfunc --env nodeenv --code hellokafka.js  Connecting via trigger We have both the functions ready but the connection between them is the missing glue. Let\u0026rsquo;s create a message queue trigger which will invoke the consumerfunc every time there is a message in input topic. The response will be sent to output topic and in case of consumerfunc invocation fails, the error is written to error topic.\n$ fission mqt create --name kafkatest --function consumerfunc --mqtype kafka --topic input --resptopic output --errortopic error  If your Kafka broker is running somewhere else (not at broker.kafka:9092), you will have to provide custom configuration for Kafka broker host while installing fission. You can do that by creating a config file, set the value of kafka.brokers to your broker URL and provide this config file while installing fission through helm using -f flag. You can refer this link to find out more about this config parameter.\nTesting it out Let\u0026rsquo;s invoke the producer function so that the topic input gets some messages and we can see the consumer function in action.\n$ fission fn test --name producerfunc Successfully sent to input  There are a couple of ways you can verify that the consumerfunc is called:\n Check the logs of mqtrigger-kafka pods:  time=\u0026quot;2018-10-29T10:46:12Z\u0026quot; level=info msg=\u0026quot;Calling message handler with value {\u0026quot;name\u0026quot;: \u0026quot;value 2018-10-29T10:46:12Z \u0026quot;}\u0026quot; time=\u0026quot;2018-10-29T10:46:12Z\u0026quot; level=info msg=\u0026quot;Making HTTP request to http://router.fission/fission-function/consumer-func\u0026quot; time=\u0026quot;2018-10-29T10:46:12Z\u0026quot; level=info msg=\u0026quot;Got response Hello {\u0026quot;name\u0026quot;:\u0026quot;value 2018-10-29T10:46:12Z \u0026quot;}\u0026quot;   Install and use a tool such as Pixy in the cluster so that you can check topics and message using a REST client. For example with Pixy and port-forwarding, you can check the response on output topic after decoding the message:  $ curl -X GET 'http://127.0.0.1:5000/topics/output/messages?group=pixy.io' { \u0026quot;key\u0026quot;: null, \u0026quot;value\u0026quot;: \u0026quot;SGVsbG8geyJuYW1lIjoidmFsdWUgMjAxOC0xMC0yOVQxMDo0NjoxMlogIn0=\u0026quot;, \u0026quot;partition\u0026quot;: 0, \u0026quot;offset\u0026quot;: 2 } $ echo \u0026quot;SGVsbG8geyJuYW1lIjoidmFsdWUgMjAxOC0xMC0yOVQxMDo0NjoxMlogIn0=\u0026quot; | base64 -D Hello {\u0026quot;name\u0026quot;:\u0026quot;value 2018-10-29T10:46:12Z \u0026quot;}  Introducing an error Let\u0026rsquo;s introduce an error scenario - instead of consumer function returning a 200, you can return 400 which will cause an error:\nmodule.exports = async function (context) { console.log(context.request.body); let obj = context.request.body; return { status: 400, body: \u0026quot;Hello \u0026quot;+ JSON.stringify(obj) }; }  Update the function with new code and invoke the producer function:\n$ fission fn update --name consumerfunc --code hellokafka.js $ fission fn test --name producerfunc Successfully sent to input  We can verify the message in error topic as we did earlier:\n$ curl -X GET 'http://127.0.0.1:5000/topics/error/messages?group=pixy.io' { \u0026quot;key\u0026quot;: null, \u0026quot;value\u0026quot;: \u0026quot;UmVxdWVzdCByZXR1cm5lZCBmYWlsdXJlOiA0MDA=\u0026quot;, \u0026quot;partition\u0026quot;: 0, \u0026quot;offset\u0026quot;: 4 } $ echo \u0026quot;UmVxdWVzdCByZXR1cm5lZCBmYWlsdXJlOiA0MDA=\u0026quot;| base64 -D Request returned failure: 400  More examples  The Kafka sample available here uses Kafka integration to build a IoT fleet management. It also uses JVM Java environment to create functions.  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/contributing/",
	"title": "Contributing to Fission",
	"tags": [],
	"description": "",
	"content": "You only need to do this if you\u0026rsquo;re making Fission changes; if you\u0026rsquo;re just deploying Fission, use fission.yaml which points to prebuilt images.\n You\u0026rsquo;ll need the go compiler and tools installed, along with the glide dependency management tool. You\u0026rsquo;ll also need docker for building images.\nThe server side is compiled as one binary (\u0026ldquo;fission-bundle\u0026rdquo;) which contains controller, poolmgr and router; it invokes the right one based on command-line arguments.\nTo build fission-bundle: clone this repo to $GOPATH/src/github.com/fission/fission, then from the top level directory (if you want to build the image with the docker inside minikube, you\u0026rsquo;ll need to set the proper environment variables with eval $(minikube docker-env)):\n # Get dependencies $ glide install # Build fission server and an image $ pushd fission-bundle $ ./build.sh  You now need to build the docker image for fission. You can use push.sh and push it to a docker hub account. But it\u0026rsquo;s easiest to use minikube and its built-in docker daemon:\n $ eval $(minikube docker-env) $ docker build -t minikube/fission-bundle .  Next, install fission with this image on your kubernetes cluster using the helm chart:\n $ helm install --set \u0026quot;image=minikube/fission-bundle,pullPolicy=IfNotPresent,analytics=false\u0026quot; charts/fission-all  And if you\u0026rsquo;re changing the CLI too, you can build it with:\n # Build Fission CLI $ cd fission \u0026amp;\u0026amp; go install  "
},
{
	"uri": "https://docs.fission.io/1.0-rc1/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Fission is a project by Platform9 Systems and many contributors. Reach us on Slack or Twitter.\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "/* / / see themes/hugo-theme-docdock/layouts/partials/header.html */\n"
},
{
	"uri": "https://docs.fission.io/1.0-rc1/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.fission.io/1.0-rc1/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]