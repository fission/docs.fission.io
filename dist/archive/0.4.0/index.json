[
{
	"uri": "http://docs.fission.io/0.4.0/compilation/",
	"title": "Compiling Fission",
	"tags": [],
	"description": "",
	"content": "[You only need to do this if you\u0026rsquo;re making Fission changes; if you\u0026rsquo;re just deploying Fission, use fission.yaml which points to prebuilt images.]\nYou\u0026rsquo;ll need the go compiler and tools installed, along with the glide dependency management tool. You\u0026rsquo;ll also need docker for building images.\nThe server side is compiled as one binary (\u0026ldquo;fission-bundle\u0026rdquo;) which contains controller, poolmgr and router; it invokes the right one based on command-line arguments.\nTo build fission-bundle: clone this repo to $GOPATH/src/github.com/fission/fission, then from the top level directory (if you want to build the image with the docker inside minikube, you\u0026rsquo;ll need to set the proper environment variables with eval $(minikube docker-env)):\n # Get dependencies $ glide install # Build fission server and an image $ pushd fission-bundle $ ./build.sh  You now need to build the docker image for fission. You can use push.sh and push it to a docker hub account. But it\u0026rsquo;s easiest to use minikube and its built-in docker daemon:\n $ eval $(minikube docker-env) $ docker build -t minikube/fission-bundle .  Next, install fission with this image on your kubernetes cluster using the helm chart:\n $ helm install --set \u0026quot;image=minikube/fission-bundle,pullPolicy=IfNotPresent,analytics=false\u0026quot; charts/fission-all  And if you\u0026rsquo;re changing the CLI too, you can build it with:\n # Build Fission CLI $ cd fission \u0026amp;\u0026amp; go install  "
},
{
	"uri": "http://docs.fission.io/0.4.0/",
	"title": "Fission",
	"tags": [],
	"description": "",
	"content": " Fission: Serverless Functions for Kubernetes fission.io @fissionio\nFission is a fast serverless framework for Kubernetes with a focus on developer productivity and high performance.\nFission operates on just the code: Docker and Kubernetes are abstracted away under normal operation, though you can use both to extend Fission if you want to.\nFission is extensible to any language; the core is written in Go, and language-specific parts are isolated in something called environments (more below). Fission currently supports NodeJS, Python, Ruby, Go, PHP, Bash, and any Linux executable, with more languages coming soon.\nPerformance: 100msec cold start Fission maintains a pool of \u0026ldquo;warm\u0026rdquo; containers that each contain a small dynamic loader. When a function is first called, i.e. \u0026ldquo;cold-started\u0026rdquo;, a running container is chosen and the function is loaded. This pool is what makes Fission fast: cold-start latencies are typically about 100msec.\nKubernetes is the right place for Serverless We\u0026rsquo;re built on Kubernetes because we think any non-trivial app will use a combination of serverless functions and more conventional microservices, and Kubernetes is a great framework to bring these together seamlessly.\nBuilding on Kubernetes also means that anything you do for operations on your Kubernetes cluster \u0026mdash; such as monitoring or log aggregation \u0026mdash; also helps with ops on your Fission deployment.\nFission Concepts A function is a piece of code that follows the fission function interface.\nAn environment contains the language- and runtime-specific parts of running a function.\nThe following environments are currently available:\n   Environment Image     Binary (for executables or scripts) fission/binary-env   Go fission/go-env   .NET fission/dotnet-env   .NET 2.0 fission/dotnet20-env   NodeJS (Alpine) fission/node-env   NodeJS (Debian) fission/node-env-debian   Perl fission/perl-env   PHP 7 fission/php-env   Python 3 fission/python-env   Ruby fission/ruby-env    You can also extend environments or create entirely new ones if you want. (An environment is essentially just a container with a webserver and dynamic loader.)\nA trigger is something that maps an event to a function; Fission supports HTTP routes as triggers today, with upcoming support for other types of event triggers, such as timers and Kubernetes events.\nUsage # Add the stock NodeJS env to your Fission deployment $ fission env create --name nodejs --image fission/node-env # A javascript one-liner that prints \u0026quot;hello world\u0026quot; $ curl https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js \u0026gt; hello.js # Upload your function code to fission $ fission function create --name hello --env nodejs --code hello.js # Map GET /hello to your new function $ fission route create --method GET --url /hello --function hello # Run the function. This takes about 100msec the first time. $ curl http://$FISSION_ROUTER/hello Hello, world!  See the examples directory for more.\n"
},
{
	"uri": "http://docs.fission.io/0.4.0/prerequisite/",
	"title": "Kubernetes Quick Install",
	"tags": [],
	"description": "",
	"content": " This is a quick guide to help you get started running Kubernetes on your laptop (or on the cloud).\n(This isn\u0026rsquo;t meant as a production Kuberenetes guide; it\u0026rsquo;s merely intended to give you something quickly so you can try Fission on it.)\nMinikube Minikube is the usual way to run Kubernetes on your laptop:\nInstall and start Kubernetes on OSX: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.16.0/minikube-darwin-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Or, install and start Kubernetes on Linux: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.16.0/minikube-linux-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Google Container Engine Alternatively, you can use Google Container Engine\u0026rsquo;s free trial to get a 3-node cluster. Hop over to Google Cloud to set that up.\n"
},
{
	"uri": "http://docs.fission.io/0.4.0/installation/",
	"title": "Installation Guide",
	"tags": [],
	"description": "",
	"content": " Welcome! This guide will get you up and running with Fission on a Kubernetes cluster.\nCluster preliminaries If you don\u0026rsquo;t have a Kubernetes cluster, here\u0026rsquo;s a quick guide to set one up.\nLet\u0026rsquo;s ensure you have the Kubernetes CLI and Helm installed and ready. If you already have helm, skip ahead to the fission install.\nKubernetes CLI Ensure you have the Kubernetes CLI.\nYou can get the Kubernetes CLI for OSX like this:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Or, for Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Ensure you have access to a cluster; use kubectl to check your Kubernetes version:\n$ kubectl version  We need at least Kubernetes 1.6 (older versions may work, but we don\u0026rsquo;t test them).\nHelm Helm is an installer for Kubernetes. If you already use helm, skip to the next section.\nFirst, you\u0026rsquo;ll need the helm CLI:\nOn OS X:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.7.0-darwin-amd64.tar.gz $ tar xzf helm-v2.7.0-darwin-amd64.tar.gz $ mv darwin-amd64/helm /usr/local/bin  On Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.7.0-linux-amd64.tar.gz $ tar xzf helm-v2.7.0-linux-amd64.tar.gz $ mv linux-amd64/helm /usr/local/bin  Next, install the Helm server on your Kubernetes cluster:\n$ helm init  Install Fission Minikube $ helm install --namespace fission --set serviceType=NodePort https://github.com/fission/fission/releases/download/0.4.1/fission-all-0.4.1.tgz  The serviceType variable allows configuring the type of Kubernetes service outside the cluster. You can use ClusterIP if you don\u0026rsquo;t want to expose anything outside the cluster.\nCloud hosted clusters (GKE, AWS, Azure etc.) $ helm install --namespace fission https://github.com/fission/fission/releases/download/0.4.1/fission-all-0.4.1.tgz  Minimal version The fission-all helm chart installs a full set of services including the NATS message queue, influxDB for logs, etc. If you want a more minimal setup, you can install the fission-core chart instead:\n$ helm install --namespace fission https://github.com/fission/fission/releases/download/0.4.1/fission-core-0.4.1.tgz  Install the Fission CLI OS X Get the CLI binary for Mac:\n$ curl -Lo fission https://github.com/fission/fission/releases/download/0.4.1/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.4.1/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nSet environment vars Set the FISSION_URL and FISSION_ROUTER environment variables. FISSION_URL is used by the fission CLI to find the server. (FISSION_ROUTER is only needed for the examples below to work.)\nMinikube If you\u0026rsquo;re using minikube, use these commands:\n $ export FISSION_URL=http://$(minikube ip):31313 $ export FISSION_ROUTER=$(minikube ip):31314  Cloud setups Save the external IP addresses of controller and router services in FISSION_URL and FISSION_ROUTER, respectively. Wait for services to get IP addresses (check this with kubectl --namespace fission get svc). Then:\nAWS  $ export FISSION_URL=http://$(kubectl --namespace fission get svc controller -o=jsonpath='{..hostname}') $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..hostname}')  GCP  $ export FISSION_URL=http://$(kubectl --namespace fission get svc controller -o=jsonpath='{..ip}') $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..ip}')  Run an example Finally, you\u0026rsquo;re ready to use Fission!\n$ fission env create --name nodejs --image fission/node-env:0.4.1 $ curl -LO https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js $ fission function create --name hello --env nodejs --code hello.js $ fission route create --method GET --url /hello --function hello $ curl http://$FISSION_ROUTER/hello Hello, world!  What\u0026rsquo;s next? If something went wrong, we\u0026rsquo;d love to help \u0026ndash; please drop by the slack channel and ask for help.\nCheck out the examples for some example functions.\n"
},
{
	"uri": "http://docs.fission.io/0.4.0/upgrade/",
	"title": "Upgrade",
	"tags": [],
	"description": "",
	"content": " From v0.1 to v0.2.x  Upgade guide  From v0.3 to v0.4.x  Upgrade guide  "
},
{
	"uri": "http://docs.fission.io/0.4.0/upgrade/upgrade-from-v0.1/",
	"title": "Upgrading from v0.1 to v0.2.x",
	"tags": [],
	"description": "",
	"content": " TL;DR The Fission API has changed significantly in this version. The new API is incompatible with the old one. The CLI is compatible; if you wrote scripts using it, those should still work.\nBelow we describe a tool for migrating your state from your old install to the new one.\nWhile this upgrade is going to be disruptive, we\u0026rsquo;re going to do our best to make sure future upgrades aren\u0026rsquo;t as bad.\nWhy is this so complicated? For a couple of reasons, we wanted to switch to using Kubernetes resources (ThirdPartyResources now, CustomResources in the next release) for storing Fission state: (a) it would allow users to avoid management of another database and (b) Fission would fit better into the Kubernetes ecosystem.\nConcurrently with this change, we were also trying to make our versioning approach less opinionated, so it would work with other tools.\nThirdly, we were also enabling build pipelines (v2 Environments).\nThese changes, especially the difference in versioning approach, made maintaining compatiblity not worth the effort at this early stage of the project.\nAll that said, we want you to know that we care a lot about compatiblity, and we\u0026rsquo;ll be more rigorous about it from the beta release onwards.\nHow to Upgrade  Get the v0.2.1 CLI Get the Fission state from your old install Install Fission v0.2.1 Restore Fission state into your new install Destroy your old install  Get the new CLI OS X $ curl -Lo fission https://github.com/fission/fission/releases/download/v0.2.1-rc/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/v0.2.1-rc/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nGet Fission state from v0.1 install fission --server \u0026lt;your V1 server\u0026gt; upgrade dump --file state.json  You can skip the \u0026ndash;server argument if you have the environment variable $FISSION_URL set to point at a v0.1 Fission server.\nThis will create a JSON file with all your fission state in the current directory.\nInstall the new version Read the install guide. You can follow all of it, except that you will need to ensure your two installs don\u0026rsquo;t conflict. To do that, use separate namespaces and ensure nodeports don\u0026rsquo;t conflict. Install with a command similar to this:\nhelm install fission-all --namespace fission2 --set controllerPort=31303,routerPort=31304,natsStreamingPort=31305,functionNamespace=fission2-function  This installs fission in the fission2 namespace and runs functions in the fission2-function namespace.\nRestore your Fission state into Fission v0.2.1 fission upgrade restore --file state.json  This commands needs $FISSION_URL set to point to new fission installation.\nIt uses the file created in the first step. It doesn\u0026rsquo;t modify state.json.\n(Note that you can run this restore on any cluster; it doesn\u0026rsquo;t have the be the same kubernetes cluster as your old install.)\nVerify How exactly you do this is up to you! But, at a minimum, run fission fn list to check that all the functions you expect are there.\nSwitch over If you had exposed fission\u0026rsquo;s router to the outside world, switch over to using the new install\u0026rsquo;s router.\nDestroy your old install Once you\u0026rsquo;re no longer using the old install, you can destroy it by deleting the namespaces that was installed in.\nkubectl delete namespace fission fission-function  "
},
{
	"uri": "http://docs.fission.io/0.4.0/upgrade/upgrade-from-v0.3/",
	"title": "Upgrading from v0.3 to v0.4.x",
	"tags": [],
	"description": "",
	"content": " Introduction Kubernetes ThirdPartyResources (\u0026ldquo;TPR\u0026rdquo;) are replaced by CustomResourceDefinitions (\u0026ldquo;CRD\u0026rdquo;). TPRs have been deprecated and are removed in Kubernetes 1.8.\nSince Fission stores state in TPRs, we need to migrate this state from TPRs to CRDs while upgrading.\nFollow the instructions below if you\u0026rsquo;re upgrading a Fission 0.2.1 or 0.3.0 cluster to 0.4. If you\u0026rsquo;re using a pre-0.2 Fission cluster, use the [upgrade guide from 0.1 to 0.2]() and then upgrade to 0.4.0.\nHow to Upgrade  Get the 0.4.0 CLI Get the Fission state from v0.3 install Upgrade to Fission 0.4.0 Upgrade Kubernetes cluster version to 1.7.x or higher Remove all TPR definition (for Kubernetes 1.7.x) Restore Fission state into CRDs  Get the new CLI OS X $ curl -Lo fission https://github.com/fission/fission/releases/download/0.4.0/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.4.0/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nGet Fission state from v0.3 install fission --server \u0026lt;your v0.3 server\u0026gt; tpr2crd dump --file state.json  You can skip the \u0026ndash;server argument if you have the environment variable $FISSION_URL set to point at a v0.3 Fission server.\nThis will create a JSON file with all your fission state in the current directory.\nUpgrade to Fission 0.4.0 Upgrade fission with a command similar to this:\nhelm upgrade fission-all --namespace fission  Upgrade Kubernetes cluster version Since CustomResource is only supported on Kubernetes v1.7+ and higher, please make sure that you upgrade to the right version that supports CustomResource.\nRemove all TPR definition (for Kubernetes 1.7.x) ** NOTICE **: This step will remove TPR definition from your kubernetes cluster. Please make sure that you dump all TPRs at the second step!\nThough Kubernetes will migrate TPRs to CRDs automatically when TPR definition is deleted if the same name CRD exists. We still need to make sure that there is no resource gets lost during the migration. Also, since we changed the capitalization of some CRDs to CamelCase (e.g. Httptrigger -\u0026gt; HTTPTrigger), we need to recreate those resources by ourselves.\nfission tpr2crd delete  Restore your Fission state into Fission 0.4.0 fission tpr2crd restore --file state.json  This commands needs $FISSION_URL set to point to new fission installation.\nIt uses the file created in the first step. It doesn\u0026rsquo;t modify state.json.\n(Note that you can run this restore on any cluster; it doesn\u0026rsquo;t have the be the same kubernetes cluster as your old install.)\nVerify Let\u0026rsquo;s check the migration result, first run following command to check CRD established state.\nkubectl get crd -o 'custom-columns=NAME:{.metadata.name},ESTABLISHED:{.status.conditions[?(@.type==\u0026quot;Established\u0026quot;)].status}'  The output should be like this\nNAME ESTABLISHED environments.fission.io True functions.fission.io True httptriggers.fission.io True kuberneteswatchtriggers.fission.io True messagequeuetriggers.fission.io True packages.fission.io True timetriggers.fission.io True  And check that CRD resources you expect are there.\nCOMMAND: fission [resource] list RESOURCES: environments functions httptriggers kuberneteswatchtriggers messagequeuetriggers packages timetriggers  "
},
{
	"uri": "http://docs.fission.io/0.4.0/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://docs.fission.io/0.4.0/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://docs.fission.io/0.4.0/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]