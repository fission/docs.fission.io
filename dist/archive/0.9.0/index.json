[
{
	"uri": "https://docs.fission.io/0.9.0/",
	"title": "Fission",
	"tags": [],
	"description": "",
	"content": " Fission: Serverless Functions for Kubernetes fission.io @fissionio\nFission is a fast serverless framework for Kubernetes with a focus on developer productivity and high performance.\nFission operates on just the code: Docker and Kubernetes are abstracted away under normal operation, though you can use both to extend Fission if you want to.\nFission is extensible to any language; the core is written in Go, and language-specific parts are isolated in something called environments (more below). Fission currently supports NodeJS, Python, Ruby, Go, PHP, Bash, and any Linux executable, with more languages coming soon.\nPerformance: 100msec cold start Fission maintains a pool of \u0026ldquo;warm\u0026rdquo; containers that each contain a small dynamic loader. When a function is first called, i.e. \u0026ldquo;cold-started\u0026rdquo;, a running container is chosen and the function is loaded. This pool is what makes Fission fast: cold-start latencies are typically about 100msec.\nKubernetes is the right place for Serverless We\u0026rsquo;re built on Kubernetes because we think any non-trivial app will use a combination of serverless functions and more conventional microservices, and Kubernetes is a great framework to bring these together seamlessly.\nBuilding on Kubernetes also means that anything you do for operations on your Kubernetes cluster \u0026mdash; such as monitoring or log aggregation \u0026mdash; also helps with ops on your Fission deployment.\nFission Concepts A function is a piece of code that follows the fission function interface.\nAn environment contains the language- and runtime-specific parts of running a function.\nThe following environments are currently available:\n   Environment Image     Binary (for executables or scripts) fission/binary-env   Go fission/go-env   .NET fission/dotnet-env   .NET 2.0 fission/dotnet20-env   NodeJS (Alpine) fission/node-env   NodeJS (Debian) fission/node-env-debian   Perl fission/perl-env   PHP 7 fission/php-env   Python 3 fission/python-env   Ruby fission/ruby-env    You can also extend environments or create entirely new ones if you want. (An environment is essentially just a container with a webserver and dynamic loader.)\nA trigger is something that maps an event to a function; Fission supports HTTP routes as triggers today, with upcoming support for other types of event triggers, such as timers and Kubernetes events.\nUsage # Add the stock NodeJS env to your Fission deployment $ fission env create --name nodejs --image fission/node-env # A javascript one-liner that prints \u0026quot;hello world\u0026quot; $ curl https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js \u0026gt; hello.js # Upload your function code to fission $ fission function create --name hello --env nodejs --code hello.js # Map GET /hello to your new function $ fission route create --method GET --url /hello --function hello # Run the function. This takes about 100msec the first time. $ fission function test --name hello Hello, world!  See the examples directory for more.\n"
},
{
	"uri": "https://docs.fission.io/0.9.0/installation/",
	"title": "Installation Guide",
	"tags": [],
	"description": "",
	"content": " Installation Installing and upgrading Fission "
},
{
	"uri": "https://docs.fission.io/0.9.0/installation/installation/",
	"title": "Installation Guide",
	"tags": [],
	"description": "",
	"content": " Welcome! This guide will get you up and running with Fission on a Kubernetes cluster.\nCluster preliminaries If you don\u0026rsquo;t have a Kubernetes cluster, here\u0026rsquo;s a quick guide to set one up.\nLet\u0026rsquo;s ensure you have the Kubernetes CLI and Helm installed and ready. If you already have helm, skip ahead to the fission install.\nKubernetes CLI Ensure you have the Kubernetes CLI.\nYou can get the Kubernetes CLI for OSX like this:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Or, for Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Ensure you have access to a cluster; use kubectl to check your Kubernetes version:\n$ kubectl version  We need at least Kubernetes 1.6 (older versions may work, but we don\u0026rsquo;t test them).\nHelm Helm is an installer for Kubernetes. If you already use helm, skip to the next section.\nFirst, you\u0026rsquo;ll need the helm CLI:\nOn OS X:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.7.0-darwin-amd64.tar.gz $ tar xzf helm-v2.7.0-darwin-amd64.tar.gz $ mv darwin-amd64/helm /usr/local/bin  On Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.7.0-linux-amd64.tar.gz $ tar xzf helm-v2.7.0-linux-amd64.tar.gz $ mv linux-amd64/helm /usr/local/bin  Next, install the Helm server on your Kubernetes cluster:\nOn Google Kubernetes Engine (GKE):\nTo avoid RBAC related issues on GKE use the following steps to install helm using a dedicated service account.\n$ kubectl create serviceaccount --namespace kube-system tiller $ kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller $ helm init --service-account tiller --upgrade  On Other Kubernetes installations:\n$ helm init  Install Fission Minikube Since minikube 0.26.0 the default bootstrapper is kubeadm which enables RBAC by default. For those who work on versions before 0.26.0, please follow the steps below to enable RBAC.\n# For minikube before version 0.26.0 $ minikube start --extra-config=apiserver.Authorization.Mode=RBAC  Then, you should see the cluster role cluster-admin.\n$ kubectl get clusterroles cluster-admin NAME AGE cluster-admin 44d  Install fission with helm\n$ helm install --namespace fission --set serviceType=NodePort,routerServiceType=NodePort https://github.com/fission/fission/releases/download/0.9.0/fission-all-0.9.0.tgz  The serviceType variable allows configuring the type of Kubernetes service outside the cluster. You can use ClusterIP if you don\u0026rsquo;t want to expose anything outside the cluster.\nCloud hosted clusters (GKE, AWS, Azure etc.) $ helm install --namespace fission https://github.com/fission/fission/releases/download/0.9.0/fission-all-0.9.0.tgz  Minimal version The fission-all helm chart installs a full set of services including the NATS message queue, influxDB for logs, etc. If you want a more minimal setup, you can install the fission-core chart instead:\n$ helm install --namespace fission https://github.com/fission/fission/releases/download/0.9.0/fission-core-0.9.0.tgz  Install the Fission CLI OS X Get the CLI binary for Mac:\n$ curl -Lo fission https://github.com/fission/fission/releases/download/0.9.0/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.9.0/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nRun an example Finally, you\u0026rsquo;re ready to use Fission!\n$ fission env create --name nodejs --image fission/node-env:0.9.0 $ curl -LO https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js $ fission function create --name hello --env nodejs --code hello.js $ fission function test --name hello Hello, world!  For a compiled language like Go:\n$ fission env create --name go --image fission/go-env:0.9.0 --builder fission/go-builder:0.9.0 $ curl -LO https://raw.githubusercontent.com/fission/fission/master/examples/go/hello.go $ fission function create --name gohello --env go --src hello.go --entrypoint Handler $ fission function test --name gohello Hello, world!  What\u0026rsquo;s next? If something went wrong, we\u0026rsquo;d love to help \u0026ndash; please drop by the slack channel and ask for help.\nCheck out the examples for some example functions.\n"
},
{
	"uri": "https://docs.fission.io/0.9.0/installation/kubernetessetup/",
	"title": "Kubernetes Quick Install",
	"tags": [],
	"description": "",
	"content": " This is a quick guide to help you get started running Kubernetes on your laptop (or on the cloud).\n(This isn\u0026rsquo;t meant as a production Kuberenetes guide; it\u0026rsquo;s merely intended to give you something quickly so you can try Fission on it.)\nMinikube Minikube is the usual way to run Kubernetes on your laptop:\nInstall and start Kubernetes on OSX: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.26.1/minikube-darwin-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Or, install and start Kubernetes on Linux: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.26.1/minikube-linux-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Google Container Engine Alternatively, you can use Google Container Engine\u0026rsquo;s free trial to get a 3-node cluster. Hop over to Google Cloud to set that up.\n"
},
{
	"uri": "https://docs.fission.io/0.9.0/installation/releasenotes/",
	"title": "Release notes",
	"tags": [],
	"description": "",
	"content": "  The fission team is on http://slack.fission.io if you have any questions.  0.4.0  This release is compatible with Kubernetes 1.7 onwards. We switched from ThirdPartyResources to CustomResourceDefinitions. ThirdPartyResources are removed in Kubernetes 1.8, so upgrade with caution, using the upgrade guide below. Upgrade guides:  Upgrade guide from 0.3.0 To upgrade from 0.2.1, please upgrade to 0.3.0 first, following the upgrade guide in the 0.3.0 release.   0.3.0 Note: This release is incompatible with Kubernetes 1.8 (Because it uses ThirdPartyResources; see #314)\nThis release introduces:\n Build pipeline. Currently, only the Python environment supports this. Workflow engine support (compatible with fission-workflows 0.1.1)  v0.2.1 Lots of big changes in this release!\n Most importantly, the API has changed a lot. We switched to Kubernetes ThirdPartyResources, and improved various pieces of the API to support new environments.\n The old API was too different from widely used Kubernetes patterns, and so we decided to fully break compatibility for this release. We\u0026rsquo;re still in alpha, so you should expect the occasional API breakage; we\u0026rsquo;ll be better at preserving compatibility once we reach beta.\n The CLI is still compatible. Environments are also still compatible \u0026ndash; environment images that worked before continue to work.\n We\u0026rsquo;re creating an upgrade tool to help migrate; if you\u0026rsquo;re upgrading v0.1.0 and can\u0026rsquo;t do a fresh install, wait for the upgrade tool.\n We now use Helm for installation instead of a set of YAML files.\n The Fission \u0026ldquo;controller\u0026rdquo; is now stateless. Fission\u0026rsquo;s etcd deployment is removed, since Fission stores state in ThirdPartyResources. Large function files are stored in a new function storage service, which uses a persistent volume.\n And, we\u0026rsquo;ve started a new docs site; for now it\u0026rsquo;s just the installation and upgrade guides, but we\u0026rsquo;ll be writing more docs soon.\n  "
},
{
	"uri": "https://docs.fission.io/0.9.0/concepts/",
	"title": "Fission Concepts",
	"tags": [],
	"description": "",
	"content": " Fission Concepts This is an overview of the few main concepts in Fission: Functions, Environments, and Triggers.\n"
},
{
	"uri": "https://docs.fission.io/0.9.0/installation/upgrade/",
	"title": "Upgrade",
	"tags": [],
	"description": "",
	"content": " From v0.4.x to v0.5.0  Upgrade guide  From v0.3 to v0.4.x  Upgrade guide  From v0.1 to v0.2.x  Upgrade guide  "
},
{
	"uri": "https://docs.fission.io/0.9.0/installation/upgrade/upgrade-from-v0.1/",
	"title": "Upgrading from v0.1 to v0.2.x",
	"tags": [],
	"description": "",
	"content": " TL;DR The Fission API has changed significantly in this version. The new API is incompatible with the old one. The CLI is compatible; if you wrote scripts using it, those should still work.\nBelow we describe a tool for migrating your state from your old install to the new one.\nWhile this upgrade is going to be disruptive, we\u0026rsquo;re going to do our best to make sure future upgrades aren\u0026rsquo;t as bad.\nWhy is this so complicated? For a couple of reasons, we wanted to switch to using Kubernetes resources (ThirdPartyResources now, CustomResources in the next release) for storing Fission state: (a) it would allow users to avoid management of another database and (b) Fission would fit better into the Kubernetes ecosystem.\nConcurrently with this change, we were also trying to make our versioning approach less opinionated, so it would work with other tools.\nThirdly, we were also enabling build pipelines (v2 Environments).\nThese changes, especially the difference in versioning approach, made maintaining compatiblity not worth the effort at this early stage of the project.\nAll that said, we want you to know that we care a lot about compatiblity, and we\u0026rsquo;ll be more rigorous about it from the beta release onwards.\nHow to Upgrade  Get the v0.2.1 CLI Get the Fission state from your old install Install Fission v0.2.1 Restore Fission state into your new install Destroy your old install  Get the new CLI OS X $ curl -Lo fission https://github.com/fission/fission/releases/download/v0.2.1-rc/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/v0.2.1-rc/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nGet Fission state from v0.1 install fission --server \u0026lt;your V1 server\u0026gt; upgrade dump --file state.json  You can skip the \u0026ndash;server argument if you have the environment variable $FISSION_URL set to point at a v0.1 Fission server.\nThis will create a JSON file with all your fission state in the current directory.\nInstall the new version Read the install guide. You can follow all of it, except that you will need to ensure your two installs don\u0026rsquo;t conflict. To do that, use separate namespaces and ensure nodeports don\u0026rsquo;t conflict. Install with a command similar to this:\nhelm install fission-all --namespace fission2 --set controllerPort=31303,routerPort=31304,natsStreamingPort=31305,functionNamespace=fission2-function  This installs fission in the fission2 namespace and runs functions in the fission2-function namespace.\nRestore your Fission state into Fission v0.2.1 fission upgrade restore --file state.json  This commands needs $FISSION_URL set to point to new fission installation.\nIt uses the file created in the first step. It doesn\u0026rsquo;t modify state.json.\n(Note that you can run this restore on any cluster; it doesn\u0026rsquo;t have the be the same kubernetes cluster as your old install.)\nVerify How exactly you do this is up to you! But, at a minimum, run fission fn list to check that all the functions you expect are there.\nSwitch over If you had exposed fission\u0026rsquo;s router to the outside world, switch over to using the new install\u0026rsquo;s router.\nDestroy your old install Once you\u0026rsquo;re no longer using the old install, you can destroy it by deleting the namespaces that was installed in.\nkubectl delete namespace fission fission-function  "
},
{
	"uri": "https://docs.fission.io/0.9.0/concepts/environments/",
	"title": "Environments",
	"tags": [],
	"description": "",
	"content": "An environment contains the language and runtime specific parts of a function. An environment is essentially a container with a webserver and a dynamic loader for the function code.\nThe following pre-built environments are currently available for use in Fission:\n   Environment Image     Binary (for executables or scripts) fission/binary-env   Go fission/go-env   .NET fission/dotnet-env   .NET 2.0 fission/dotnet20-env   NodeJS (Alpine) fission/node-env   NodeJS (Debian) fission/node-env-debian   Perl fission/perl-env   PHP 7 fission/php-env   Python 3 fission/python-env   Ruby fission/ruby-env    To create custom environments you can extend one of the environments in the list or create your own environment from scratch.\n"
},
{
	"uri": "https://docs.fission.io/0.9.0/installation/upgrade/upgrade-from-v0.3/",
	"title": "Upgrading from v0.3 to v0.4.x",
	"tags": [],
	"description": "",
	"content": " Introduction Kubernetes ThirdPartyResources (\u0026ldquo;TPR\u0026rdquo;) are replaced by CustomResourceDefinitions (\u0026ldquo;CRD\u0026rdquo;). TPRs have been deprecated and are removed in Kubernetes 1.8.\nSince Fission stores state in TPRs, we need to migrate this state from TPRs to CRDs while upgrading.\nFollow the instructions below if you\u0026rsquo;re upgrading a Fission 0.2.1 or 0.3.0 cluster to 0.4. If you\u0026rsquo;re using a pre-0.2 Fission cluster, use the [upgrade guide from 0.1 to 0.2]() and then upgrade to 0.4.0.\nHow to Upgrade  Get the 0.4.0 CLI Get the Fission state from v0.3 install Upgrade to Fission 0.4.0 Upgrade Kubernetes cluster version to 1.7.x or higher Remove all TPR definition (for Kubernetes 1.7.x) Restore Fission state into CRDs  Get the new CLI OS X $ curl -Lo fission https://github.com/fission/fission/releases/download/0.4.0/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.4.0/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nGet Fission state from v0.3 install fission --server \u0026lt;your v0.3 server\u0026gt; tpr2crd dump --file state.json  You can skip the \u0026ndash;server argument if you have the environment variable $FISSION_URL set to point at a v0.3 Fission server.\nThis will create a JSON file with all your fission state in the current directory.\nUpgrade to Fission 0.4.0 Upgrade fission with a command similar to this:\nhelm upgrade fission-all --namespace fission  Upgrade Kubernetes cluster version Since CustomResource is only supported on Kubernetes v1.7+ and higher, please make sure that you upgrade to the right version that supports CustomResource.\nRemove all TPR definition (for Kubernetes 1.7.x) ** NOTICE **: This step will remove TPR definition from your kubernetes cluster. Please make sure that you dump all TPRs at the second step!\nThough Kubernetes will migrate TPRs to CRDs automatically when TPR definition is deleted if the same name CRD exists. We still need to make sure that there is no resource gets lost during the migration. Also, since we changed the capitalization of some CRDs to CamelCase (e.g. Httptrigger -\u0026gt; HTTPTrigger), we need to recreate those resources by ourselves.\nfission tpr2crd delete  Restore your Fission state into Fission 0.4.0 fission tpr2crd restore --file state.json  This commands needs $FISSION_URL set to point to new fission installation.\nIt uses the file created in the first step. It doesn\u0026rsquo;t modify state.json.\n(Note that you can run this restore on any cluster; it doesn\u0026rsquo;t have the be the same kubernetes cluster as your old install.)\nVerify Let\u0026rsquo;s check the migration result, first run following command to check CRD established state.\nkubectl get crd -o 'custom-columns=NAME:{.metadata.name},ESTABLISHED:{.status.conditions[?(@.type==\u0026quot;Established\u0026quot;)].status}'  The output should be like this\nNAME ESTABLISHED environments.fission.io True functions.fission.io True httptriggers.fission.io True kuberneteswatchtriggers.fission.io True messagequeuetriggers.fission.io True packages.fission.io True timetriggers.fission.io True  And check that CRD resources you expect are there.\nCOMMAND: fission [resource] list RESOURCES: environments functions httptriggers kuberneteswatchtriggers messagequeuetriggers packages timetriggers  "
},
{
	"uri": "https://docs.fission.io/0.9.0/concepts/executor/",
	"title": "Controlling Function Execution",
	"tags": [],
	"description": "",
	"content": " Executors When you create a function, you can specify an executor for a function. An executor controls how function pods are created and what capabilities are available for that executor type.\nPool-based executor A pool based executor (Refered to as poolmgr) creates a pool of generic environment pods as soon as you create an environment. The pool size of initial \u0026ldquo;warm\u0026rdquo; containers can be configured based on user needs. These warm containers contain a small dynamic loader for loading the function. Resource requirements are specified at environment level and are inherited by specialized function pods.\nOnce you create a function and invoke it, one of pods from the pool is taken out and \u0026ldquo;specialized\u0026rdquo; and used for execution. This pod is used for subseqnent requests for that function. If there are no more requests for a certain idle duration, then this pod is cleaned up. If a new requests come after the earlier specialized pod was cleaned up, then a new pod is specialised from the pool and used for execution.\nPoolmgr executortype is great for functions where lower latency is a requirement. Poolmgr executortype has certain limitations: for example, you can not autoscale them based on demand.\nNew-deployment executor New-Deployment executor (Newdeploy) creates a Kubernetes Deployment along with a Service and HorizontalPodAutoscaler for function execution. This enables autoscaling of function pods and load balancing the requests between pods. In future additional capabilities will be added for newdeploy executortype such as support for volume etc. In the new-deploy executor, resource requirements can be specified at the function level. These requirements override those specified in the environment.\nNewdeploy executortype can be used for requests with no particular low-latency requirements, such as those invoked asynchronously, minscale can be set to zero. In this case the Kubernetes deployment and other objects will be created on first invocation of the function. Subsequent requests can be served by the same deployment. If there are no requests for certain duration then the idle objects are cleaned up. This mechanism ensures resource consumption only on demand and is a good fit for asynchronous requests.\nFor requests where latency requirements are stringent, a minscale greater than zero can be set. This essentially keeps a minscale number of pods ready when you create a function. When the function is invoked, there is no delay since the pod is already created. Also minscale ensures that the pods are not cleaned up even if the function is idle. This is great for functions where lower latency is more important than saving resource consumption when functions are idle.\nThe latency vs. idle-cost tradeoff The executors allow you as a user to decide between latency and a small idle cost tradeoff. Depending on the need you can choose one of the combinations which is optimal for your use case. In future, a more intelligent dispatch mechanism will enable more complex combinations of executors.\n   Executor Type Min Scale Latency Idle cost     Newdeploy 0 High Very low - pods get cleaned up after idlle time   Newdeploy \u0026gt;0 Low Medium, Min Scale number of pods are always up   Poolmgr 0 Low Low, pool of pods are always up    Autoscaling The new deployment based executor provides autoscaling for functions based on CPU usage. In future custom metrics will be also supported for scaling the functions. You can set the intial and maximum CPU for a function and target CPU at which autoscaling will be trigerred. Autoscaling is useful for workloads where you expect intermittant spikes in workloads. It also enables optimal usage of resources to execute functions, by using a baseline capacity with minimum scale and ability to burst up to maximum scale based on spikes in demand.\n"
},
{
	"uri": "https://docs.fission.io/0.9.0/installation/upgrade/upgrade-from-v0.4/",
	"title": "Upgrading from v0.4.x to v0.5.0",
	"tags": [],
	"description": "",
	"content": " How to Upgrade  Get the 0.5.0 CLI Upgrade to Fission 0.5.0  Get the new CLI OS X $ curl -Lo fission https://github.com/fission/fission/releases/download/0.5.0/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.5.0/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nUpgrade to Fission 0.5.0 Upgrade fission with a command similar to this:\n# find the release want to upgrade $ helm list # upgrade to 0.5.0 $ helm upgrade \u0026lt;release_name\u0026gt; https://github.com/fission/fission/releases/download/0.5.0/fission-all-0.5.0.tgz  "
},
{
	"uri": "https://docs.fission.io/0.9.0/concepts/trigger/",
	"title": "Trigger",
	"tags": [],
	"description": "",
	"content": " Triggers are events that can invoke a function. Fission has three kinds of triggers that can be used to invoke functions.\nHttp Trigger HTTP triggers enable calling functions with HTTP requests. Supported methods are GET, POST, PUT, DELETE, HEAD and by default GET is used. URL pattern follow the gorilla/mux supported patterns.\nHTTP trigger also supports creation of ingress for a HTTP trigger. The ingress can be used to give the function an externally-reachable URL, terminate SSL, load balance traffic etc.\nTime Trigger If you want a function to be called at a periodic frequency then the time triggers are perfect for the use case. Time triggers follow cron like specifications and are invoked based on the cron schedule.\nTime trigger based invocations are great for running scheduled jobs, periodic cleanup jobs, periodic polling based invocations etc.\nMQ Trigger Message queue based trigger enables ability to listen on a topic and invoke a function for each message. You can optionally send a response to another topic. By default it is assumed that the messages in queue are in application/json format but you can specify otherwise while creating the trigger. Currently, nats-streaming and azure-storage-queue are supported message queues.\nMQ triggers are great for integrating various systems in a decoupled and asynchronous manner.\n"
},
{
	"uri": "https://docs.fission.io/0.9.0/concepts/package/",
	"title": "Builder and Packages",
	"tags": [],
	"description": "",
	"content": "Most real world applications are more than a single file of code and typically have dependencies on libraries etc. Packages in fission solve three distinct problems:\n1) Enable a mechanism to store more than one file as a single unit and use them with functions. This is done through a combination of deployment archive builder environment associated with the environment.\n2) Provide a mechanism to build from source code and dependencies into a binary based on a build command and store it as an object. User should be able to use this built artifact with a function. This is achieved with a source archive and a builder environment.\n3) Decouple the execution logic from the functions and thus enable reuse of same logic for multiple functions. This will enable user to run same logic with different functions having different runtime charateristics and executor types.\nWhen you create a function with a single source file, fission internally creates a package and links it to a function. Creating a package explicitly gives more flexibility in some use cases as explained above.\n"
},
{
	"uri": "https://docs.fission.io/0.9.0/usage/",
	"title": "Using Fission",
	"tags": [],
	"description": "",
	"content": " Using Fission Usage guides, tutorials and examples "
},
{
	"uri": "https://docs.fission.io/0.9.0/usage/functions/",
	"title": "Function",
	"tags": [],
	"description": "",
	"content": " Create a function Before creating a function the environment should be created, we will assume that you have already created environment named node.\nLet\u0026rsquo;s create a simple code snippet in nodejs which will output Hello world:\nmodule.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, world!\\n\u0026quot; }; }  Let\u0026rsquo;s create a route for the function which can be used for making HTTP requests:\n$ fission route create --function hello --url /hello trigger '5327e9a7-6d87-4533-a4fb-c67f55b1e492' created  Let\u0026rsquo;s create a function based on pool based executor.\n$ fission fn create --name hello --code hello.js --env node --executortype poolmgr  When you hit this function\u0026rsquo;s URL , you get a response:\n$ curl http://$FISSION_ROUTER/hello Hello, world!  Similarly you can create a new deployment executor type function and provide minmum and maximum scale for the function.\n$ fission fn create --name hello --code hello.js --env node --minscale 1 --maxscale 5 --executortype newdeploy  View \u0026amp; update function source code You can look at the source code associated with given function:\n$ fission fn get --name hello module.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, world!\\n\u0026quot; }; }  Let\u0026rsquo;s say you want to update the function to output \u0026ldquo;Hello Fission\u0026rdquo; instead of \u0026ldquo;Hello world\u0026rdquo;, you can update the source file and update the source code for function:\n$ fission fn update --name hello --code ../hello.js package 'hello-js-ku9s' updated function 'hello' updated  Let\u0026rsquo;s verify that the function now respond with a different output than earlier:\n$ curl http://$FISSION_ROUTER/hello Hello, Fission!  Test and debug function You can directly test a function using test command. If the function call succeeds, it will output the function\u0026rsquo;s response.\n$ fission fn test --name hello Hello, Fission!  But if there is an error in function execution then the logs of function execution are displayed:\n$ fission fn test --name hello Error calling function hello: 500 Internal server error (fission) \u0026gt; fission-nodejs-runtime@0.1.0 start /usr/src/app \u0026gt; node server.js Codepath defaulting to /userfunc/user Port defaulting to 8888 user code load error: SyntaxError: Unexpected token function ::ffff:10.8.1.181 - - [16/Feb/2018:08:44:33 +0000] \u0026quot;POST /specialize HTTP/1.1\u0026quot; 500 2 \u0026quot;-\u0026quot; \u0026quot;Go-http-client/1.1\u0026quot;  You can also look at function execution logs explicitly:\n$ fission fn logs --name hello [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 fetcher received fetch request and started downloading: {1 {hello-js-rqew default 0 0001-01-01 00:00:00 +0000 UTC \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; map[] map[] [] nil [] } user [] []} [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Successfully placed at /userfunc/user [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Checking secrets/cfgmaps [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Completed fetch request [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 elapsed time in fetch request = 89.844653ms [2018-02-16 08:41:43 +0000 UTC] user code loaded in 0sec 4.235593ms [2018-02-16 08:41:43 +0000 UTC] ::ffff:10.8.1.181 - - [16/Feb/2018:08:41:43 +0000] \u0026quot;POST /specialize HTTP/1.1\u0026quot; 202 - \u0026quot;-\u0026quot; \u0026quot;Go-http-client/1.1\u0026quot; [2018-02-16 08:41:43 +0000 UTC] ::ffff:10.8.1.182 - - [16/Feb/2018:08:41:43 +0000] \u0026quot;GET / HTTP/1.1\u0026quot; 200 16 \u0026quot;-\u0026quot; \u0026quot;curl/7.54.0\u0026quot;  Fission builds \u0026amp; compiled artifacts Most real world functions will require more than one source files. It is also easier to simply provide source files and let Fission take care of building from source files. Fission provides first class support for building from source as well as using compiled artifacts to create functions.\nYou can attach the source/deployment packages to a function or explicitly create packages and use them across functions. Check documentation for package for more information.\nBuilding function from source Let\u0026rsquo;s take a simple python function which has dependency on a python pyyaml module. We can specify the dependencies in requirements.txt and a simple command to build from source. The tree structure of directory looks like:\nsourcepkg/ ├── __init__.py ├── build.sh ├── requirements.txt └── user.py  And the file contents:\n$ cat user.py import sys import yaml document = \u0026quot;\u0026quot;\u0026quot; a: 1 b: c: 3 d: 4 \u0026quot;\u0026quot;\u0026quot; def main(): return yaml.dump(yaml.load(document)) $ cat requirements.txt pyyaml $ cat build.sh #!/bin/sh pip3 install -r ${SRC_PKG}/requirements.txt -t ${SRC_PKG} \u0026amp;\u0026amp; cp -r ${SRC_PKG} ${DEPLOY_PKG}  You first need to create an environment with environment image and python-builder image specified:\n$ fission env create --name python --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2  Now let\u0026rsquo;s zip the directory containing the source files and create a function with source package:\n$ zip -jr demo-src-pkg.zip sourcepkg/ adding: __init__.py (stored 0%) adding: build.sh (deflated 24%) adding: requirements.txt (stored 0%) adding: user.py (deflated 25%) $ fission fn create --name hellopy --env python --src demo-src-pkg.zip --entrypoint \u0026quot;user.main\u0026quot; --buildcmd \u0026quot;./build.sh\u0026quot; function 'hellopy' created $ fission route create --function hellopy --url /hellopy  Once we create the function, the build process is started. You can check logs of the builder in fission-builder namespace:\n$ kubectl -n fission-builder logs -f py3-4214348-59555d9bd8-ks7m4 builder 2018/02/16 11:44:21 Builder received request: {demo-src-pkg-zip-ninf-djtswo ./build.sh} 2018/02/16 11:44:21 Starting build... === Build Logs ===command=./build.sh env=[PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=py3-4214348-59555d9bd8-ks7m4 PYTHON_4212095_PORT_8000_TCP_PROTO=tcp PY3_4214348_SERVICE_HOST=10.11.250.161 KUBERNETES_PORT=tcp://10.11.240.1:443 PYTHON_4212095_PORT=tcp://10.11.244.134:8000 PYTHON_4212095_PORT_8000_TCP=tcp://10.11.244.134:8000 PYTHON_4212095_PORT_8001_TCP_PROTO=tcp PYTHON_4212095_PORT_8001_TCP_ADDR=10.11.244.134 PY3_4214348_SERVICE_PORT=8000 PY3_4214348_SERVICE_PORT_BUILDER_PORT=8001 PY3_4214348_PORT_8001_TCP=tcp://10.11.250.161:8001 KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_ADDR=10.11.240.1 PY3_4214348_SERVICE_PORT_FETCHER_PORT=8000 PY3_4214348_PORT_8000_TCP=tcp://10.11.250.161:8000 PY3_4214348_PORT_8001_TCP_PORT=8001 PYTHON_4212095_SERVICE_PORT_FETCHER_PORT=8000 PYTHON_4212095_PORT_8000_TCP_ADDR=10.11.244.134 KUBERNETES_SERVICE_HOST=10.11.240.1 PY3_4214348_PORT=tcp://10.11.250.161:8000 PYTHON_4212095_SERVICE_PORT_BUILDER_PORT=8001 PYTHON_4212095_PORT_8001_TCP=tcp://10.11.244.134:8001 PY3_4214348_PORT_8000_TCP_PROTO=tcp PY3_4214348_PORT_8000_TCP_PORT=8000 KUBERNETES_SERVICE_PORT_HTTPS=443 KUBERNETES_PORT_443_TCP=tcp://10.11.240.1:443 PYTHON_4212095_PORT_8001_TCP_PORT=8001 PY3_4214348_PORT_8000_TCP_ADDR=10.11.250.161 PY3_4214348_PORT_8001_TCP_PROTO=tcp KUBERNETES_SERVICE_PORT=443 PYTHON_4212095_SERVICE_PORT=8000 PYTHON_4212095_PORT_8000_TCP_PORT=8000 PY3_4214348_PORT_8001_TCP_ADDR=10.11.250.161 KUBERNETES_PORT_443_TCP_PROTO=tcp PYTHON_4212095_SERVICE_HOST=10.11.244.134 HOME=/root SRC_PKG=/packages/demo-src-pkg-zip-ninf-djtswo DEPLOY_PKG=/packages/demo-src-pkg-zip-ninf-djtswo-c40gfu] Collecting pyyaml (from -r /packages/demo-src-pkg-zip-ninf-djtswo/requirements.txt (line 1)) Downloading PyYAML-3.12.tar.gz (253kB) Installing collected packages: pyyaml Running setup.py install for pyyaml: started Running setup.py install for pyyaml: finished with status 'done' Successfully installed pyyaml-3.12 ================== 2018/02/16 11:44:24 elapsed time in build request = 3.460498847s  Once the build has succeeded, you can hit the function URL to test the function:\n$curl http://$FISSION_ROUTER/hellopy a: 1 b: {c: 3, d: 4}  Using compiled artifacts with Fission In some cases you have a pre-built deployment package which you need to deploy to Fission. For this example let\u0026rsquo;s use a simple python file as a deployment package but in practice it can be any other compiled package.\nWe will use a simple python file in a directory and turn it into a deployment package:\n$ cat testDir/hello.py def main(): return \u0026quot;Hello, world!\u0026quot; $zip -jr demo-deploy-pkg.zip testDir/  Let\u0026rsquo;s use the deployment package to create a function and route and then test it.\n$ fission fn create --name hellopy --env python --deploy demo-deploy-pkg.zip --entrypoint \u0026quot;hello.main\u0026quot; function 'hellopy' created $ fission route create --function hellopy --url /hellopy $ curl http://$FISSION_ROUTER/hellopy Hello, world!  View function information You can retrieve metadata information of a single function or list all functions to look at basic information of functions:\n$ fission fn getmeta --name hello NAME UID ENV hello 34234b50-12f5-11e8-85c9-42010aa00010 node $ fission fn list NAME UID ENV EXECUTORTYPE MINSCALE MAXSCALE TARGETCPU hello 34234b50-12f5-11e8-85c9-42010aa00010 node poolmgr 0 1 80 hello2 e37a46e3-12f4-11e8-85c9-42010aa00010 node newdeploy 1 5 80  "
},
{
	"uri": "https://docs.fission.io/0.9.0/tutorial/enabling-istio-on-fission/",
	"title": "Enabling Istio on Fission",
	"tags": [],
	"description": "",
	"content": " This is the very first step for fission to integrate with Istio. For those interested in trying to integrate fission with istio, following is the set up tutorial.\nTest Environment  Google Kubernetes Engine: 1.9.2-gke.1  Set Up Create Kubernetes v1.9+ cluster Enable both RBAC \u0026amp; initializer features on kubernetes cluster.\n$ export ZONE=\u0026lt;zone name\u0026gt; $ gcloud container clusters create istio-demo-1 \\ --machine-type=n1-standard-2 \\ --num-nodes=1 \\ --no-enable-legacy-authorization \\ --zone=$ZONE \\ --cluster-version=1.9.2-gke.1  Grant cluster admin permissions Grant admin permission for system:serviceaccount:kube-system:default and current user.\n# for system:serviceaccount:kube-system:default $ kubectl create clusterrolebinding --user system:serviceaccount:kube-system:default kube-system-cluster-admin --clusterrole cluster-admin # for current user $ kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value core/account)  Set up Istio environment For Istio 0.5.1 you can follow the installation tutorial below. Also, you can follow the latest installation guides on Istio official site: Quick Start and Sidecar Injection.\nDownload Istio 0.5.1\n$ export ISTIO_VERSION=0.5.1 $ curl -L https://git.io/getLatestIstio | sh - $ cd istio-0.5.1  Apply istio related YAML files\n$ kubectl apply -f install/kubernetes/istio.yaml  Automatic sidecar injection\n$ kubectl api-versions | grep admissionregistration admissionregistration.k8s.io/v1beta1  Installing the webhook\nDownload the missing files in istio release 0.5.1\n$ wget https://raw.githubusercontent.com/istio/istio/master/install/kubernetes/webhook-create-signed-cert.sh -P install/kubernetes/ $ wget https://raw.githubusercontent.com/istio/istio/master/install/kubernetes/webhook-patch-ca-bundle.sh -P install/kubernetes/ $ chmod +x install/kubernetes/webhook-create-signed-cert.sh install/kubernetes/webhook-patch-ca-bundle.sh  Install the sidecar injection configmap.\n$ ./install/kubernetes/webhook-create-signed-cert.sh \\ --service istio-sidecar-injector \\ --namespace istio-system \\ --secret sidecar-injector-certs $ kubectl apply -f install/kubernetes/istio-sidecar-injector-configmap-release.yaml  Install the sidecar injector\n$ cat install/kubernetes/istio-sidecar-injector.yaml | \\ ./install/kubernetes/webhook-patch-ca-bundle.sh \u0026gt; \\ install/kubernetes/istio-sidecar-injector-with-ca-bundle.yaml $ kubectl apply -f install/kubernetes/istio-sidecar-injector-with-ca-bundle.yaml # Check sidecar injector status $ kubectl -n istio-system get deployment -listio=sidecar-injector NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE istio-sidecar-injector 1 1 1 1 26s  Install fission Set default namespace for helm installation, here we use fission as example namespace.\n$ export FISSION_NAMESPACE=fission  Create namespace \u0026amp; add label for Istio sidecar injection.\n$ kubectl create namespace $FISSION_NAMESPACE $ kubectl label namespace $FISSION_NAMESPACE istio-injection=enabled $ kubectl config set-context $(kubectl config current-context) --namespace=$FISSION_NAMESPACE  Follow the installation guide to install fission with flag enableIstio true.\n$ helm install --namespace $FISSION_NAMESPACE --set enableIstio=true --name istio-demo \u0026lt;chart-fission-all-url\u0026gt;  Create a function Set environment\n$ export FISSION_URL=http://$(kubectl --namespace fission get svc controller -o=jsonpath='{..ip}') $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..ip}')  Let\u0026rsquo;s create a simple function with Node.js.\n# hello.js module.exports = async function(context) { console.log(context.request.headers); return { status: 200, body: \u0026quot;Hello, World!\\n\u0026quot; }; }  Create environment\n$ fission env create --name nodejs --image fission/node-env:latest  Create function\n$ fission fn create --name h1 --env nodejs --code hello.js --method GET  Create route\n$ fission route create --method GET --url /h1 --function h1  Access function\n$ curl http://$FISSION_ROUTER/h1 Hello, World!  Install Istio Add-ons  Prometheus  $ kubectl apply -f istio-0.5.1/install/kubernetes/addons/prometheus.yaml $ kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') 9090:9090  Web Link: http://127.0.0.1:9090/graph\n Grafana  Please install Prometheus first.\n$ kubectl apply -f istio-0.5.1/install/kubernetes/addons/grafana.yaml $ kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=grafana -o jsonpath='{.items[0].metadata.name}') 3000:3000  Web Link: http://127.0.0.1:3000/dashboard/db/istio-dashboard\n Jaegar  $ kubectl apply -n istio-system -f https://raw.githubusercontent.com/jaegertracing/jaeger-kubernetes/master/all-in-one/jaeger-all-in-one-template.yml $ kubectl port-forward -n istio-system $(kubectl get pod -n istio-system -l app=jaeger -o jsonpath='{.items[0].metadata.name}') 16686:16686  Web Link: http://localhost:16686\n"
},
{
	"uri": "https://docs.fission.io/0.9.0/usage/environments/",
	"title": "Environment",
	"tags": [],
	"description": "",
	"content": " Create an environment You can create an environment on your cluster from an image for that language. Optionally, you can specify CPU and memory resource limits. You can also specify the number of initially pre-warmed pods, which is called the poolsize.\n$ fission env create --name node --image fission/node-env:0.4.0 --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 4  In case of pool based executor, the resources specified for environment are used for function pod as well. In case of new deployment executor, you can override the resources when you create a function.\nUsing a builder When you create an environment, you can specify a builder image and builder command which will be used for building from source code. You can override the build command when creating a function. For more details on builder and packages you should check out examples in Functions and packages\n$ fission env create --name python --image fission/python-env:latest --builder fission/python-builder:latest  Viewing environment information You can list the environments or view information of an individual environment:\n$ fission env list NAME UID IMAGE POOLSIZE MINCPU MAXCPU MINMEMORY MAXMEMORY node ac84d62e-001f-11e8-85c9-42010aa00010 fission/node-env:0.4.0 4 40m 80m 64Mi 128Mi $ fission env get --name node NAME UID IMAGE node ac84d62e-001f-11e8-85c9-42010aa00010 fission/node-env:0.4.0  "
},
{
	"uri": "https://docs.fission.io/0.9.0/usage/executor/",
	"title": "Controlling Function Execution",
	"tags": [],
	"description": "",
	"content": " Autoscaling Let\u0026rsquo;s create a function to demonstrate the autoscaling behaviour in Fission. We create a simple function which outputs \u0026ldquo;Hello World\u0026rdquo; in using NodeJS. We have kept the CPU request and limit purposefully low to simulate the load and also kept the target CPU percent to 50%.\n$ fission fn create --name hello --env node --code hello.js --minmemory 64 --maxmemory 128 --minscale 1 --maxscale 6 --executortype newdeploy --targetcpu 50 function 'hello' created  Now let\u0026rsquo;s use hey to generate the load with 250 concurrent and a total of 10000 requests:\n$ hey -c 250 -n 10000 http://$FISSION_ROUTER/hello Summary: Total:\t67.3535 secs Slowest:\t4.6192 secs Fastest:\t0.0177 secs Average:\t1.6464 secs Requests/sec:\t148.4704 Total data:\t160000 bytes Size/request:\t16 bytes Response time histogram: 0.018 [1]\t| 0.478 [486]\t|∎∎∎∎∎∎∎ 0.938 [971]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 1.398 [2686]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 1.858 [2326]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 2.318 [1641]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 2.779 [1157]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 3.239 [574]\t|∎∎∎∎∎∎∎∎∎ 3.699 [120]\t|∎∎ 4.159 [0]\t| 4.619 [38]\t|∎ Latency distribution: 10% in 0.7037 secs 25% in 1.1979 secs 50% in 1.5038 secs 75% in 2.1959 secs 90% in 2.6670 secs 95% in 2.8855 secs 99% in 3.4102 secs Details (average, fastest, slowest): DNS+dialup:\t0.0058 secs, 0.0000 secs, 1.0853 secs DNS-lookup:\t0.0000 secs, 0.0000 secs, 0.0000 secs req write:\t0.0000 secs, 0.0000 secs, 0.0026 secs resp wait:\t1.6405 secs, 0.0176 secs, 3.6144 secs resp read:\t0.0001 secs, 0.0000 secs, 0.0056 secs Status code distribution: [200]\t10000 responses  While the load is being generated, we will watch the HorizontalPodAutoscaler and how it scales over period of time. As you can notice, the number of pods is scaled from 1 to 3 after the load rises from 8 - 103%. After the load generator stops, it takes a few iterations to scale down from 3 to 1 pod.\nWhen testing the scaling behaviour, do keep in mind that the scaling event has an initial delay of uptp a minute and waits for the average CPU to reach 110% above the threshold before scaling up. It is best to maintain a minimum number of pods which can handle initial load and scale as needed.\nYou will notice that the scaling up and down has different behaviour in terms of response time. This behaviour is governed by the frequency at which the controller watches (which defaults to 30s) and parameters set on controller-manager for upscale/downscale delay. More details can be found here\n$ kubectl -n fission-function get hpa -w NAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGE hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 1 3m hello-qoxmothj Deployment/hello-qoxmothj 8% / 50% 1 6 1 3m hello-qoxmothj Deployment/hello-qoxmothj 103% / 50% 1 6 1 4m hello-qoxmothj Deployment/hello-qoxmothj 103% / 50% 1 6 3 5m hello-qoxmothj Deployment/hello-qoxmothj 25% / 50% 1 6 3 5m hello-qoxmothj Deployment/hello-qoxmothj 25% / 50% 1 6 3 6m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 6m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 7m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 7m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 8m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 8m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 9m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 9m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 10m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 10m hello-qoxmothj Deployment/hello-qoxmothj 7% / 50% 1 6 1 11m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 11m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 12m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 12m  "
},
{
	"uri": "https://docs.fission.io/0.9.0/tutorial/ingress-tutorial/",
	"title": "Exposing functions with Ingress",
	"tags": [],
	"description": "",
	"content": " This tutorial will walk you through exposing a function using an ingress controller (You can read more about ingress and ingress controller here). We will make the function available on a fully qualified domain name (FQDN) using Fission\u0026rsquo;s route and ingress controller setup in a cloud environment.\nSetup \u0026amp; pre-requisites You will need a Kubernetes cluster with Fission installed (Please check installation page for details). This tutorial uses a cloud load balancer, but if you are using Minikube you might want to take a look at details here\nLater parts of this tutorial use a FQDN to reach the function. If you plan to go along in this section, you will need a domain name setup and access to modify the NS records and create A record in the zone of the domain name you have. The tutorial uses Google cloud to walk through the tutorial but you can use any cloud you prefer to. Also the changes in name server can take 24-48 hours so you may want to use an already created domain name.\nSetup an Ingress Controller First thing we will need is an ingress controller and we will use Nginx ingress controller in this tutorial. Based on your setup you can choose one of the multiple ways to install Nginx ingress controller. This setup should work with other ingress controllers also but has not been tested.\nLet\u0026rsquo;s verify that the installation succeeded:\nkubectl get all -n ingress-nginx NAME READY STATUS RESTARTS AGE po/default-http-backend-66b447d9cf-4q8f7 1/1 Running 0 19d po/nginx-ingress-controller-58fcfdc6fd-2cwts 1/1 Running 0 19d NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE svc/default-http-backend 10.11.243.109 \u0026lt;none\u0026gt; 80/TCP 19d svc/ingress-nginx 10.11.245.254 35.200.150.175 80:31000/TCP,443:30666/TCP 19d NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deploy/default-http-backend 1 1 1 1 19d deploy/nginx-ingress-controller 1 1 1 1 19d NAME DESIRED CURRENT READY AGE rs/default-http-backend-66b447d9cf 1 1 1 19d rs/nginx-ingress-controller-58fcfdc6fd 1 1 1 19d  Following are key points to validate that ingress controller installation succeeded (Please refer to output of a successful installation above)\n The ingress controller pod is up and running The ingress-nginx service has a external IP address populated If you hit the external IP address of the ingress-nginx, you get the default backend page:  curl http://35.200.150.175 default backend - 404  Deploying Function with ingress An ingress resource allows traffic from outside the cluster to reach the services inside the cluster. The ingress is fulfilled by an ingress controller. In following sections we will create a function and enable traffic outside the cluster to reach the function.\nCreate a function We will create an environment, a function and test that it works:\n$ fission env create --name nodejs --image fission/node-env environment 'nodejs' created $ cat hello.js module.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, Fission!\\n\u0026quot; }; } $ fission fn create --name hello --env nodejs --code hello.js function 'hello' created $ fission fn test --name hello Hello, Fission!  Create a internal route Let\u0026rsquo;s create a route which is not exposed via the ingress controller so that it can be consumed by resources inside the cluster only.\nCurrently since functions are also exposed via the Fission router, the function can be accessed from outside the cluster but in future the router may not expose all functions outside the cluster.\n$ fission route create --url /ihello --function hello trigger '249838c9-9ae3-492a-bba1-b0464ae65671' created $ fission route list NAME METHOD HOST URL INGRESS FUNCTION_NAME 249838c9-9ae3-492a-bba1-b0464ae65671 GET /ihello false hello  This route will be accessible at http://$FISSION_ROUTER/ihello but if tried to access on the ingress controller address http://\u0026lt;INGRESS-CONTROLLER-EXTERNAL-IP\u0026gt;/ihello you will get a default backend page. This is expected result as we did not create an ingress for this route.\nCreate a external route Now let\u0026rsquo;s create a route which we will expose over ingress controller. We will create a route with createingress flag enabled:\n$ fission route create --url /hello --function hello --createingress trigger '301b3cb0-5ac1-4211-a1ed-2b0ad9143e34' created $ $ fission route list NAME METHOD HOST URL INGRESS FUNCTION_NAME 249838c9-9ae3-492a-bba1-b0464ae65671 GET /ihello false hello 301b3cb0-5ac1-4211-a1ed-2b0ad9143e34 GET /hello true hello $  If you check the ingress controller pod logs, you will notice that the ingress controller has re-loaded the configuration for the newly created ingress resource:\nI0604 12:47:08.983567 5 controller.go:168] backend reload required I0604 12:47:08.985535 5 event.go:218] Event(v1.ObjectReference{Kind:\u0026quot;Ingress\u0026quot;, Namespace:\u0026quot;fission\u0026quot;, Name:\u0026quot;301b3cb0-5ac1-4211-a1ed-2b0ad9143e34\u0026quot;, UID:\u0026quot;64bffe8c-67f5-11e8-98e8-42010aa00018\u0026quot;, APIVersion:\u0026quot;extensions\u0026quot;, ResourceVersion:\u0026quot;18017617\u0026quot;, FieldPath:\u0026quot;\u0026quot;}): type: 'Normal' reason: 'CREATE' Ingress fission/301b3cb0-5ac1-4211-a1ed-2b0ad9143e34 I0604 12:47:09.117629 5 controller.go:177] ingress backend successfully reloaded...  If you now hit the function at ingress controller\u0026rsquo;s IP and the path (http://\u0026lt;INGRESS-CONTROLLER-EXTERNAL-IP\u0026gt;/hello), you will get function\u0026rsquo;s response. Depending on your setup and settings, you will have to try HTTP or HTTPS. Some ingress controllers enable SSL redirect by default and hence the HTTPS URL has to be accessed.\n$ curl -k https://35.200.150.175/hello Hello, Fission!  Create a FQDN route This is an optional step and pre-requisites should be fulfilled before proceeding. You can map the FQDN to function if you have DNS setup and access. You need to do a few steps:\n Map the domain name\u0026rsquo;s name server to your cloud provider. For example we used domain name fission.sh and mapped the name server to google cloud (Since this tutorial setup is on Google cloud). The instructions are specific to your domain name provider, please check the documentation of the provider.\n Create a zone for the root domain in the cloud provider (Created a zone for fission.sh in google cloud)\n Create a sub-domain A record that maps to the IP address of Ingress Controller load balancer. In this tutorial we created a A record in the zone above for ing.fission.sh and pointed to the IP of ingress controller load balancer i.e. 35.200.150.175 (A records can take 30 minutes to 4 hours to update)\n If all these steps are configured properly, we can hit the function at FQDN like below:\n  $ curl -k https://ing.fission.sh/hello Hello, Fission!  "
},
{
	"uri": "https://docs.fission.io/0.9.0/usage/trigger/",
	"title": "Triggers",
	"tags": [],
	"description": "",
	"content": " Create a HTTP Trigger An HTTP trigger invokes a function when there is an HTTP request.\nYou can specify the relative URL and HTTP method for a trigger:\n$ fission httptrigger create --url /hello --method GET --function hello trigger '94cd5163-30dd-4fb2-ab3c-794052f70841' created  If you want to create a ingress for the HTTP trigger, you can provide the flag along with the hostname. Hostname is the host field as per HTTP1.1 specifications. If the hostname is not provided, it defaults to \u0026ldquo;*\u0026rdquo; which indicates wildcard host.\n$ fission ht create --url /hello --method GET --function hello --createingress --host acme.com trigger '94cd5163-30dd-4fb2-ab3c-794052f70841' created $ fission route list NAME METHOD HOST URL INGRESS FUNCTION_NAME 94cd5163-30dd-4fb2-ab3c-794052f70841 GET acme.com /hello true hello  Please note that for ingress to work, you will have to deploy an ingress controller in Kubernetes cluster. Kubernetes currently supports and maintains the following ingress controllers:\n Nginx Ingress Controller GCE Ingress Controller  F5 networks and Kong also offer ingress controllers which are supported and maintained by them.\nCreate a Time Trigger Time-based triggers invoke functions based on time. They can run once or repeatedly. They\u0026rsquo;re specified using cron string specifications:\n$ fission tt create --name halfhourly --function hello --cron \u0026quot;*/30 * * * *\u0026quot; trigger 'halfhourly' created  You can also use a friendlier syntax such \u0026ldquo;@every 1m\u0026rdquo; or \u0026ldquo;@hourly\u0026rdquo;:\n$ fission tt create --name minute --function hello --cron \u0026quot;@every 1m\u0026quot; trigger 'minute' created  And you can list time triggers to see their associated function and cron strings:\n$ fission tt list NAME CRON FUNCTION_NAME halfhourly 0 30 * * * hello minute @every 1m hello  Create a Message Queue Trigger A message queue trigger invokes a function based on messages from an message queue. Optionally, it can place the response of a function onto another queue.\nNATS and Azure Storage Queue are supported queues:\n$ fission mqt create --name hellomsg --function hello --mqtype nats-streaming --topic newfile --resptopic newfileresponse trigger 'hellomsg' created  You can list or update message queue triggers with fission mqt list, or fission mqt update.\n"
},
{
	"uri": "https://docs.fission.io/0.9.0/tutorial/java-example/",
	"title": "Building Java Functions",
	"tags": [],
	"description": "",
	"content": " With the JVM environment there is now support to use Java functions in Fission. This tutorial explains about the working and some inner details of the way Java functions work in Fission.\nTo see this Java support in action, we are going to build a simple \u0026ldquo;Hello World\u0026rdquo; function with the JVM environment. This example can also be found in examples directory on GitHub.\nJVM Environment The JVM environment in Fission is based on Spring boot and Spring web frameworks. Spring boot \u0026amp; web is already loaded in JVM and if you are using this dependency, you can mark it at provided scope. The environment loads the function code from JAR file during specialization and then executes it.\nFission contract A function needs to implement the io.fission.Function class and override the call method. The call method receives the RequestEntity and Context as inputs and needs to return ResponseEntity object. Both RequestEntity and ResponseEntity are from org.springframework.http package and provide a fairly high level and rich API to interact with request and response.\nResponseEntity call(RequestEntity req, Context context);  The Context object is a placeholder to interact with the platform and provide information about the platform to the code. This also is a extension mechanism to provide more information to runtime code in future.\nBuilding a function Source code \u0026amp; test The function code responds with \u0026ldquo;Hello World\u0026rdquo; in response body.\npublic class HelloWorld implements Function { @Override public ResponseEntity\u0026lt;?\u0026gt; call(RequestEntity req, Context context) { return ResponseEntity.ok(\u0026quot;Hello World!\u0026quot;); } }  Project \u0026amp; dependencies with Maven First you have to define the the basic information about the function:\n\t\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;io.fission\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hello-world\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;JAR\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;hello-world\u0026lt;/name\u0026gt;  You will have to add two dependencies which are provided by the function runtime, so both them of scope as provided.\n\t\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.fission\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fission-java-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.2-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  One of the key things when packaging the Java function is to package it as a uber/fat JAR so that the class and all other dependencies are packaged with function. For that you can use maven-assembly-plugin:\n\u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;make-assembly\u0026lt;/id\u0026gt; \u0026lt;!-- this is used for inheritance merges --\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;!-- bind to the packaging phase --\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;single\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt;  Lastly since the fission-java-core is currently in the snapshot release, you need to explicitely add the sonatype repository which is where it is published.\n\t\u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;fission-java-core\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;fission-java-core-snapshot\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://oss.sonatype.org/content/repositories/snapshots/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt;  Building the package For building the source Java code with Maven, you either need Maven and Java installed locally or you can use the build.sh helper script which builds the code inside a docker image which has those dependencies.\ndocker run -it --rm -v \u0026quot;$(pwd)\u0026quot;:/usr/src/mymaven -w /usr/src/mymaven maven:3.5-jdk-8 mvn clean package  At this stage we assume that build succeeded and you have the JAR file of the function ready.\nDeploying the function First you will need to create an environment. The extract flag is important for Java based applications packaged as JAR file. This flag will ensure that the fetcher won\u0026rsquo;t extract the JAR file into a directory. Currently JVM environment only supports version 2 \u0026amp; above so we specify the environment version as 2\n$ fission env create --name jvm --image fission/jvm-env --version 2 --extract=false  When creating the function we provide the JAR file built in earlier steps and the environment. The entrypoint signifies the fully qualified name of the class which implements the Fission\u0026rsquo;s Function interface.\n$ fission fn create --name hello --deploy target/hello-world-1.0-SNAPSHOT-JAR-with-dependencies.JAR --env jvm --entrypoint io.fission.HelloWorld  Lastly you can create a route and test that the function works!\n$ fission route create --function hello --url /hellon --method GET $ curl $FISSION_ROUTER/hello Hello World!  What\u0026rsquo;s next  More examples can be found in examples directory on GitHub  "
},
{
	"uri": "https://docs.fission.io/0.9.0/usage/package/",
	"title": "Packaging source code",
	"tags": [],
	"description": "",
	"content": " Creating source package Before you create a package, you need to create an environment with associated builder image:\n$ fission env create --name pythonsrc --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2 environment 'pythonsrc' created  Let\u0026rsquo;s take a simple python function which has dependency on a python pyyaml module. We can specify the dependencies in requirements.txt and a simple command to build from source. The tree structure of directory and contents of the file looks like:\nsourcepkg/ ├── __init__.py ├── build.sh ├── requirements.txt └── user.py  And the file contents:\n$ cat user.py import sys import yaml document = \u0026quot;\u0026quot;\u0026quot; a: 1 b: c: 3 d: 4 \u0026quot;\u0026quot;\u0026quot; def main(): return yaml.dump(yaml.load(document)) $ cat requirements.txt pyyaml $ cat build.sh #!/bin/sh pip3 install -r ${SRC_PKG}/requirements.txt -t ${SRC_PKG} \u0026amp;\u0026amp; cp -r ${SRC_PKG} ${DEPLOY_PKG} $zip -jr demo-src-pkg.zip sourcepkg/ adding: __init__.py (stored 0%) adding: build.sh (deflated 24%) adding: requirements.txt (stored 0%) adding: user.py (deflated 25%)  Using the source archive creared in previous step, you can create a package in Fission:\n$ fission package create --sourcearchive demo-src-pkg.zip --env pythonsrc --buildcmd \u0026quot;./build.sh\u0026quot; Package 'demo-src-pkg-zip-8lwt' created  Since we are working with source package, we provided the build command. Once you create the package, the build process will start and you can check the build logs by getting information of the package:\n$ fission pkg info --name demo-src-pkg-zip-8lwt Name: demo-src-pkg-zip-8lwt Environment: pythonsrc Status: succeeded Build Logs: Collecting pyyaml (from -r /packages/demo-src-pkg-zip-8lwt-v57qil/requirements.txt (line 1)) Using cached PyYAML-3.12.tar.gz Installing collected packages: pyyaml Running setup.py install for pyyaml: started Running setup.py install for pyyaml: finished with status 'done' Successfully installed pyyaml-3.12  Using the package above you can create the function. Since package already is associated with a source package, environment and build command, these will be ignored when creating a function. Only addition thing you will need to provide is the entrypoint. Assuming you hace created the route, the function should be reachable with successful output:\n$ fission fn create --name srcpy --pkg demo-src-pkg-zip-8lwt --entrypoint \u0026quot;user.main\u0026quot; function 'srcpy' created $ curl http://$FISSION_ROUTER/srcpy a: 1 b: {c: 3, d: 4}  Creating deployment package Before you create a package you need to create an environment with the builder image:\n$ fission env create --name pythondeploy --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2 environment 'pythonsrc' created  We will use a simple Python example which outputs \u0026ldquo;Hello World!\u0026rdquo; in a directory to create a deployment archive:\n$ cat testDir/hello.py def main(): return \u0026quot;Hello, world!\u0026quot; $zip -jr demo-deploy-pkg.zip testDir/  Using the archive and environments created previously, you can create a package:\n$ fission package create --deployarchive demo-deploy-pkg.zip --env pythondeploy Package 'demo-deploy-pkg-zip-whzl' created  Since it is a deployment archive, there is no need to build it, hence the build logs for the package will be empty:\n$ fission package info --name demo-deploy-pkg-zip-whzl Name: demo-deploy-pkg-zip-xlaw Environment: pythondeploy2 Status: succeeded Build Logs:  Finally you can create a function with the package and test the function:\n$ fission fn create --name deploypy --pkg demo-deploy-pkg-zip-whzl --entrypoint \u0026quot;hello.main\u0026quot; $curl http://$FISSION_ROUTER/deploypy Hello, world!  "
},
{
	"uri": "https://docs.fission.io/0.9.0/usage/access-secret-cfgmap-in-function/",
	"title": "Accessing Secrets in Functions",
	"tags": [],
	"description": "",
	"content": " Functions can access Kubernetes Secrets and ConfigMaps.\nUse secrets for things like API keys, authentication tokens, and so on.\nUse config maps for any other configuration that doesn\u0026rsquo;t need to be a secret.\nCreate A Secret or a ConfigMap You can create a Secret or ConfigMap with the Kubernetes CLI:\n$ kubectl -n default create secret generic my-secret --from-literal=TEST_KEY=\u0026quot;TESTVALUE\u0026quot; $ kubectl -n default create configmap my-configmap --from-literal=TEST_KEY=\u0026quot;TESTVALUE\u0026quot;  Or, use kubectl create -f \u0026lt;filename.yaml\u0026gt; to create these from a YAML file.\napiVersion: v1 kind: Secret metadata: namespace: default name: my-secret data: TEST_KEY: VEVTVFZBTFVF # value after base64 encode type: Opaque --- apiVersion: v1 kind: ConfigMap metadata: namespace: default name: my-configmap data: TEST_KEY: TESTVALUE  Accessing Secrets and ConfigMaps Secrets and configmaps are accessed similarly. Each secret or configmap is a set of key value pairs. Fission sets these up as files you can read from your function.\n# Secret path /secrets/\u0026lt;namespace\u0026gt;/\u0026lt;name\u0026gt;/\u0026lt;key\u0026gt; # ConfigMap path /configs/\u0026lt;namespace\u0026gt;/\u0026lt;name\u0026gt;/\u0026lt;key\u0026gt;  From the previous example, the paths are:\n# secret my-secret /secrets/default/my-secret/TEST_KEY # confimap my-configmap /configs/default/my-configmap/TEST_KEY  Now, let\u0026rsquo;s create a simple python function (leaker.py) that returns the value of Secret my-secret and ConfigMap my-configmap.\n# leaker.py def main(): path = \u0026quot;/configs/default/my-configmap/TEST_KEY\u0026quot; f = open(path, \u0026quot;r\u0026quot;) config = f.read() path = \u0026quot;/secrets/default/my-secret/TEST_KEY\u0026quot; f = open(path, \u0026quot;r\u0026quot;) secret = f.read() msg = \u0026quot;ConfigMap: %s\\nSecret: %s\u0026quot; % (config, secret) return msg, 200  Create an environment and a function:\n# create python env $ fission env create --name python --image fission/python-env # create function named \u0026quot;leaker\u0026quot; $ fission fn create --name leaker --env python --code leaker.py --secret my-secret --configmap my-configmap  Run the function, and the output should look like this:\n$ fission function test --name leaker ConfigMap: TESTVALUE Secret: TESTVALUE  If the Secret or ConfigMap value is updated, the function may not get the updated value for some time; it may get a cached older value.\n "
},
{
	"uri": "https://docs.fission.io/0.9.0/contributing/",
	"title": "Contributing to Fission",
	"tags": [],
	"description": "",
	"content": " Contributing to Fission Development guide "
},
{
	"uri": "https://docs.fission.io/0.9.0/contributing/compiling/",
	"title": "Compiling Fission",
	"tags": [],
	"description": "",
	"content": "[You only need to do this if you\u0026rsquo;re making Fission changes; if you\u0026rsquo;re just deploying Fission, use fission.yaml which points to prebuilt images.]\nYou\u0026rsquo;ll need the go compiler and tools installed, along with the glide dependency management tool. You\u0026rsquo;ll also need docker for building images.\nThe server side is compiled as one binary (\u0026ldquo;fission-bundle\u0026rdquo;) which contains controller, poolmgr and router; it invokes the right one based on command-line arguments.\nTo build fission-bundle: clone this repo to $GOPATH/src/github.com/fission/fission, then from the top level directory (if you want to build the image with the docker inside minikube, you\u0026rsquo;ll need to set the proper environment variables with eval $(minikube docker-env)):\n # Get dependencies $ glide install # Build fission server and an image $ pushd fission-bundle $ ./build.sh  You now need to build the docker image for fission. You can use push.sh and push it to a docker hub account. But it\u0026rsquo;s easiest to use minikube and its built-in docker daemon:\n $ eval $(minikube docker-env) $ docker build -t minikube/fission-bundle .  Next, install fission with this image on your kubernetes cluster using the helm chart:\n $ helm install --set \u0026quot;image=minikube/fission-bundle,pullPolicy=IfNotPresent,analytics=false\u0026quot; charts/fission-all  And if you\u0026rsquo;re changing the CLI too, you can build it with:\n # Build Fission CLI $ cd fission \u0026amp;\u0026amp; go install  "
},
{
	"uri": "https://docs.fission.io/0.9.0/workflows/",
	"title": "Fission Workflows",
	"tags": [],
	"description": "",
	"content": " Prerequisites Fission Workflows requires the following components to be installed on your local machine:\n kubectl helm  Fission Workflows is deployed on top of a Kubernetes cluster. If you don\u0026rsquo;t have a Kubernetes cluster, here\u0026rsquo;s a quick guide to set one up. It also requires a Fission deployment to be present on your Kubernetes cluster. If you do not have a Fission deployment, follow Fission\u0026rsquo;s installation guide.\n(Note that Fission Workflows 0.4.0 requires Fission 0.4.1 or higher, with the NATS component installed!)\nInstalling Fission Workflows Fission Workflows is an add-on to Fission. You can install both Fission and Fission Workflows using helm charts.\nAssuming you have your Kubernetes cluster set up with a functioning deployment of Fission 0.4.1 or higher, run the following commands:\n# If you haven't already, add the Fission charts repo $ helm repo add fission-charts https://fission.github.io/fission-charts/ $ helm repo update # Install Fission Workflows $ helm install --wait -n fission-workflows fission-charts/fission-workflows --version 0.4.0  Creating your first workflow After installing Fission and Workflows, you\u0026rsquo;re all set to run a simple test workflow. With the following code snippet you will be able to deploy and run a small workflow example:\n# Fetch the required files, alternatively you could clone the fission-workflow repo $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.4.0/examples/whales/fortune.sh \u0026gt; fortune.sh $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.4.0/examples/whales/whalesay.sh \u0026gt; whalesay.sh $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.4.0/examples/whales/fortunewhale.wf.yaml \u0026gt; fortunewhale.wf.yaml # # Add binary environment and create two test functions on your Fission setup: # $ fission env create --name binary --image fission/binary-env $ fission function create --name whalesay --env binary --deploy ./whalesay.sh $ fission function create --name fortune --env binary --deploy ./fortune.sh # # Create a workflow that uses those two functions. A workflow is just # a function that uses the \u0026quot;workflow\u0026quot; environment. # $ fission function create --name fortunewhale --env workflow --src ./fortunewhale.wf.yaml # # Map an HTTP GET to your new workflow function: # $ fission route create --method GET --url /fortunewhale --function fortunewhale # # Invoke the workflow with an HTTP request: # $ curl ${FISSION_ROUTER}/fortunewhale  This last command, the invocation of the workflow, should return a whale saying something wise\n ______________________________________ / Anthony's Law of Force: \\ | | \\ Don't force it; get a larger hammer. / -------------------------------------- \\ \\ \\ ## . ## ## ## == ## ## ## ## ## === /\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\\___/ === { / ===- \\______ O __/ \\ \\ __/ \\____\\_______/  So what happened here? Let\u0026rsquo;s see what the workflow consists of (for example by running cat fortunewhale.wf.yaml):\n# This whale shows off a basic workflow that combines both Fission Functions (fortune, whalesay) and internal functions (noop) apiVersion: 1 output: WhaleWithFortune tasks: InternalFuncShowoff: run: noop GenerateFortune: run: fortune requires: - InternalFuncShowoff WhaleWithFortune: run: whalesay inputs: \u0026quot;{$.Tasks.GenerateFortune.Output}\u0026quot; requires: - GenerateFortune  What you see is the YAML-based workflow definition of the fortunewhale workflow. A workflow consists of multiple tasks, which are steps that it needs to complete. Each task has a unique identifier, such as GenerateFortune, a reference to a Fission function in the run field. Optionally, it can contain inputs which allows you to specify inputs to the task, as well as contain requires which allows you to specify which tasks need to complete before this task can start. Finally, at the top you will find the output field, which specifies the task whose output is used as the workflow\u0026rsquo;s output.\nIn this case, the fortunewhale workflow consists of a sequence of 3 tasks:\nInternalFuncShowoff -\u0026gt; GenerateFortune -\u0026gt; WhaleWithFortune  First, it starts with InternalFuncShowoff by running noop, which is an internal function in the workflow engine. Internal functions are run inside of the workflow engine, which makes them run much faster at the cost of expressiveness and scalability. So typically, light-weight functions, such as logic or control flow operations, are good candidates to be used as internal functions. Besides, a minimal set of predefined internal functions, you can define internal function - there is nothing special about them.\nAfter InternalFuncShowff completes, the GenerateFortune task can start as its requires has been fulfilled. It runs the fortune Fission function, which outputs a random piece of wisdom.\nAfter GenerateFortune completes, the WhaleWithFortune task can start. This task uses a javascript expression in its inputs to reference the output of the GenerateFortune task. In the inputs of a task you can reference anything in the workflow, such as outputs, inputs, and task definitions, or just provide a constant value. The workflow engine invokes the whalesay fission function with as input the piece of wisdom, which outputs the ASCI whale that wraps the phrase.\nFinally, with all tasks completed, the workflow engine uses the top-level output field to fetch the output of the WhaleWithFortune and return it to the user. As the workflow engine adheres to the Fission function specification, a Fission workflow is just another Fission Function. This means that you could use this workflow as a function in the run in other workflows.\nWhat\u0026rsquo;s next? To learn more about the Fission Workflows system and its advanced concepts, see the documentation on Github.\nOr, check out the examples for more example workflows.\nIf something went wrong, we\u0026rsquo;d love to help \u0026ndash; please drop by the slack channel and ask for help.\n"
},
{
	"uri": "https://docs.fission.io/0.9.0/tutorial/developer-workflow/",
	"title": "Source Code Organization and Your Development Workflow",
	"tags": [],
	"description": "",
	"content": " You\u0026rsquo;ve made a Hello World function in your favourite language, and you\u0026rsquo;ve run it on your Fission deployment. What\u0026rsquo;s next?\nHow should you organize source code when you have lots of functions? How should you automate deployment into the cluster? What about version control? How do you test before deploying?\nThe answers to these questions start from a common first step: how do you specify an application?\nDeclarative Specifications Instead of invoking the Fission CLI commands, you can specify your functions in a set of YAML files. This is better than scripting the fission CLI, which is meant as a user interface, not a programming interface.\nYou\u0026rsquo;ll usually want to track these YAML files in version control along with your source code. Fission provides CLI tools for generating these specification files, validating them, and \u0026ldquo;applying\u0026rdquo; them to a Fission installation.\nWhat does it mean to apply a specification? It means putting specification to effect: figuring out the things that need to be changed on the cluster, and updating them to make them the same as the specification.\nApplying a Fission spec goes through these steps:\n Resources (functions, triggers, etc) that are in the specification but don\u0026rsquo;t exist on the cluster are created. Local source files are packaged and uploaded.\n Resources that are both in the specs and on the cluster are compared. If they\u0026rsquo;re different, the ones on the cluster are changed to match the spec.\n Resources present only on the cluster and not in the spec are destroyed. (This deletion is limited to resources that were created by a previous apply; this makes sure that Fission doesn\u0026rsquo;t delete unrelated resources. See below for how this calculation works.)\n  Note that running apply more than once is equivalent to running it once: in other words, it\u0026rsquo;s idempotent.\nUsage Summary Start using Fission\u0026rsquo;s declarative application specifications in 3 steps:\n Initialize a directory of specs: fission spec init Generate some YAMLs: fission function create --spec ... Apply them to a cluster: fission spec apply --wait  You can also deploy continuously with fission spec apply --watch.\nWe\u0026rsquo;ll see examples of all these commands in the tutorial below.\nTutorial This tutorial assumes you\u0026rsquo;ve already set up Fission, and tested a simple hello world function to make sure everything\u0026rsquo;s working. To learn how to do that, head over to the installation guide.\nWe\u0026rsquo;ll make a small calculator app with one python environment and two functions, all of which will be declaratively specified using YAML files. This is a somewhat contrived example, but it is just meant as an illustration.\nMake an empty directory mkdir spec-tutorial cd spec-tutorial  Initialize the specs directory fission spec init  This creates a specs/ directory. You\u0026rsquo;ll see a fission-config.yaml in there. This file has a unique ID in it; everything created on the cluster from these specs will be annotated with that unique ID.\nSetup a Python environment fission env create --spec --name python --image fission/python-env:0.9.0 --builder fission/python-build-env:0.9.0  This command creates a YAML file under specs called specs/env-python.yaml.\nCode two functions One function simply returns a simple web form. You can download the code or copy paste from the contents below:\n curl -Lo form.py http://xxx  Here are its contents:\ndef main(): return \u0026quot;\u0026quot;\u0026quot; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026quot;/calculate\u0026quot; method=\u0026quot;GET\u0026quot;\u0026gt; \u0026lt;input name=\u0026quot;num_1\u0026quot;/\u0026gt; \u0026lt;input name=\u0026quot;num_2\u0026quot;/\u0026gt; \u0026lt;input name=\u0026quot;operator\u0026quot;/\u0026gt; \u0026lt;button\u0026gt;Calculate\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026quot;\u0026quot;\u0026quot;  The form accepts a simple arithmetic expression. When it is submitted, it makes a request to the second function, which calculates the expression entered.\nHere\u0026rsquo;s the calculator function:\n curl -Lo calc.py http://yyy  That function is pretty simple too:\ndef main(): num_1 = int(request.form['num_1']) num_2 = int(request.form['num_2']) operator = request.form['operator'] if operator == '+': result = num_1 + num_2 elsif operator == '-': result = num_1 - num_2 return \u0026quot;%s %s %s = %s\u0026quot; % (num_1, operator, num_2, result)  Create specs for these functions Let\u0026rsquo;s create a specification for each of these functions. This specifies the function name, where the code lives, and associates the function with the python environment:\nfission function create --spec --name calc-form --env python --src form.py --entrypoint form.main fission function create --spec --name calc-eval --env python --src calc.py --entrypoint calc.main  You can see the generated YAML files in specs/function-calc-form.yaml and specs/function-calc-eval.yaml.\nCreate HTTP trigger specs fission route create --spec --method GET --url /form --function calc-form fission route create --spec --method GET --url /eval --function calc-eval  This creates YAML files specifying that GET requests on /form and /eval invoke the functions calc-form and calc-eval respectively.\nValidate your specs Spec validation does some basic checks: it makes sure there are no duplicate functions with the same name, and that references between various resources are correct.\nfission spec validate  You should see no errors.\nApply: deploy your functions to Fission You can simply use apply to deploy the environment, functions and HTTP triggers to the cluster.\nfission spec apply --wait  (This uses your kubeconfig to connect to Fission, just like kubectl. See Usage Reference below for options.)\nTest a function Make sure your function is working:\nfission function test --name calc-form  You should see the output of the calc-form function.\nTo test the other function, open the URL of the Fission router service in a browser, enter two numbers and an operator, and click submit.\n(If you don\u0026rsquo;t know the address of the Fission router, you can find it with kubectl: kubectl -n fission get service router.)\nModify the function and re-deploy it Let\u0026rsquo;s try modifying a function: let\u0026rsquo;s change the calc-eval function to support multiplication, too.\n ... elsif operator == '*': result = num_1 * num_2 ...  You can add the above lines to calc.py, or just download the modified function:\ncurl -Lo calc.py http://zzz  To deploy your changes, simply apply the specs again:\nfission spec apply --wait  This should output something like:\n1 archive updated: calc-eval-xyz 1 package updated: calc-eval-xyz 1 function updated: calc-eval  Your new updated function is deployed!\nTest it out by entering a * for the operator in the form!\nAdd dependencies to the function Let\u0026rsquo;s say you\u0026rsquo;d like to add a pip requirements.txt to your function, and include some libraries in it, so you can import them in your functions.\nCreate a requirements.txt, and add something to it:\nxxx  Modify the ArchiveUploadSpec inside specs/function-.yaml\nOnce again, deploying is the same:\nfission spec apply --wait  This command figures out that one function has changed, uploads the source to the cluster, and waits until the Fission builder on the cluster finishes rebuilding this updated source code.\nA bit about how this works Kubernetes manages its state as a set of resources. Deployments, Pod, Services are examples of resources. They represent a target state, and Kubernetes then does the work to ensure this target state is met.\nKubernetes resources can be extended, using Custom Resources. Fission runs on top of Kubernetes and sets up your functions, environments and triggers as Custom Resources. You can see even these custom resources from kubectl: try kubectl get customeresourcedefinitions or kubectl get function.fission.io\nYour specs directory is, basically, set of resources plus a bit of configuration. Each YAML file contains one or more resources. They are separated by a \u0026ldquo;\u0026mdash;\u0026rdquo; separator. The resources are functions, environments, triggers.\nThere\u0026rsquo;s a special resource there, ArchiveUploadSpec. This is in fact not a resource, just looks like one in the YAML files. It is used to specify and name a set of files that will be uploaded to the cluster. fission spec apply uses these ArchiveUploadSpecs to create archives locally and upload them. The specs reference these archives using archive:// URLs. These aren\u0026rsquo;t \u0026ldquo;real\u0026rdquo; URLs; they are replaced by http URLs by the fission spec implementation after the archives are uploaded to the cluster. On the cluster, Archives are tracked with checksums; the Fission CLI only uploads archives when their checksum has changed.\nUsage Reference NAME: fission spec - Manage a declarative app specification USAGE: fission spec command [command options] [arguments...] COMMANDS: init Create an initial declarative app specification validate Validate Fission app specification apply Create, update, or delete Fission resources from app specification destroy Delete all Fission resources in the app specification helm Create a helm chart from the app specification OPTIONS: --help, -h show help  fission spec init NAME: fission spec init - Create an initial declarative app specification USAGE: fission spec init [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs --name value (optional) Name for the app, applied to resources as a Kubernetes annotation  fission spec validate NAME: fission spec validate - Validate Fission app specification USAGE: fission spec validate [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs  fission spec apply NAME: fission spec apply - Create, update, or delete Fission resources from app specification USAGE: fission spec apply [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs --delete Allow apply to delete resources that no longer exist in the specification --wait Wait for package builds --watch Watch local files for change, and re-apply specs as necessary  fission spec destroy NAME: fission spec destroy - Delete all Fission resources in the app specification USAGE: fission spec destroy [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs  "
},
{
	"uri": "https://docs.fission.io/0.9.0/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.fission.io/0.9.0/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.fission.io/0.9.0/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.fission.io/0.9.0/tutorial/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": ""
}]