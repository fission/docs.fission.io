[
{
	"uri": "https://docs.fission.io/0.11.0/",
	"title": "Fission",
	"tags": [],
	"description": "",
	"content": " Fission: Serverless Functions for Kubernetes fission.io @fissionio\nFission is a fast serverless framework for Kubernetes with a focus on developer productivity and high performance.\nFission operates on just the code: Docker and Kubernetes are abstracted away under normal operation, though you can use both to extend Fission if you want to.\nFission is extensible to any language; the core is written in Go, and language-specific parts are isolated in something called environments (more below). Fission currently supports NodeJS, Python, Ruby, Go, PHP, Bash, and any Linux executable, with more languages coming soon.\nPerformance: 100msec cold start Fission maintains a pool of \u0026ldquo;warm\u0026rdquo; containers that each contain a small dynamic loader. When a function is first called, i.e. \u0026ldquo;cold-started\u0026rdquo;, a running container is chosen and the function is loaded. This pool is what makes Fission fast: cold-start latencies are typically about 100msec.\nKubernetes is the right place for Serverless We\u0026rsquo;re built on Kubernetes because we think any non-trivial app will use a combination of serverless functions and more conventional microservices, and Kubernetes is a great framework to bring these together seamlessly.\nBuilding on Kubernetes also means that anything you do for operations on your Kubernetes cluster \u0026mdash; such as monitoring or log aggregation \u0026mdash; also helps with ops on your Fission deployment.\nFission Concepts A function is a piece of code that follows the fission function interface.\nAn environment contains the language- and runtime-specific parts of running a function.\nThe following environments are currently available:\n   Environment Image     Binary (for executables or scripts) fission/binary-env   Go fission/go-env   .NET fission/dotnet-env   .NET 2.0 fission/dotnet20-env   NodeJS (Alpine) fission/node-env   NodeJS (Debian) fission/node-env-debian   Perl fission/perl-env   PHP 7 fission/php-env   Python 3 fission/python-env   Ruby fission/ruby-env    You can also extend environments or create entirely new ones if you want. (An environment is essentially just a container with a webserver and dynamic loader.)\nA trigger is something that maps an event to a function; Fission supports HTTP routes as triggers today, with upcoming support for other types of event triggers, such as timers and Kubernetes events.\nUsage # Add the stock NodeJS env to your Fission deployment $ fission env create --name nodejs --image fission/node-env # A javascript one-liner that prints \u0026quot;hello world\u0026quot; $ curl https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js \u0026gt; hello.js # Upload your function code to fission $ fission function create --name hello --env nodejs --code hello.js # Map GET /hello to your new function $ fission route create --method GET --url /hello --function hello # Run the function. This takes about 100msec the first time. $ fission function test --name hello Hello, world!  See the examples directory for more.\n"
},
{
	"uri": "https://docs.fission.io/0.11.0/installation/kubernetessetup/",
	"title": "Kubernetes Quick Install",
	"tags": [],
	"description": "",
	"content": " This is a quick guide to help you get started running Kubernetes on your laptop (or on the cloud).\n(This isn\u0026rsquo;t meant as a production Kuberenetes guide; it\u0026rsquo;s merely intended to give you something quickly so you can try Fission on it.)\nMinikube Minikube is the usual way to run Kubernetes on your laptop:\nInstall and start Kubernetes on OSX: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.26.1/minikube-darwin-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Or, install and start Kubernetes on Linux: $ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin $ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.26.1/minikube-linux-amd64 \u0026amp;\u0026amp; chmod +x minikube \u0026amp;\u0026amp; sudo mv minikube /usr/local/bin/ $ minikube start  Google Container Engine Alternatively, you can use Google Kubernetes Engine\u0026rsquo;s free trial to get a 3-node cluster. Hop over to Google Cloud to set that up.\n"
},
{
	"uri": "https://docs.fission.io/0.11.0/concepts/basic-concept/",
	"title": "Basic Concepts",
	"tags": [],
	"description": "",
	"content": " There are three basic concepts/elements of fission:\nFunction A snippet of code write in specific programming language and will be invoked when requests come to fission router.\nFollowing is a simple nodejs helloworld sample\nmodule.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, world!\\n\u0026quot; }; }  Currently, fission support multiple popular language like NodeJs, Go, Python, Java\u0026hellip;etc. For more examples in different languages, please visit fission language examples.\nEnvironment The environment(language) container which runs user function to serve HTTP requests. When a request hit fission router, the env container will load user function into runtime conainer first, then execute the function to serve the request.\nTrigger A fission object maps incoming requests to the backend functions. When a trigger receives requests/events, it will invoke the target function defined in trigger object by sending a HTTP request to function pod.\nCurrently, fission supports following types of trigger:\n HTTP Trigger  The trigger first registers a specific url path to router and proxy all requests hit the url to user function.  Time trigger  A function will be invoked based on the schedule of cron spec.  Message Queue Trigger  The trigger will subscribe and handle any messages sent to the message queue topic. Then, publish function response/error to the predefined response/error topic.  Kubernetes Watch Trigger  A watcher will be created to watch changes of kubernetes objects. If any changes occurred, invoke the target user function.   "
},
{
	"uri": "https://docs.fission.io/0.11.0/installation/",
	"title": "Installing Fission",
	"tags": [],
	"description": "",
	"content": " Welcome! This guide will get you up and running with Fission on a Kubernetes cluster.\nCluster preliminaries If you don\u0026rsquo;t have a Kubernetes cluster, here\u0026rsquo;s a quick guide to set one up.\nFirst, let\u0026rsquo;s ensure you have the Kubernetes CLI and Helm installed and ready. If you already have helm, skip ahead to the fission install.\nIf you cannot (or don\u0026rsquo;t want to) use Helm, there is an alternative installation method possible; see installing without Helm..\nKubernetes CLI Ensure you have the Kubernetes CLI.\nYou can get the Kubernetes CLI for OSX like this:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Or, for Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \u0026amp;\u0026amp; chmod +x kubectl \u0026amp;\u0026amp; sudo mv kubectl /usr/local/bin  Next, ensure you have access to a cluster. Do this by using kubectl to check your Kubernetes version:\n$ kubectl version  We will need at least Kubernetes 1.6.\nSet up Helm Helm is an installer for Kubernetes. If you already use helm, skip to the next section.\nTo install Helm, first you\u0026rsquo;ll need the helm CLI:\nOn OS X:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.7.0-darwin-amd64.tar.gz $ tar xzf helm-v2.7.0-darwin-amd64.tar.gz $ mv darwin-amd64/helm /usr/local/bin  On Linux:\n$ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.7.0-linux-amd64.tar.gz $ tar xzf helm-v2.7.0-linux-amd64.tar.gz $ mv linux-amd64/helm /usr/local/bin  Next, install the Helm server on your Kubernetes cluster. Before you do that, you have to give helm\u0026rsquo;s server privileges to install software on your cluster.\nFor example, you can use the following steps to install helm using a dedicated service account with full cluster admin privileges.\n$ kubectl create serviceaccount --namespace kube-system tiller $ kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller $ helm init --service-account tiller  Or, if your cluster is already set up with a permissive service account (this varies by version and how your Kubernetes was installed), you can simply do:\n$ helm init  Install Fission (if you have helm) Minikube Since minikube 0.26.0 the default bootstrapper is kubeadm which enables RBAC by default. For those who work on versions before 0.26.0, please follow the steps below to enable RBAC.\n# For minikube before version 0.26.0 $ minikube start --extra-config=apiserver.Authorization.Mode=RBAC  Then, you should see the cluster role cluster-admin.\n$ kubectl get clusterroles cluster-admin NAME AGE cluster-admin 44d  Install fission with helm\n$ helm install --name fission --namespace fission --set serviceType=NodePort,routerServiceType=NodePort https://github.com/fission/fission/releases/download/0.11.0/fission-all-0.11.0.tgz  The serviceType variable allows configuring the type of Kubernetes service outside the cluster. You can use ClusterIP if you don\u0026rsquo;t want to expose anything outside the cluster.\nCloud hosted clusters (GKE, AWS, Azure etc.) $ helm install --name fission --namespace fission https://github.com/fission/fission/releases/download/0.11.0/fission-all-0.11.0.tgz  Minimal version The fission-all helm chart installs a full set of services including the NATS message queue, influxDB for logs, etc. If you want a more minimal setup, you can install the fission-core chart instead:\n$ helm install --name fission --namespace fission https://github.com/fission/fission/releases/download/0.11.0/fission-core-0.11.0.tgz  Install Fission \u0026ndash; alternative method without helm This method uses kubectl apply to install Fission. You can edit the YAML file before applying it to your cluster, if you want to change anything in it.\nChoose one of the following commands to run:\n# Full Fission install, cloud hosted cluster: $ kubectl apply -f https://github.com/fission/fission/releases/download/0.11.0/fission-all-0.11.0.yaml # Full install on minikube: $ kubectl apply -f https://github.com/fission/fission/releases/download/0.11.0/fission-all-0.11.0-minikube.yaml # Minimal install on cloud hosted cluster: $ kubectl apply -f https://github.com/fission/fission/releases/download/0.11.0/fission-core-0.11.0.yaml # Minimal install on minikube: $ kubectl apply -f https://github.com/fission/fission/releases/download/0.11.0/fission-core-0.11.0-minikube.yaml  Next, install the Fission CLI.\nInstall the Fission CLI OS X Get the CLI binary for Mac:\n$ curl -Lo fission https://github.com/fission/fission/releases/download/0.11.0/fission-cli-osx \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Linux $ curl -Lo fission https://github.com/fission/fission/releases/download/0.11.0/fission-cli-linux \u0026amp;\u0026amp; chmod +x fission \u0026amp;\u0026amp; sudo mv fission /usr/local/bin/  Windows For Windows, you can use the linux binary on WSL. Or you can download this windows executable: fission.exe\nRun an example Finally, you\u0026rsquo;re ready to use Fission!\n$ fission env create --name nodejs --image fission/node-env:0.11.0 $ curl -LO https://raw.githubusercontent.com/fission/fission/master/examples/nodejs/hello.js $ fission function create --name hello --env nodejs --code hello.js $ fission function test --name hello Hello, world!  For a compiled language like Go:\n$ fission env create --name go --image fission/go-env:0.11.0 --builder fission/go-builder:0.11.0 $ curl -LO https://raw.githubusercontent.com/fission/fission/master/examples/go/hello.go $ fission function create --name gohello --env go --src hello.go --entrypoint Handler $ fission function test --name gohello Hello, world!  What\u0026rsquo;s next? If something went wrong, we\u0026rsquo;d love to help \u0026ndash; please drop by the slack channel and ask for help.\nCheck out the examples for some example functions.\n"
},
{
	"uri": "https://docs.fission.io/0.11.0/concepts/executor/",
	"title": "Fission Function Executors",
	"tags": [],
	"description": "",
	"content": " When you create a function, you can specify an executor for a function. An executor controls how function pods are created and what capabilities are available for that executor type.\nPool-based executor A pool based executor (Refered to as poolmgr) creates a pool of generic environment pods as soon as you create an environment. The pool size of initial \u0026ldquo;warm\u0026rdquo; containers can be configured based on user needs. These warm containers contain a small dynamic loader for loading the function. Resource requirements are specified at environment level and are inherited by specialized function pods.\nOnce you create a function and invoke it, one of pods from the pool is taken out and \u0026ldquo;specialized\u0026rdquo; and used for execution. This pod is used for subsequent requests for that function. If there are no more requests for a certain idle duration, then this pod is cleaned up. If a new requests come after the earlier specialized pod was cleaned up, then a new pod is specialised from the pool and used for execution.\nPoolmgr executortype is great for functions where lower latency is a requirement. Poolmgr executortype has certain limitations: for example, you can not autoscale them based on demand.\nNew-deployment executor New-Deployment executor (Newdeploy) creates a Kubernetes Deployment along with a Service and HorizontalPodAutoscaler for function execution. This enables autoscaling of function pods and load balancing the requests between pods. In future additional capabilities will be added for newdeploy executortype such as support for volume etc. In the new-deploy executor, resource requirements can be specified at the function level. These requirements override those specified in the environment.\nNewdeploy executortype can be used for requests with no particular low-latency requirements, such as those invoked asynchronously, minscale can be set to zero. In this case the Kubernetes deployment and other objects will be created on first invocation of the function. Subsequent requests can be served by the same deployment. If there are no requests for certain duration then the idle objects are cleaned up. This mechanism ensures resource consumption only on demand and is a good fit for asynchronous requests.\nFor requests where latency requirements are stringent, a minscale greater than zero can be set. This essentially keeps a minscale number of pods ready when you create a function. When the function is invoked, there is no delay since the pod is already created. Also minscale ensures that the pods are not cleaned up even if the function is idle. This is great for functions where lower latency is more important than saving resource consumption when functions are idle.\nThe latency vs. idle-cost tradeoff The executors allow you as a user to decide between latency and a small idle cost tradeoff. Depending on the need you can choose one of the combinations which is optimal for your use case. In future, a more intelligent dispatch mechanism will enable more complex combinations of executors.\n   Executor Type Min Scale Latency Idle cost     Newdeploy 0 High Very low - pods get cleaned up after idlle time   Newdeploy \u0026gt;0 Low Medium, Min Scale number of pods are always up   Poolmgr 0 Low Low, pool of pods are always up    Autoscaling The new deployment based executor provides autoscaling for functions based on CPU usage. In future custom metrics will be also supported for scaling the functions. You can set the intial and maximum CPU for a function and target CPU at which autoscaling will be trigerred. Autoscaling is useful for workloads where you expect intermittant spikes in workloads. It also enables optimal usage of resources to execute functions, by using a baseline capacity with minimum scale and ability to burst up to maximum scale based on spikes in demand.\n"
},
{
	"uri": "https://docs.fission.io/0.11.0/concepts/",
	"title": "Fission Concepts",
	"tags": [],
	"description": "",
	"content": " Fission has three main concepts: Functions, Environments, and Triggers.\nFunctions A Fission function is something that Fission executes. It\u0026rsquo;s usually a module with one entry point, and that entry point is a function with a certain interface. A number of programming languages are supported for Functions; see below.\nEnvironments Environments are the language-specific parts of Fission. An Environment contains just enough software to build and run a Fission Function.\nSince Fission invokes Functions through HTTP, this means the runtime of an environment is a container with an HTTP server, and usually a dynamic loader that can load a function. Some environments also contain builder containers, which take care of compilation and gathering dependencies.\nThe following pre-built environments are currently available for use in Fission:\n   Environment Image     NodeJS (Alpine) fission/node-env   NodeJS (Debian) fission/node-env-debian   Python 3 fission/python-env   Go fission/go-env   Ruby fission/ruby-env   Binary (for executables or scripts) fission/binary-env   .NET fission/dotnet-env   .NET 2.0 fission/dotnet20-env   Perl fission/perl-env   PHP 7 fission/php-env    To create custom environments you can extend one of the environments in the list or create your own environment from scratch.\nTriggers Functions are invoked on the occurence of an event; a Trigger is what configures Fission to use that event to invoke a function. In other words, a trigger is a binding of events to function invocations.\nFor example, an HTTP Trigger may bind GET requests on a certain path to the invocation of a certain function.\nThere are several types of triggers besides HTTP Triggers: Timer Trigger invoke functions based on time; Message queue triggers for Kafka, NATS, and Azure queues; Kubernetes Watch triggers to invoke functions when something in your cluster changes.\nOther Concepts These are concepts you may not need while starting out, but might be useful to know in more advanced usage.\nArchives An Archive is a zip file containing source code or compiled binaries.\nArchives with runnable functions in them are called Deployment Archives; those with source code in them are called Source Archives.\nPackages A Package is a Fission object containing a Deployment Archive and a Source Archive. A Package also references a certain environment.\nWhen you create a Package with a Source Archive, Fission automatically builds it using the appropriate builder environment, and adds a Deployment Archive to the package.\nSpecifications Specifications (specs for short) are simply YAML config files containing the objects we\u0026rsquo;ve spoken about so far \u0026mdash; Functions, Environments, Triggers, Packages and Archives.\nSpecifications exist only on the client side, and are a way to instruct the Fission CLI about what objects to create or update. They also specify how to bundle up source code, binaries etc into Archives.\nThe Fission CLI features an idempotent deployment tool that works using these specifications.\n"
},
{
	"uri": "https://docs.fission.io/0.11.0/installation/upgrade/",
	"title": "Upgrading Fission",
	"tags": [],
	"description": "",
	"content": " If you\u0026rsquo;re using Helm If you installed Fission using helm, upgrade is as simple as helm upgrade:\n# Find the name of the release you want to upgrade $ helm list # Upgrade it $ helm upgrade \u0026lt;release_name\u0026gt; https://github.com/fission/fission/releases/download/0.11.0/fission-all-0.11.0.tgz  Replace fission-all with fission-core if you\u0026rsquo;re using the minimal Fission install.\nIf you\u0026rsquo;re not using Helm If you installed using kubectl apply of a YAML file, you can simply kubectl apply the new file.\n$ kubectl apply -f https://github.com/fission/fission/releases/download/0.11.0/fission-all-0.11.0.yaml  Replace fission-all with fission-core if you\u0026rsquo;re using the minimal install.\nUse the -minikube suffix if you\u0026rsquo;re on minikube, as follows:\n$ kubectl apply -f https://github.com/fission/fission/releases/download/0.11.0/fission-all-0.11.0-minikube.yaml  Upgrading older versions Please see older documentation versions to upgrade version prior to 0.4.x:\nhttps://docs.fission.io/0.11.0/installation/upgrade/\n"
},
{
	"uri": "https://docs.fission.io/0.11.0/usage/package/",
	"title": "Packaging source code",
	"tags": [],
	"description": "",
	"content": " Creating a Source Package Before you create a package, you need to create an environment with an associated builder image:\n$ fission env create --name pythonsrc --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2 environment 'pythonsrc' created  Let\u0026rsquo;s take a simple python function which has a dependency on the pyyaml module. We can specify the dependencies in requirements.txt and a simple command to build from source. The tree structure of directory and contents of the file would look like:\nsourcepkg/ ├── __init__.py ├── build.sh ├── requirements.txt └── user.py  And the file contents:\n$ cat user.py import sys import yaml document = \u0026quot;\u0026quot;\u0026quot; a: 1 b: c: 3 d: 4 \u0026quot;\u0026quot;\u0026quot; def main(): return yaml.dump(yaml.load(document)) $ cat requirements.txt pyyaml $ cat build.sh #!/bin/sh pip3 install -r ${SRC_PKG}/requirements.txt -t ${SRC_PKG} \u0026amp;\u0026amp; cp -r ${SRC_PKG} ${DEPLOY_PKG} $zip -jr demo-src-pkg.zip sourcepkg/ adding: __init__.py (stored 0%) adding: build.sh (deflated 24%) adding: requirements.txt (stored 0%) adding: user.py (deflated 25%)  Using the source archive creared in previous step, you can create a package in Fission:\n$ fission package create --sourcearchive demo-src-pkg.zip --env pythonsrc --buildcmd \u0026quot;./build.sh\u0026quot; Package 'demo-src-pkg-zip-8lwt' created  Since we are working with a source package, we provided the build command. Once you create the package, the build process will start and you can see the build logs with the fission package info command:\n$ fission pkg info --name demo-src-pkg-zip-8lwt Name: demo-src-pkg-zip-8lwt Environment: pythonsrc Status: succeeded Build Logs: Collecting pyyaml (from -r /packages/demo-src-pkg-zip-8lwt-v57qil/requirements.txt (line 1)) Using cached PyYAML-3.12.tar.gz Installing collected packages: pyyaml Running setup.py install for pyyaml: started Running setup.py install for pyyaml: finished with status 'done' Successfully installed pyyaml-3.12  Using the package above you can create the function. Since package already is associated with a source package, environment and build command, these will be ignored when creating a function.\nThe only additional thing you\u0026rsquo;ll need to provide is the Function\u0026rsquo;s entrypoint:\n$ fission fn create --name srcpy --pkg demo-src-pkg-zip-8lwt --entrypoint \u0026quot;user.main\u0026quot; function 'srcpy' created # Run the function: $ fission fn test --name srcpy a: 1 b: {c: 3, d: 4}  Creating a Deployment Package Before you create a package you need to create an environment with the builder image:\n$ fission env create --name pythondeploy --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2 environment 'pythonsrc' created  We will use a simple Python example which outputs \u0026ldquo;Hello World!\u0026rdquo; in a directory to create a deployment archive:\n$ cat testDir/hello.py def main(): return \u0026quot;Hello, world!\u0026quot; $zip -jr demo-deploy-pkg.zip testDir/  Using the archive and environments created previously, you can create a package:\n$ fission package create --deployarchive demo-deploy-pkg.zip --env pythondeploy Package 'demo-deploy-pkg-zip-whzl' created  Since it is a deployment archive, there is no need to build it, so the build logs for the package will be empty:\n$ fission package info --name demo-deploy-pkg-zip-whzl Name: demo-deploy-pkg-zip-xlaw Environment: pythondeploy2 Status: succeeded Build Logs:  Finally you can create a function with the package and test the function:\n$ fission fn create --name deploypy --pkg demo-deploy-pkg-zip-whzl --entrypoint \u0026quot;hello.main\u0026quot; $ fission fn test --name deploypy Hello, world!  While these examples illustrate how to use packages, you don\u0026rsquo;t have to use them every time you need to build your source code. A better way is to use Specifications.\n"
},
{
	"uri": "https://docs.fission.io/0.11.0/usage/access-secret-cfgmap-in-function/",
	"title": "Accessing Secrets in Functions",
	"tags": [],
	"description": "",
	"content": " Functions can access Kubernetes Secrets and ConfigMaps.\nUse secrets for things like API keys, authentication tokens, and so on.\nUse config maps for any other configuration that doesn\u0026rsquo;t need to be a secret.\nCreate A Secret or a ConfigMap You can create a Secret or ConfigMap with the Kubernetes CLI:\n$ kubectl -n default create secret generic my-secret --from-literal=TEST_KEY=\u0026quot;TESTVALUE\u0026quot; $ kubectl -n default create configmap my-configmap --from-literal=TEST_KEY=\u0026quot;TESTVALUE\u0026quot;  Or, use kubectl create -f \u0026lt;filename.yaml\u0026gt; to create these from a YAML file.\napiVersion: v1 kind: Secret metadata: namespace: default name: my-secret data: TEST_KEY: VEVTVFZBTFVF # value after base64 encode type: Opaque --- apiVersion: v1 kind: ConfigMap metadata: namespace: default name: my-configmap data: TEST_KEY: TESTVALUE  Accessing Secrets and ConfigMaps Secrets and configmaps are accessed similarly. Each secret or configmap is a set of key value pairs. Fission sets these up as files you can read from your function.\n# Secret path /secrets/\u0026lt;namespace\u0026gt;/\u0026lt;name\u0026gt;/\u0026lt;key\u0026gt; # ConfigMap path /configs/\u0026lt;namespace\u0026gt;/\u0026lt;name\u0026gt;/\u0026lt;key\u0026gt;  From the previous example, the paths are:\n# secret my-secret /secrets/default/my-secret/TEST_KEY # confimap my-configmap /configs/default/my-configmap/TEST_KEY  Now, let\u0026rsquo;s create a simple python function (leaker.py) that returns the value of Secret my-secret and ConfigMap my-configmap.\n# leaker.py def main(): path = \u0026quot;/configs/default/my-configmap/TEST_KEY\u0026quot; f = open(path, \u0026quot;r\u0026quot;) config = f.read() path = \u0026quot;/secrets/default/my-secret/TEST_KEY\u0026quot; f = open(path, \u0026quot;r\u0026quot;) secret = f.read() msg = \u0026quot;ConfigMap: %s\\nSecret: %s\u0026quot; % (config, secret) return msg, 200  Create an environment and a function:\n# create python env $ fission env create --name python --image fission/python-env # create function named \u0026quot;leaker\u0026quot; $ fission fn create --name leaker --env python --code leaker.py --secret my-secret --configmap my-configmap  Run the function, and the output should look like this:\n$ fission function test --name leaker ConfigMap: TESTVALUE Secret: TESTVALUE  If the Secret or ConfigMap value is updated, the function may not get the updated value for some time; it may get a cached older value.\n "
},
{
	"uri": "https://docs.fission.io/0.11.0/usage/",
	"title": "Using Fission",
	"tags": [],
	"description": "",
	"content": " Environments Functions Triggers Controlling Function Execution Packaging source code Accessing Secrets in Functions  "
},
{
	"uri": "https://docs.fission.io/0.11.0/usage/environments/",
	"title": "Environments",
	"tags": [],
	"description": "",
	"content": " Create an environment You can create an environment on your cluster from an image for that language.\nOptionally, you can specify CPU and memory resource limits. You can also specify the number of initially pre-warmed pods, which is called the poolsize.\n$ fission env create --name node --image fission/node-env --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 4  In case of the pool based executor, the resources specified for environment are used for function pod as well. In case of new deployment executor, you can override the resources when you create a function.\nUsing a builder When you create an environment, you can specify a builder image and builder command which will be used for building from source code. You can override the build command when creating a function. For more details on builder and packages, check out examples in Functions and packages.\n$ fission env create --name python --image fission/python-env:latest --builder fission/python-builder:latest  Viewing environment information You can list the environments or view information of an individual environment:\n$ fission env list NAME UID IMAGE POOLSIZE MINCPU MAXCPU MINMEMORY MAXMEMORY node ac84d62e-001f-11e8-85c9-42010aa00010 fission/node-env:0.4.0 4 40m 80m 64Mi 128Mi $ fission env get --name node NAME UID IMAGE node ac84d62e-001f-11e8-85c9-42010aa00010 fission/node-env:0.4.0 $ kubectl get environment.fission.io -o yaml # Full YAML of Fission environment object  "
},
{
	"uri": "https://docs.fission.io/0.11.0/usage/functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": " Create a function Before creating a function, you\u0026rsquo;ll need an environment; read environments if you haven\u0026rsquo;t already.\nLet\u0026rsquo;s create a simple code snippet in NodeJS which will output the string \u0026ldquo;Hello, world!\u0026rdquo;:\nmodule.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, world!\\n\u0026quot; }; }  Let\u0026rsquo;s create this function on the cluster. This only registers the function with Fission, it doesn\u0026rsquo;t run it yet.\n$ fission fn create --name hello --code hello.js --env node  Next, let\u0026rsquo;s create a route for the function which can be used for making HTTP requests:\n$ fission route create --function hello --url /hello trigger '5327e9a7-6d87-4533-a4fb-c67f55b1e492' created  When you hit this function\u0026rsquo;s URL, you get the expected response:\n$ curl http://${FISSION_ROUTER}/hello Hello, world!  You can also create a function with executor type \u0026ldquo;newdeploy\u0026rdquo; and provide the minimum and maximum number of instances of the function.\n$ fission fn create --name hello --code hello.js --env node --minscale 1 --maxscale 5 --executortype newdeploy  View \u0026amp; update function source code You can look at the source code associated with given function:\n$ fission fn get --name hello module.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, world!\\n\u0026quot; }; }  Let\u0026rsquo;s say you want to update the function to output \u0026ldquo;Hello Fission\u0026rdquo; instead of \u0026ldquo;Hello world\u0026rdquo;, you can update the source file and update the source code for function:\n$ fission fn update --name hello --code ../hello.js package 'hello-js-ku9s' updated function 'hello' updated  Let\u0026rsquo;s verify that the function now responds with a different output than it did earlier:\n$ curl http://${FISSION_ROUTER}/hello Hello, Fission!  Test and debug function You can run a function using the test command. If the function call succeeds, it will output the function\u0026rsquo;s response.\n$ fission fn test --name hello Hello, Fission!  But if there is an error in the function\u0026rsquo;s execution (it returns HTTP \u0026gt;= 300), then the logs of function execution are displayed:\n$ fission fn test --name hello Error calling function hello: 500 Internal server error (fission) \u0026gt; fission-nodejs-runtime@0.1.0 start /usr/src/app \u0026gt; node server.js Codepath defaulting to /userfunc/user Port defaulting to 8888 user code load error: SyntaxError: Unexpected token function ::ffff:10.8.1.181 - - [16/Feb/2018:08:44:33 +0000] \u0026quot;POST /specialize HTTP/1.1\u0026quot; 500 2 \u0026quot;-\u0026quot; \u0026quot;Go-http-client/1.1\u0026quot;  You can also look at function execution logs explicitly:\n$ fission fn logs --name hello [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 fetcher received fetch request and started downloading: {1 {hello-js-rqew default 0 0001-01-01 00:00:00 +0000 UTC \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; map[] map[] [] nil [] } user [] []} [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Successfully placed at /userfunc/user [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Checking secrets/cfgmaps [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 Completed fetch request [2018-02-16 08:41:43 +0000 UTC] 2018/02/16 08:41:43 elapsed time in fetch request = 89.844653ms [2018-02-16 08:41:43 +0000 UTC] user code loaded in 0sec 4.235593ms [2018-02-16 08:41:43 +0000 UTC] ::ffff:10.8.1.181 - - [16/Feb/2018:08:41:43 +0000] \u0026quot;POST /specialize HTTP/1.1\u0026quot; 202 - \u0026quot;-\u0026quot; \u0026quot;Go-http-client/1.1\u0026quot; [2018-02-16 08:41:43 +0000 UTC] ::ffff:10.8.1.182 - - [16/Feb/2018:08:41:43 +0000] \u0026quot;GET / HTTP/1.1\u0026quot; 200 16 \u0026quot;-\u0026quot; \u0026quot;curl/7.54.0\u0026quot;  Fission builds \u0026amp; compiled artifacts Most real world functions will require more than one source files. It is also easier to simply provide source files and let Fission take care of building from source files. Fission provides first class support for building from source as well as using compiled artifacts to create functions.\nYou can attach the source/deployment packages to a function or explicitly create packages and use them across functions. Check documentation for package for more information.\nBuilding functions from source Let\u0026rsquo;s take a simple python function which has dependency on a python pyyaml module. We can specify the dependencies in requirements.txt and a simple command to build from source. The tree structure of directory looks like:\nsourcepkg/ ├── __init__.py ├── build.sh ├── requirements.txt └── user.py  And the file contents:\n$ cat user.py import sys import yaml document = \u0026quot;\u0026quot;\u0026quot; a: 1 b: c: 3 d: 4 \u0026quot;\u0026quot;\u0026quot; def main(): return yaml.dump(yaml.load(document)) $ cat requirements.txt pyyaml $ cat build.sh #!/bin/sh pip3 install -r ${SRC_PKG}/requirements.txt -t ${SRC_PKG} \u0026amp;\u0026amp; cp -r ${SRC_PKG} ${DEPLOY_PKG}  You first need to create an environment with environment image and python-builder image specified:\n$ fission env create --name python --image fission/python-env:latest --builder fission/python-builder:latest --mincpu 40 --maxcpu 80 --minmemory 64 --maxmemory 128 --poolsize 2  Now let\u0026rsquo;s zip the directory containing the source files and create a function with source package:\n$ zip -jr demo-src-pkg.zip sourcepkg/ adding: __init__.py (stored 0%) adding: build.sh (deflated 24%) adding: requirements.txt (stored 0%) adding: user.py (deflated 25%) $ fission fn create --name hellopy --env python --src demo-src-pkg.zip --entrypoint \u0026quot;user.main\u0026quot; --buildcmd \u0026quot;./build.sh\u0026quot; function 'hellopy' created $ fission route create --function hellopy --url /hellopy  Once we create the function, the build process is started. You can check logs of the builder in fission-builder namespace:\n$ kubectl -n fission-builder logs -f py3-4214348-59555d9bd8-ks7m4 builder 2018/02/16 11:44:21 Builder received request: {demo-src-pkg-zip-ninf-djtswo ./build.sh} 2018/02/16 11:44:21 Starting build... === Build Logs ===command=./build.sh env=[PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=py3-4214348-59555d9bd8-ks7m4 PYTHON_4212095_PORT_8000_TCP_PROTO=tcp PY3_4214348_SERVICE_HOST=10.11.250.161 KUBERNETES_PORT=tcp://10.11.240.1:443 PYTHON_4212095_PORT=tcp://10.11.244.134:8000 PYTHON_4212095_PORT_8000_TCP=tcp://10.11.244.134:8000 PYTHON_4212095_PORT_8001_TCP_PROTO=tcp PYTHON_4212095_PORT_8001_TCP_ADDR=10.11.244.134 PY3_4214348_SERVICE_PORT=8000 PY3_4214348_SERVICE_PORT_BUILDER_PORT=8001 PY3_4214348_PORT_8001_TCP=tcp://10.11.250.161:8001 KUBERNETES_PORT_443_TCP_PORT=443 KUBERNETES_PORT_443_TCP_ADDR=10.11.240.1 PY3_4214348_SERVICE_PORT_FETCHER_PORT=8000 PY3_4214348_PORT_8000_TCP=tcp://10.11.250.161:8000 PY3_4214348_PORT_8001_TCP_PORT=8001 PYTHON_4212095_SERVICE_PORT_FETCHER_PORT=8000 PYTHON_4212095_PORT_8000_TCP_ADDR=10.11.244.134 KUBERNETES_SERVICE_HOST=10.11.240.1 PY3_4214348_PORT=tcp://10.11.250.161:8000 PYTHON_4212095_SERVICE_PORT_BUILDER_PORT=8001 PYTHON_4212095_PORT_8001_TCP=tcp://10.11.244.134:8001 PY3_4214348_PORT_8000_TCP_PROTO=tcp PY3_4214348_PORT_8000_TCP_PORT=8000 KUBERNETES_SERVICE_PORT_HTTPS=443 KUBERNETES_PORT_443_TCP=tcp://10.11.240.1:443 PYTHON_4212095_PORT_8001_TCP_PORT=8001 PY3_4214348_PORT_8000_TCP_ADDR=10.11.250.161 PY3_4214348_PORT_8001_TCP_PROTO=tcp KUBERNETES_SERVICE_PORT=443 PYTHON_4212095_SERVICE_PORT=8000 PYTHON_4212095_PORT_8000_TCP_PORT=8000 PY3_4214348_PORT_8001_TCP_ADDR=10.11.250.161 KUBERNETES_PORT_443_TCP_PROTO=tcp PYTHON_4212095_SERVICE_HOST=10.11.244.134 HOME=/root SRC_PKG=/packages/demo-src-pkg-zip-ninf-djtswo DEPLOY_PKG=/packages/demo-src-pkg-zip-ninf-djtswo-c40gfu] Collecting pyyaml (from -r /packages/demo-src-pkg-zip-ninf-djtswo/requirements.txt (line 1)) Downloading PyYAML-3.12.tar.gz (253kB) Installing collected packages: pyyaml Running setup.py install for pyyaml: started Running setup.py install for pyyaml: finished with status 'done' Successfully installed pyyaml-3.12 ================== 2018/02/16 11:44:24 elapsed time in build request = 3.460498847s  Once the build has succeeded, you can hit the function URL to test the function:\n$curl http://$FISSION_ROUTER/hellopy a: 1 b: {c: 3, d: 4}  If you\u0026rsquo;re using Fission with source code, be sure to read about the recommended development workflow.\nUsing compiled artifacts with Fission In some cases you have a pre-built deployment package which you need to deploy to Fission. For this example let\u0026rsquo;s use a simple python file as a deployment package but in practice it can be any other compiled package.\nWe will use a simple python file in a directory and turn it into a deployment package:\n$ cat testDir/hello.py def main(): return \u0026quot;Hello, world!\u0026quot; $zip -jr demo-deploy-pkg.zip testDir/  Let\u0026rsquo;s use the deployment package to create a function and route and then test it.\n$ fission fn create --name hellopy --env python --deploy demo-deploy-pkg.zip --entrypoint \u0026quot;hello.main\u0026quot; function 'hellopy' created $ fission route create --function hellopy --url /hellopy $ curl http://$FISSION_ROUTER/hellopy Hello, world!  View function information You can retrieve metadata information of a single function or list all functions to look at basic information of functions:\n$ fission fn getmeta --name hello NAME UID ENV hello 34234b50-12f5-11e8-85c9-42010aa00010 node $ fission fn list NAME UID ENV EXECUTORTYPE MINSCALE MAXSCALE TARGETCPU hello 34234b50-12f5-11e8-85c9-42010aa00010 node poolmgr 0 1 80 hello2 e37a46e3-12f4-11e8-85c9-42010aa00010 node newdeploy 1 5 80  "
},
{
	"uri": "https://docs.fission.io/0.11.0/usage/trigger/",
	"title": "Triggers",
	"tags": [],
	"description": "",
	"content": " Create a HTTP Trigger An HTTP trigger invokes a function when there is an HTTP request.\nYou can specify the relative URL and HTTP method for a trigger:\n$ fission httptrigger create --url /hello --method GET --function hello trigger '94cd5163-30dd-4fb2-ab3c-794052f70841' created $ curl http://$FISSION_ROUTER/hello Hello World!  FISSION_ROUTER is the externally-visible address of your Fission router service. For how to set up environment variable FISSION_ROUTER, see here\n If you want to use Kubernetes Ingress for the HTTP Trigger, you can provide the --createingress flag and a hostname. If the hostname is not provided, it defaults to \u0026ldquo;*\u0026ldquo;, which indicates a wildcard host.\n$ fission httptrigger create --url /hello --method GET --function hello --createingress --host acme.com trigger '94cd5163-30dd-4fb2-ab3c-794052f70841' created $ fission route list NAME METHOD HOST URL INGRESS FUNCTION_NAME 94cd5163-30dd-4fb2-ab3c-794052f70841 GET acme.com /hello true hello  Please note that for ingress to work, you will have to deploy an ingress controller in Kubernetes cluster. Kubernetes currently supports and maintains the following ingress controllers:\n Nginx Ingress Controller GCE Ingress Controller  Other Ingress controllers exist, such as F5 networks and Kong.\nCreate a Time Trigger Time-based triggers invoke functions based on time. They can run once or repeatedly. They\u0026rsquo;re specified using cron string specifications:\n$ fission tt create --name halfhourly --function hello --cron \u0026quot;*/30 * * * *\u0026quot; trigger 'halfhourly' created  You can also use a friendlier syntax such \u0026ldquo;@every 1m\u0026rdquo; or \u0026ldquo;@hourly\u0026rdquo;:\n$ fission tt create --name minute --function hello --cron \u0026quot;@every 1m\u0026quot; trigger 'minute' created  And you can list time triggers to see their associated function and cron strings:\n$ fission tt list NAME CRON FUNCTION_NAME halfhourly 0 30 * * * * hello minute @every 1m hello  You can also use showschedule to show the upcoming schedule for a given cron spec. Use this to test your cron strings. And note that the server\u0026rsquo;s time is used to invoke functions, not your laptop\u0026rsquo;s time!\n$ fission tt showschedule --cron \u0026quot;0 30 * * * *\u0026quot; --round 5 Current Server Time: 2018-06-12T05:07:41Z Next 1 invocation: 2018-06-12T05:30:00Z Next 2 invocation: 2018-06-12T06:30:00Z Next 3 invocation: 2018-06-12T07:30:00Z Next 4 invocation: 2018-06-12T08:30:00Z Next 5 invocation: 2018-06-12T09:30:00Z  Create a Message Queue Trigger A message queue trigger invokes a function based on messages from an message queue. Optionally, it can place the response of a function onto another queue.\nNATS and Azure Storage Queue are supported queues:\n$ fission mqt create --name hellomsg --function hello --mqtype nats-streaming --topic newfile --resptopic newfileresponse trigger 'hellomsg' created  You can list or update message queue triggers with fission mqt list, or fission mqt update.\n"
},
{
	"uri": "https://docs.fission.io/0.11.0/usage/executor/",
	"title": "Controlling Function Execution",
	"tags": [],
	"description": "",
	"content": " Autoscaling Let\u0026rsquo;s create a function to demonstrate the autoscaling behaviour in Fission. We create a simple function which outputs \u0026ldquo;Hello World\u0026rdquo; in using NodeJS. We have kept the CPU request and limit purposefully low to simulate the load and also kept the target CPU percent to 50%.\n$ fission fn create --name hello --env node --code hello.js --minmemory 64 --maxmemory 128 --minscale 1 --maxscale 6 --executortype newdeploy --targetcpu 50 function 'hello' created  Now let\u0026rsquo;s use hey to generate the load with 250 concurrent and a total of 10000 requests:\n$ hey -c 250 -n 10000 http://${FISSION_ROUTER}/hello Summary: Total:\t67.3535 secs Slowest:\t4.6192 secs Fastest:\t0.0177 secs Average:\t1.6464 secs Requests/sec:\t148.4704 Total data:\t160000 bytes Size/request:\t16 bytes Response time histogram: 0.018 [1]\t| 0.478 [486]\t|∎∎∎∎∎∎∎ 0.938 [971]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 1.398 [2686]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 1.858 [2326]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 2.318 [1641]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 2.779 [1157]\t|∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎ 3.239 [574]\t|∎∎∎∎∎∎∎∎∎ 3.699 [120]\t|∎∎ 4.159 [0]\t| 4.619 [38]\t|∎ Latency distribution: 10% in 0.7037 secs 25% in 1.1979 secs 50% in 1.5038 secs 75% in 2.1959 secs 90% in 2.6670 secs 95% in 2.8855 secs 99% in 3.4102 secs Details (average, fastest, slowest): DNS+dialup:\t0.0058 secs, 0.0000 secs, 1.0853 secs DNS-lookup:\t0.0000 secs, 0.0000 secs, 0.0000 secs req write:\t0.0000 secs, 0.0000 secs, 0.0026 secs resp wait:\t1.6405 secs, 0.0176 secs, 3.6144 secs resp read:\t0.0001 secs, 0.0000 secs, 0.0056 secs Status code distribution: [200]\t10000 responses  While the load is being generated, we will watch the HorizontalPodAutoscaler and how it scales over period of time. As you can notice, the number of pods is scaled from 1 to 3 after the load rises from 8 - 103%. After the load generator stops, it takes a few iterations to scale down from 3 to 1 pod.\nWhen testing the scaling behaviour, do keep in mind that the scaling event has an initial delay of uptp a minute and waits for the average CPU to reach 110% above the threshold before scaling up. It is best to maintain a minimum number of pods which can handle initial load and scale as needed.\nYou will notice that the scaling up and down has different behaviour in terms of response time. This behaviour is governed by the frequency at which the controller watches (which defaults to 30s) and parameters set on controller-manager for upscale/downscale delay. More details can be found here\n$ kubectl -n fission-function get hpa -w NAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGE hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 1 3m hello-qoxmothj Deployment/hello-qoxmothj 8% / 50% 1 6 1 3m hello-qoxmothj Deployment/hello-qoxmothj 103% / 50% 1 6 1 4m hello-qoxmothj Deployment/hello-qoxmothj 103% / 50% 1 6 3 5m hello-qoxmothj Deployment/hello-qoxmothj 25% / 50% 1 6 3 5m hello-qoxmothj Deployment/hello-qoxmothj 25% / 50% 1 6 3 6m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 6m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 7m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 7m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 8m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 8m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 9m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 9m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 10m hello-qoxmothj Deployment/hello-qoxmothj 5% / 50% 1 6 3 10m hello-qoxmothj Deployment/hello-qoxmothj 7% / 50% 1 6 1 11m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 11m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 12m hello-qoxmothj Deployment/hello-qoxmothj 6% / 50% 1 6 1 12m  "
},
{
	"uri": "https://docs.fission.io/0.11.0/installation/env_vars/",
	"title": "Environment Variables",
	"tags": [],
	"description": "",
	"content": " Namespace Set FISSION_NAMESPACE to the namespace where the Fission is installed. You don\u0026rsquo;t have to set this unless there are multiple Fission installations in different namespaces within the same Kubernetes cluster.\n$ export FISSION_NAMESPACE \u0026lt;namespace\u0026gt;  Fission Router Address It\u0026rsquo;s convenient to set the FISSION_ROUTER environment variable to the externally-visible address of the Fission router.\nMinikube If you\u0026rsquo;re using minikube, use these commands:\n$ export FISSION_ROUTER=$(minikube ip):$(kubectl -n fission get svc router -o jsonpath='{...nodePort}')  Cloud Provider If you want to expose the router to the internet, the service type of router service must be set to LoadBalancer. This is the default in the helm chart.\n$ kubectl --namespace fission get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE router LoadBalancer 10.107.80.21 \u0026lt;pending\u0026gt; 80:31314/TCP 11d  If the field EXTERNAL-IP shows \u0026lt;pending\u0026gt;, it means that kubernetes is waiting for cloud provider to allocate the public IP address. It often takes a few minutes to get an IP address. Then:\n# AWS $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..hostname}') # GCP $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..ip}')  Using FISSION_ROUTER env var $ curl http://${FISSION_ROUTER}/\u0026lt;url-path\u0026gt;  Troubleshooting If your cluster is running in an environment that does not support external load balancer (e.g., minikube), the EXTERNAL-IP of fission router will stay in pending state.\n$ kubectl --namespace fission get svc router NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE router LoadBalancer 10.39.253.73 \u0026lt;pending\u0026gt; 80:31377/TCP 27d  In this case, you can use the port-forward method instead:\n# Port-forward $ kubectl --namespace fission port-forward $(kubectl --namespace fission get pod -l svc=router -o name) \u0026lt;local port\u0026gt;:80 \u0026amp; $ export FISSION_ROUTER=127.0.0.1:\u0026lt;local port\u0026gt;  Now, curl http://${FISSION_ROUTER}/ will open a connection that goes through the port forward you just created. This is useful for local testing of your function.\n"
},
{
	"uri": "https://docs.fission.io/0.11.0/usage/developer-workflow/",
	"title": "Source Code Organization and Your Development Workflow",
	"tags": [],
	"description": "",
	"content": " You\u0026rsquo;ve made a Hello World function in your favourite language, and you\u0026rsquo;ve run it on your Fission deployment. What\u0026rsquo;s next?\nHow should you organize source code when you have lots of functions? How should you automate deployment into the cluster? What about version control? How do you test before deploying?\nThe answers to these questions start from a common first step: how do you specify an application?\nDeclarative Specifications Instead of invoking the Fission CLI commands, you can specify your functions in a set of YAML files. This is better than scripting the fission CLI, which is meant as a user interface, not a programming interface.\nYou\u0026rsquo;ll usually want to track these YAML files in version control along with your source code. Fission provides CLI tools for generating these specification files, validating them, and \u0026ldquo;applying\u0026rdquo; them to a Fission installation.\nWhat does it mean to apply a specification? It means putting specification to effect: figuring out the things that need to be changed on the cluster, and updating them to make them the same as the specification.\nApplying a Fission spec goes through these steps:\n Resources (functions, triggers, etc) that are in the specification but don\u0026rsquo;t exist on the cluster are created. Local source files are packaged and uploaded.\n Resources that are both in the specs and on the cluster are compared. If they\u0026rsquo;re different, the ones on the cluster are changed to match the spec.\n Resources present only on the cluster and not in the spec are destroyed. (This deletion is limited to resources that were created by a previous apply; this makes sure that Fission doesn\u0026rsquo;t delete unrelated resources. See below for how this calculation works.)\n  Note that running apply more than once is equivalent to running it once: in other words, it\u0026rsquo;s idempotent.\nUsage Summary Start using Fission\u0026rsquo;s declarative application specifications in 3 steps:\n Initialize a directory of specs: fission spec init Generate some YAMLs: fission function create --spec ... Apply them to a cluster: fission spec apply --wait  You can also deploy continuously with fission spec apply --watch.\nWe\u0026rsquo;ll see examples of all these commands in the tutorial below.\nTutorial This tutorial assumes you\u0026rsquo;ve already set up Fission, and tested a simple hello world function to make sure everything\u0026rsquo;s working. To learn how to do that, head over to the installation guide.\nWe\u0026rsquo;ll make a small calculator app with one python environment and two functions, all of which will be declaratively specified using YAML files. This is a somewhat contrived example, but it is just meant as an illustration.\nMake an empty directory mkdir spec-tutorial cd spec-tutorial  Initialize the specs directory fission spec init  This creates a specs/ directory. You\u0026rsquo;ll see a fission-config.yaml in there. This file has a unique ID in it; everything created on the cluster from these specs will be annotated with that unique ID.\nSetup a Python environment fission env create --spec --name python --image fission/python-env:0.11.0 --builder fission/python-builder:0.11.0  This command creates a YAML file under specs called specs/env-python.yaml.\nCode two functions One function simply returns a simple web form. You can download the code or copy paste from the contents below:\n curl -Lo form.py http://xxx  Here are its contents:\ndef main(): return \u0026quot;\u0026quot;\u0026quot; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026quot;/calculate\u0026quot; method=\u0026quot;GET\u0026quot;\u0026gt; \u0026lt;input name=\u0026quot;num_1\u0026quot;/\u0026gt; \u0026lt;input name=\u0026quot;num_2\u0026quot;/\u0026gt; \u0026lt;input name=\u0026quot;operator\u0026quot;/\u0026gt; \u0026lt;button\u0026gt;Calculate\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026quot;\u0026quot;\u0026quot;  The form accepts a simple arithmetic expression. When it is submitted, it makes a request to the second function, which calculates the expression entered.\nHere\u0026rsquo;s the calculator function:\n curl -Lo calc.py http://yyy  That function is pretty simple too:\ndef main(): num_1 = int(request.form['num_1']) num_2 = int(request.form['num_2']) operator = request.form['operator'] if operator == '+': result = num_1 + num_2 elsif operator == '-': result = num_1 - num_2 return \u0026quot;%s %s %s = %s\u0026quot; % (num_1, operator, num_2, result)  Create specs for these functions Let\u0026rsquo;s create a specification for each of these functions. This specifies the function name, where the code lives, and associates the function with the python environment:\nfission function create --spec --name calc-form --env python --src form.py --entrypoint form.main fission function create --spec --name calc-eval --env python --src calc.py --entrypoint calc.main  You can see the generated YAML files in specs/function-calc-form.yaml and specs/function-calc-eval.yaml.\nCreate HTTP trigger specs fission route create --spec --method GET --url /form --function calc-form fission route create --spec --method GET --url /eval --function calc-eval  This creates YAML files specifying that GET requests on /form and /eval invoke the functions calc-form and calc-eval respectively.\nValidate your specs Spec validation does some basic checks: it makes sure there are no duplicate functions with the same name, and that references between various resources are correct.\nfission spec validate  You should see no errors.\nApply: deploy your functions to Fission You can simply use apply to deploy the environment, functions and HTTP triggers to the cluster.\nfission spec apply --wait  (This uses your kubeconfig to connect to Fission, just like kubectl. See Usage Reference below for options.)\nTest a function Make sure your function is working:\nfission function test --name calc-form  You should see the output of the calc-form function.\nTo test the other function, open the URL of the Fission router service in a browser, enter two numbers and an operator, and click submit.\n(If you don\u0026rsquo;t know the address of the Fission router, you can find it with kubectl: kubectl -n fission get service router.)\nModify the function and re-deploy it Let\u0026rsquo;s try modifying a function: let\u0026rsquo;s change the calc-eval function to support multiplication, too.\n ... elsif operator == '*': result = num_1 * num_2 ...  You can add the above lines to calc.py, or just download the modified function:\ncurl -Lo calc.py http://zzz  To deploy your changes, simply apply the specs again:\nfission spec apply --wait  This should output something like:\n1 archive updated: calc-eval-xyz 1 package updated: calc-eval-xyz 1 function updated: calc-eval  Your new updated function is deployed!\nTest it out by entering a * for the operator in the form!\nAdd dependencies to the function Let\u0026rsquo;s say you\u0026rsquo;d like to add a pip requirements.txt to your function, and include some libraries in it, so you can import them in your functions.\nCreate a requirements.txt, and add something to it:\nxxx  Modify the ArchiveUploadSpec inside specs/function-.yaml\nOnce again, deploying is the same:\nfission spec apply --wait  This command figures out that one function has changed, uploads the source to the cluster, and waits until the Fission builder on the cluster finishes rebuilding this updated source code.\nA bit about how this works Kubernetes manages its state as a set of resources. Deployments, Pod, Services are examples of resources. They represent a target state, and Kubernetes then does the work to ensure this target state is met.\nKubernetes resources can be extended, using Custom Resources. Fission runs on top of Kubernetes and sets up your functions, environments and triggers as Custom Resources. You can see even these custom resources from kubectl: try kubectl get customeresourcedefinitions or kubectl get function.fission.io\nYour specs directory is, basically, set of resources plus a bit of configuration. Each YAML file contains one or more resources. They are separated by a \u0026ldquo;\u0026mdash;\u0026rdquo; separator. The resources are functions, environments, triggers.\nThere\u0026rsquo;s a special resource there, ArchiveUploadSpec. This is in fact not a resource, just looks like one in the YAML files. It is used to specify and name a set of files that will be uploaded to the cluster. fission spec apply uses these ArchiveUploadSpecs to create archives locally and upload them. The specs reference these archives using archive:// URLs. These aren\u0026rsquo;t \u0026ldquo;real\u0026rdquo; URLs; they are replaced by http URLs by the fission spec implementation after the archives are uploaded to the cluster. On the cluster, Archives are tracked with checksums; the Fission CLI only uploads archives when their checksum has changed.\nUsage Reference NAME: fission spec - Manage a declarative app specification USAGE: fission spec command [command options] [arguments...] COMMANDS: init Create an initial declarative app specification validate Validate Fission app specification apply Create, update, or delete Fission resources from app specification destroy Delete all Fission resources in the app specification helm Create a helm chart from the app specification OPTIONS: --help, -h show help  fission spec init NAME: fission spec init - Create an initial declarative app specification USAGE: fission spec init [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs --name value (optional) Name for the app, applied to resources as a Kubernetes annotation  fission spec validate NAME: fission spec validate - Validate Fission app specification USAGE: fission spec validate [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs  fission spec apply NAME: fission spec apply - Create, update, or delete Fission resources from app specification USAGE: fission spec apply [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs --delete Allow apply to delete resources that no longer exist in the specification --wait Wait for package builds --watch Watch local files for change, and re-apply specs as necessary  fission spec destroy NAME: fission spec destroy - Delete all Fission resources in the app specification USAGE: fission spec destroy [command options] [arguments...] OPTIONS: --specdir value Directory to store specs, defaults to ./specs  "
},
{
	"uri": "https://docs.fission.io/0.11.0/usage/ingress-tutorial/",
	"title": "Exposing functions with Ingress",
	"tags": [],
	"description": "",
	"content": " This tutorial will walk you through exposing a function using an ingress controller (You can read more about ingress and ingress controller here). We will make the function available on a fully qualified domain name (FQDN) using Fission\u0026rsquo;s route and ingress controller setup in a cloud environment.\nSetup \u0026amp; pre-requisites You will need a Kubernetes cluster with Fission installed (Please check installation page for details). This tutorial uses a cloud load balancer, but if you are using Minikube you might want to take a look at details here\nLater parts of this tutorial use a FQDN to reach the function. If you plan to go along in this section, you will need a domain name setup and access to modify the NS records and create A record in the zone of the domain name you have. The tutorial uses Google cloud to walk through the tutorial but you can use any cloud you prefer to. Also the changes in name server can take 24-48 hours so you may want to use an already created domain name.\nSetup an Ingress Controller First thing we will need is an ingress controller and we will use Nginx ingress controller in this tutorial. Based on your setup you can choose one of the multiple ways to install Nginx ingress controller. This setup should work with other ingress controllers also but has not been tested.\nLet\u0026rsquo;s verify that the installation succeeded:\nkubectl get all -n ingress-nginx NAME READY STATUS RESTARTS AGE po/default-http-backend-66b447d9cf-4q8f7 1/1 Running 0 19d po/nginx-ingress-controller-58fcfdc6fd-2cwts 1/1 Running 0 19d NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE svc/default-http-backend 10.11.243.109 \u0026lt;none\u0026gt; 80/TCP 19d svc/ingress-nginx 10.11.245.254 35.200.150.175 80:31000/TCP,443:30666/TCP 19d NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deploy/default-http-backend 1 1 1 1 19d deploy/nginx-ingress-controller 1 1 1 1 19d NAME DESIRED CURRENT READY AGE rs/default-http-backend-66b447d9cf 1 1 1 19d rs/nginx-ingress-controller-58fcfdc6fd 1 1 1 19d  Following are key points to validate that ingress controller installation succeeded (Please refer to output of a successful installation above)\n The ingress controller pod is up and running The ingress-nginx service has a external IP address populated If you hit the external IP address of the ingress-nginx, you get the default backend page:  curl http://35.200.150.175 default backend - 404  Deploying Function with ingress An ingress resource allows traffic from outside the cluster to reach the services inside the cluster. The ingress is fulfilled by an ingress controller. In following sections we will create a function and enable traffic outside the cluster to reach the function.\nCreate a function We will create an environment, a function and test that it works:\n$ fission env create --name nodejs --image fission/node-env environment 'nodejs' created $ cat hello.js module.exports = async function(context) { return { status: 200, body: \u0026quot;Hello, Fission!\\n\u0026quot; }; } $ fission fn create --name hello --env nodejs --code hello.js function 'hello' created $ fission fn test --name hello Hello, Fission!  Create a internal route Let\u0026rsquo;s create a route which is not exposed via the ingress controller so that it can be consumed by resources inside the cluster only.\nCurrently since functions are also exposed via the Fission router, the function can be accessed from outside the cluster but in future the router may not expose all functions outside the cluster.\n$ fission route create --url /ihello --function hello trigger '249838c9-9ae3-492a-bba1-b0464ae65671' created $ fission route list NAME METHOD HOST URL INGRESS FUNCTION_NAME 249838c9-9ae3-492a-bba1-b0464ae65671 GET /ihello false hello  This route will be accessible at http://$FISSION_ROUTER/ihello but if tried to access on the ingress controller address http://\u0026lt;INGRESS-CONTROLLER-EXTERNAL-IP\u0026gt;/ihello you will get a default backend page. This is expected result as we did not create an ingress for this route.\nCreate a external route Now let\u0026rsquo;s create a route which we will expose over ingress controller. We will create a route with createingress flag enabled:\n$ fission route create --url /hello --function hello --createingress trigger '301b3cb0-5ac1-4211-a1ed-2b0ad9143e34' created $ $ fission route list NAME METHOD HOST URL INGRESS FUNCTION_NAME 249838c9-9ae3-492a-bba1-b0464ae65671 GET /ihello false hello 301b3cb0-5ac1-4211-a1ed-2b0ad9143e34 GET /hello true hello $  If you check the ingress controller pod logs, you will notice that the ingress controller has re-loaded the configuration for the newly created ingress resource:\nI0604 12:47:08.983567 5 controller.go:168] backend reload required I0604 12:47:08.985535 5 event.go:218] Event(v1.ObjectReference{Kind:\u0026quot;Ingress\u0026quot;, Namespace:\u0026quot;fission\u0026quot;, Name:\u0026quot;301b3cb0-5ac1-4211-a1ed-2b0ad9143e34\u0026quot;, UID:\u0026quot;64bffe8c-67f5-11e8-98e8-42010aa00018\u0026quot;, APIVersion:\u0026quot;extensions\u0026quot;, ResourceVersion:\u0026quot;18017617\u0026quot;, FieldPath:\u0026quot;\u0026quot;}): type: 'Normal' reason: 'CREATE' Ingress fission/301b3cb0-5ac1-4211-a1ed-2b0ad9143e34 I0604 12:47:09.117629 5 controller.go:177] ingress backend successfully reloaded...  If you now hit the function at ingress controller\u0026rsquo;s IP and the path (http://\u0026lt;INGRESS-CONTROLLER-EXTERNAL-IP\u0026gt;/hello), you will get function\u0026rsquo;s response. Depending on your setup and settings, you will have to try HTTP or HTTPS. Some ingress controllers enable SSL redirect by default and hence the HTTPS URL has to be accessed.\n$ curl -k https://35.200.150.175/hello Hello, Fission!  Create a FQDN route This is an optional step and pre-requisites should be fulfilled before proceeding. You can map the FQDN to function if you have DNS setup and access. You need to do a few steps:\n Map the domain name\u0026rsquo;s name server to your cloud provider. For example we used domain name fission.sh and mapped the name server to google cloud (Since this tutorial setup is on Google cloud). The instructions are specific to your domain name provider, please check the documentation of the provider.\n Create a zone for the root domain in the cloud provider (Created a zone for fission.sh in google cloud)\n Create a sub-domain A record that maps to the IP address of Ingress Controller load balancer. In this tutorial we created a A record in the zone above for ing.fission.sh and pointed to the IP of ingress controller load balancer i.e. 35.200.150.175 (A records can take 30 minutes to 4 hours to update)\n If all these steps are configured properly, we can hit the function at FQDN like below:\n  $ curl -k https://ing.fission.sh/hello Hello, Fission!  "
},
{
	"uri": "https://docs.fission.io/0.11.0/contributing/",
	"title": "Contributing to Fission",
	"tags": [],
	"description": "",
	"content": " Compiling Fission  "
},
{
	"uri": "https://docs.fission.io/0.11.0/contributing/compiling/",
	"title": "Compiling Fission",
	"tags": [],
	"description": "",
	"content": "You only need to do this if you\u0026rsquo;re making Fission changes; if you\u0026rsquo;re just deploying Fission, use fission.yaml which points to prebuilt images.\n You\u0026rsquo;ll need the go compiler and tools installed, along with the glide dependency management tool. You\u0026rsquo;ll also need docker for building images.\nThe server side is compiled as one binary (\u0026ldquo;fission-bundle\u0026rdquo;) which contains controller, poolmgr and router; it invokes the right one based on command-line arguments.\nTo build fission-bundle: clone this repo to $GOPATH/src/github.com/fission/fission, then from the top level directory (if you want to build the image with the docker inside minikube, you\u0026rsquo;ll need to set the proper environment variables with eval $(minikube docker-env)):\n # Get dependencies $ glide install # Build fission server and an image $ pushd fission-bundle $ ./build.sh  You now need to build the docker image for fission. You can use push.sh and push it to a docker hub account. But it\u0026rsquo;s easiest to use minikube and its built-in docker daemon:\n $ eval $(minikube docker-env) $ docker build -t minikube/fission-bundle .  Next, install fission with this image on your kubernetes cluster using the helm chart:\n $ helm install --set \u0026quot;image=minikube/fission-bundle,pullPolicy=IfNotPresent,analytics=false\u0026quot; charts/fission-all  And if you\u0026rsquo;re changing the CLI too, you can build it with:\n # Build Fission CLI $ cd fission \u0026amp;\u0026amp; go install  "
},
{
	"uri": "https://docs.fission.io/0.11.0/tutorial/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": " Enabling Istio on Fission Building Java Functions  "
},
{
	"uri": "https://docs.fission.io/0.11.0/tutorial/enabling-istio-on-fission/",
	"title": "Enabling Istio on Fission",
	"tags": [],
	"description": "",
	"content": " This is the very first step for fission to integrate with Istio. For those interested in trying to integrate fission with istio, following is the set up tutorial.\nTest Environment  Google Kubernetes Engine: 1.9.2-gke.1  Set Up Create Kubernetes v1.9+ cluster Enable both RBAC \u0026amp; initializer features on kubernetes cluster.\n$ export ZONE=\u0026lt;zone name\u0026gt; $ gcloud container clusters create istio-demo-1 \\ --machine-type=n1-standard-2 \\ --num-nodes=1 \\ --no-enable-legacy-authorization \\ --zone=$ZONE \\ --cluster-version=1.9.2-gke.1  Grant cluster admin permissions Grant admin permission for system:serviceaccount:kube-system:default and current user.\n# for system:serviceaccount:kube-system:default $ kubectl create clusterrolebinding --user system:serviceaccount:kube-system:default kube-system-cluster-admin --clusterrole cluster-admin # for current user $ kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value core/account)  Set up Istio environment For Istio 0.5.1 you can follow the installation tutorial below. Also, you can follow the latest installation guides on Istio official site: Quick Start and Sidecar Injection.\nDownload Istio 0.5.1\n$ export ISTIO_VERSION=0.5.1 $ curl -L https://git.io/getLatestIstio | sh - $ cd istio-0.5.1  Apply istio related YAML files\n$ kubectl apply -f install/kubernetes/istio.yaml  Automatic sidecar injection\n$ kubectl api-versions | grep admissionregistration admissionregistration.k8s.io/v1beta1  Installing the webhook\nDownload the missing files in istio release 0.5.1\n$ wget https://raw.githubusercontent.com/istio/istio/master/install/kubernetes/webhook-create-signed-cert.sh -P install/kubernetes/ $ wget https://raw.githubusercontent.com/istio/istio/master/install/kubernetes/webhook-patch-ca-bundle.sh -P install/kubernetes/ $ chmod +x install/kubernetes/webhook-create-signed-cert.sh install/kubernetes/webhook-patch-ca-bundle.sh  Install the sidecar injection configmap.\n$ ./install/kubernetes/webhook-create-signed-cert.sh \\ --service istio-sidecar-injector \\ --namespace istio-system \\ --secret sidecar-injector-certs $ kubectl apply -f install/kubernetes/istio-sidecar-injector-configmap-release.yaml  Install the sidecar injector\n$ cat install/kubernetes/istio-sidecar-injector.yaml | \\ ./install/kubernetes/webhook-patch-ca-bundle.sh \u0026gt; \\ install/kubernetes/istio-sidecar-injector-with-ca-bundle.yaml $ kubectl apply -f install/kubernetes/istio-sidecar-injector-with-ca-bundle.yaml # Check sidecar injector status $ kubectl -n istio-system get deployment -listio=sidecar-injector NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE istio-sidecar-injector 1 1 1 1 26s  Install fission Set default namespace for helm installation, here we use fission as example namespace.\n$ export FISSION_NAMESPACE=fission  Create namespace \u0026amp; add label for Istio sidecar injection.\n$ kubectl create namespace $FISSION_NAMESPACE $ kubectl label namespace $FISSION_NAMESPACE istio-injection=enabled $ kubectl config set-context $(kubectl config current-context) --namespace=$FISSION_NAMESPACE  Follow the installation guide to install fission with flag enableIstio true.\n$ helm install --namespace $FISSION_NAMESPACE --set enableIstio=true --name istio-demo \u0026lt;chart-fission-all-url\u0026gt;  Create a function Set environment\n$ export FISSION_URL=http://$(kubectl --namespace fission get svc controller -o=jsonpath='{..ip}') $ export FISSION_ROUTER=$(kubectl --namespace fission get svc router -o=jsonpath='{..ip}')  Let\u0026rsquo;s create a simple function with Node.js.\n# hello.js module.exports = async function(context) { console.log(context.request.headers); return { status: 200, body: \u0026quot;Hello, World!\\n\u0026quot; }; }  Create environment\n$ fission env create --name nodejs --image fission/node-env:latest  Create function\n$ fission fn create --name h1 --env nodejs --code hello.js --method GET  Create route\n$ fission route create --method GET --url /h1 --function h1  Access function\n$ curl http://$FISSION_ROUTER/h1 Hello, World!  Install Istio Add-ons  Prometheus  $ kubectl apply -f istio-0.5.1/install/kubernetes/addons/prometheus.yaml $ kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=prometheus -o jsonpath='{.items[0].metadata.name}') 9090:9090  Web Link: http://127.0.0.1:9090/graph\n Grafana  Please install Prometheus first.\n$ kubectl apply -f istio-0.5.1/install/kubernetes/addons/grafana.yaml $ kubectl -n istio-system port-forward $(kubectl -n istio-system get pod -l app=grafana -o jsonpath='{.items[0].metadata.name}') 3000:3000  Web Link: http://127.0.0.1:3000/dashboard/db/istio-dashboard\n Jaegar  $ kubectl apply -n istio-system -f https://raw.githubusercontent.com/jaegertracing/jaeger-kubernetes/master/all-in-one/jaeger-all-in-one-template.yml $ kubectl port-forward -n istio-system $(kubectl get pod -n istio-system -l app=jaeger -o jsonpath='{.items[0].metadata.name}') 16686:16686  Web Link: http://localhost:16686\n"
},
{
	"uri": "https://docs.fission.io/0.11.0/tutorial/java-example/",
	"title": "Building Java Functions",
	"tags": [],
	"description": "",
	"content": " With the JVM environment there is now support to use Java functions in Fission. This tutorial explains about the working and some inner details of the way Java functions work in Fission.\nTo see this Java support in action, we are going to build a simple \u0026ldquo;Hello World\u0026rdquo; function with the JVM environment. This example can also be found in examples directory on GitHub.\nJVM Environment The JVM environment in Fission is based on Spring boot and Spring web frameworks. Spring boot \u0026amp; web is already loaded in JVM and if you are using this dependency, you can mark it at provided scope. The environment loads the function code from JAR file during specialization and then executes it.\nFission contract A function needs to implement the io.fission.Function class and override the call method. The call method receives the RequestEntity and Context as inputs and needs to return ResponseEntity object. Both RequestEntity and ResponseEntity are from org.springframework.http package and provide a fairly high level and rich API to interact with request and response.\nResponseEntity call(RequestEntity req, Context context);  The Context object is a placeholder to interact with the platform and provide information about the platform to the code. This also is a extension mechanism to provide more information to runtime code in future.\nBuilding a function Source code \u0026amp; test The function code responds with \u0026ldquo;Hello World\u0026rdquo; in response body.\npublic class HelloWorld implements Function { @Override public ResponseEntity\u0026lt;?\u0026gt; call(RequestEntity req, Context context) { return ResponseEntity.ok(\u0026quot;Hello World!\u0026quot;); } }  Project \u0026amp; dependencies with Maven First you have to define the the basic information about the function:\n\t\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;io.fission\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hello-world\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;JAR\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;hello-world\u0026lt;/name\u0026gt;  You will have to add two dependencies which are provided by the function runtime, so both them of scope as provided.\n\t\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.fission\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fission-java-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.2-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;  One of the key things when packaging the Java function is to package it as a uber/fat JAR so that the class and all other dependencies are packaged with function. For that you can use maven-assembly-plugin:\n\u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;make-assembly\u0026lt;/id\u0026gt; \u0026lt;!-- this is used for inheritance merges --\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;!-- bind to the packaging phase --\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;single\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt;  Lastly since the fission-java-core is currently in the snapshot release, you need to explicitely add the sonatype repository which is where it is published.\n\t\u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;fission-java-core\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;fission-java-core-snapshot\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://oss.sonatype.org/content/repositories/snapshots/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt;  Building the package For building the source Java code with Maven, you either need Maven and Java installed locally or you can use the build.sh helper script which builds the code inside a docker image which has those dependencies.\ndocker run -it --rm -v \u0026quot;$(pwd)\u0026quot;:/usr/src/mymaven -w /usr/src/mymaven maven:3.5-jdk-8 mvn clean package  At this stage we assume that build succeeded and you have the JAR file of the function ready.\nDeploying the function First you will need to create an environment. The extract flag is important for Java based applications packaged as JAR file. This flag will ensure that the fetcher won\u0026rsquo;t extract the JAR file into a directory. Currently JVM environment only supports version 2 \u0026amp; above so we specify the environment version as 2\n$ fission env create --name jvm --image fission/jvm-env --version 2 --extract=false  When creating the function we provide the JAR file built in earlier steps and the environment. The entrypoint signifies the fully qualified name of the class which implements the Fission\u0026rsquo;s Function interface.\n$ fission fn create --name hello --deploy target/hello-world-1.0-SNAPSHOT-JAR-with-dependencies.JAR --env jvm --entrypoint io.fission.HelloWorld  Lastly you can create a route and test that the function works!\n$ fission route create --function hello --url /hellon --method GET $ curl $FISSION_ROUTER/hello Hello World!  What\u0026rsquo;s next  More examples can be found in examples directory on GitHub  "
},
{
	"uri": "https://docs.fission.io/0.11.0/tutorial/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.fission.io/0.11.0/workflows/",
	"title": "Fission Workflows",
	"tags": [],
	"description": "",
	"content": " Prerequisites Fission Workflows requires the following components to be installed on your local machine:\n kubectl helm  Fission Workflows is deployed on top of a Kubernetes cluster. If you don\u0026rsquo;t have a Kubernetes cluster, here\u0026rsquo;s a quick guide to set one up. It also requires a Fission deployment to be present on your Kubernetes cluster. If you do not have a Fission deployment, follow Fission\u0026rsquo;s installation guide.\n(Note that Fission Workflows 0.5.0 requires Fission 0.4.1 or higher, with the NATS component installed!)\nInstalling Fission Workflows Fission Workflows is an add-on to Fission. You can install both Fission and Fission Workflows using helm charts.\nAssuming you have your Kubernetes cluster set up with a functioning deployment of Fission 0.4.1 or higher, run the following commands:\n# If you haven't already, add the Fission charts repo $ helm repo add fission-charts https://fission.github.io/fission-charts/ $ helm repo update # Install Fission Workflows $ helm install --wait -n fission-workflows fission-charts/fission-workflows --version 0.5.0  Creating your first workflow After installing Fission and Workflows, you\u0026rsquo;re all set to run a simple test workflow. With the following code snippet you will be able to deploy and run a small workflow example:\n# Fetch the required files, alternatively you could clone the fission-workflow repo $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.5.0/examples/whales/fortune.sh \u0026gt; fortune.sh $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.5.0/examples/whales/whalesay.sh \u0026gt; whalesay.sh $ curl https://raw.githubusercontent.com/fission/fission-workflows/0.5.0/examples/whales/fortunewhale.wf.yaml \u0026gt; fortunewhale.wf.yaml # # Add binary environment and create two test functions on your Fission setup: # $ fission env create --name binary --image fission/binary-env $ fission function create --name whalesay --env binary --deploy ./whalesay.sh $ fission function create --name fortune --env binary --deploy ./fortune.sh # # Create a workflow that uses those two functions. A workflow is just # a function that uses the \u0026quot;workflow\u0026quot; environment. # $ fission function create --name fortunewhale --env workflow --src ./fortunewhale.wf.yaml # # Map an HTTP GET to your new workflow function: # $ fission route create --method GET --url /fortunewhale --function fortunewhale # # Invoke the workflow with an HTTP request: # $ curl ${FISSION_ROUTER}/fortunewhale  This last command, the invocation of the workflow, should return a whale saying something wise\n ______________________________________ / Anthony's Law of Force: \\ | | \\ Don't force it; get a larger hammer. / -------------------------------------- \\ \\ \\ ## . ## ## ## == ## ## ## ## ## === /\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\\___/ === { / ===- \\______ O __/ \\ \\ __/ \\____\\_______/  So what happened here? Let\u0026rsquo;s see what the workflow consists of (for example by running cat fortunewhale.wf.yaml):\n# This whale shows off a basic workflow that combines both Fission Functions (fortune, whalesay) and internal functions (noop) apiVersion: 1 output: WhaleWithFortune tasks: InternalFuncShowoff: run: noop GenerateFortune: run: fortune requires: - InternalFuncShowoff WhaleWithFortune: run: whalesay inputs: \u0026quot;{$.Tasks.GenerateFortune.Output}\u0026quot; requires: - GenerateFortune  What you see is the YAML-based workflow definition of the fortunewhale workflow. A workflow consists of multiple tasks, which are steps that it needs to complete. Each task has a unique identifier, such as GenerateFortune, a reference to a Fission function in the run field. Optionally, it can contain inputs which allows you to specify inputs to the task, as well as contain requires which allows you to specify which tasks need to complete before this task can start. Finally, at the top you will find the output field, which specifies the task whose output is used as the workflow\u0026rsquo;s output.\nIn this case, the fortunewhale workflow consists of a sequence of 3 tasks:\nInternalFuncShowoff -\u0026gt; GenerateFortune -\u0026gt; WhaleWithFortune  First, it starts with InternalFuncShowoff by running noop, which is an internal function in the workflow engine. Internal functions are run inside of the workflow engine, which makes them run much faster at the cost of expressiveness and scalability. So typically, light-weight functions, such as logic or control flow operations, are good candidates to be used as internal functions. Besides, a minimal set of predefined internal functions, you can define internal function - there is nothing special about them.\nAfter InternalFuncShowff completes, the GenerateFortune task can start as its requires has been fulfilled. It runs the fortune Fission function, which outputs a random piece of wisdom.\nAfter GenerateFortune completes, the WhaleWithFortune task can start. This task uses a javascript expression in its inputs to reference the output of the GenerateFortune task. In the inputs of a task you can reference anything in the workflow, such as outputs, inputs, and task definitions, or just provide a constant value. The workflow engine invokes the whalesay fission function with as input the piece of wisdom, which outputs the ASCI whale that wraps the phrase.\nFinally, with all tasks completed, the workflow engine uses the top-level output field to fetch the output of the WhaleWithFortune and return it to the user. As the workflow engine adheres to the Fission function specification, a Fission workflow is just another Fission Function. This means that you could use this workflow as a function in the run in other workflows.\nWhat\u0026rsquo;s next? To learn more about the Fission Workflows system and its advanced concepts, see the documentation on Github.\nOr, check out the examples for more example workflows.\nIf something went wrong, we\u0026rsquo;d love to help \u0026ndash; please drop by the slack channel and ask for help.\n"
},
{
	"uri": "https://docs.fission.io/0.11.0/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.fission.io/0.11.0/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.fission.io/0.11.0/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]